# GrammerParser (F:\\Univer\\ЛОИС\\_Практика\\Lab1\\Grammer.g)
# Generated by ANTLR 3.1.1 on 2008-10-15 21:29:31

require 'GrammerLexer'

class GrammerParser
	attr_reader :lexer
	
    TOKENS = [
        ["INTEGER", 1],
        ["DECIMAL", 2],
        ["DIGIT", 3],
        ["WS", 4],
        ["'+'", 5],
        ["'-'", 6],
        ["'*'", 7],
        ["'/'", 8],
        ["'%'", 9],
        ["'ln'", 10],
        ["'^'", 11],
        ["'('", 12],
        ["')'", 13],
        ["'PI'", 14],
        ["'E'", 15]
    ].inject({}) { |hash, pair|
        name = pair[0]
        index = pair[1] + 3 # hardcoded for now... no way to get this value from ANTLR

        if name[0] == ?'
            hash[:"T#{index}"] = index
        else
            hash[:"#{name}"] = index
        end

        hash
    }
    
    TOKENS[:EOF] = -1

    def initialize(input)
        if input.respond_to?(:to_str) || input.respond_to?(:read)
            input = GrammerLexer.new(input)
        end

		@lexer = input
        @input = TokenStream.new(input)
        @backtracking = 0
        @failed = false


    end

    # 6:1: evaluate returns [result] : r= expression ;
    def evaluate()
    	 _retval_result = nil 



        # 6:28: r= expression
        _r = [Grammer.expression,index=2,line=8]()

         result = r 



        return _retval_result
    end

    # 8:1: expression returns [result] : r= mult ( '+' r2= mult | '-' r2= mult )* ;
    def expression()
    	 _retval_result = nil 



        # 8:30: r= mult ( '+' r2= mult | '-' r2= mult )*
        _r = [Grammer.mult,index=3,line=17]()

        # 8:37: ( '+' r2= mult | '-' r2= mult )*
        while true
            alt1 = 3
            # 
            look_ahead1_0 = look_ahead(1)
            if look_ahead1_0 == :T__8  
                alt1 = 1
            elsif look_ahead1_0 == :T__9  
                alt1 = 2
            end
            case alt1
                when 1
                    # 9:5: '+' r2= mult
                    match(:T__8)
                    _r2 = [Grammer.mult,index=3,line=17]()


                            r += r2
                        
                when 2
                    # 12:5: '-' r2= mult
                    match(:T__9)
                    _r2 = [Grammer.mult,index=3,line=17]()


                            r -= r2
                        
                else
                    break
            end
        end
         result = r 



        return _retval_result
    end

    # 17:1: mult returns [result] : r= log ( '*' r2= log | '/' r2= log | '%' r2= log )* ;
    def mult()
    	 _retval_result = nil 



        # 17:24: r= log ( '*' r2= log | '/' r2= log | '%' r2= log )*
        _r = [Grammer.log,index=4,line=29]()

        # 17:30: ( '*' r2= log | '/' r2= log | '%' r2= log )*
        while true
            alt2 = 4
            # 
            case look_ahead(1)
                when :T__10
                    alt2 = 1
                when :T__11
                    alt2 = 2
                when :T__12
                    alt2 = 3
            end
            case alt2
                when 1
                    # 18:5: '*' r2= log
                    match(:T__10)
                    _r2 = [Grammer.log,index=4,line=29]()


                            r *= r2
                        
                when 2
                    # 21:5: '/' r2= log
                    match(:T__11)
                    _r2 = [Grammer.log,index=4,line=29]()


                            r /= r2
                        
                when 3
                    # 24:5: '%' r2= log
                    match(:T__12)
                    _r2 = [Grammer.log,index=4,line=29]()


                            r %= r2
                        
                else
                    break
            end
        end
         result = r 



        return _retval_result
    end

    # 29:1: log returns [result] : ( 'ln' r= exp | r= exp );
    def log()
    	 _retval_result = nil 



        # 29:21: ( 'ln' r= exp | r= exp )
        alt3 = 2
        # 
        look_ahead3_0 = look_ahead(1)
        if look_ahead3_0 == :T__13  
            alt3 = 1
        elsif (TOKENS[look_ahead3_0] >= 4 && TOKENS[look_ahead3_0] <= 5) || look_ahead3_0 == :T__15 || (TOKENS[look_ahead3_0] >= 17 && TOKENS[look_ahead3_0] <= 18)  
            alt3 = 2
        else
            raise "Expected: "
        end
        case alt3
            when 1
                # 29:23: 'ln' r= exp
                match(:T__13)
                _r = [Grammer.exp,index=5,line=33]()

                 result = Math::log(r) 
            when 2
                # 30:7: r= exp
                _r = [Grammer.exp,index=5,line=33]()

                 result = r 
        end



        return _retval_result
    end

    # 33:1: exp returns [result] : r= atom ( '^' r2= atom )? ;
    def exp()
    	 _retval_result = nil 



        # 33:23: r= atom ( '^' r2= atom )?
        _r = [Grammer.atom,index=6,line=36]()

        # 33:30: ( '^' r2= atom )?
        alt4 = 2
        # 
        look_ahead4_0 = look_ahead(1)

        if look_ahead4_0 == :T__14  
            alt4 = 1
        end
        case alt4
            when 1
                # 33:31: '^' r2= atom
                match(:T__14)
                _r2 = [Grammer.atom,index=6,line=36]()

                 r = r ** r2 
        end
         result = r 



        return _retval_result
    end

    # 36:1: atom returns [result] : (n= INTEGER | n= DECIMAL | '(' r= expression ')' | 'PI' | 'E' );
    def atom()
    	 _retval_result = nil 
    	_n = nil




        # 36:22: (n= INTEGER | n= DECIMAL | '(' r= expression ')' | 'PI' | 'E' )
        alt5 = 5
        # 
        case look_ahead(1)
            when :INTEGER
                alt5 = 1
            when :DECIMAL
                alt5 = 2
            when :T__15
                alt5 = 3
            when :T__17
                alt5 = 4
            when :T__18
                alt5 = 5
            else
                raise "Expected: "

        end
        case alt5
            when 1
                # 37:5: n= INTEGER
                _n = @input.look_ahead(1)
                match(:INTEGER)
                 result = _n.text.to_i 
            when 2
                # 38:5: n= DECIMAL
                _n = @input.look_ahead(1)
                match(:DECIMAL)
                 result = _n.text.to_f 
            when 3
                # 39:5: '(' r= expression ')'
                match(:T__15)
                _r = [Grammer.expression,index=2,line=8]()

                 result = r 
                match(:T__16)
            when 4
                # 40:5: 'PI'
                match(:T__17)
                 result = Math::PI 
            when 5
                # 41:5: 'E'
                match(:T__18)
                 result = Math::E 
        end



        return _retval_result
    end


    private

    class TokenStream
        attr_reader :index

        def initialize(input)
            @buffer = []
            @input = input
            @channel = nil

            @index = 0;
        end

        # returns a Token
        def look_ahead(pos)
            offset = @index + pos - 1

            while @buffer[-1] != :EOF && @buffer.length < offset + 1
                token = @input.next_token
                if token == :EOF || token.channel == @channel
                    @buffer << token
                end
            end

            offset = -1 if offset >= @buffer.length
            if offset < @buffer.length
                @buffer[offset]
            end
        end

        def mark
            @state = { :index => @index }
            return 0
        end

        def rewind(marker)
            @index = @state[:index]
        end

        def consume
           look_ahead(1) # force a read from the input if necessary
           @index = @index + 1
        end
    end

    def match(token = nil)
        if token.nil? || look_ahead(1) == token
            @input.consume
            @failed = false
            return
        elsif @backtracking > 0
            @failed = true
        else
            raise "Expected #{token}"
        end
    end

    def look_ahead(k)
        token = @input.look_ahead(k)
        if token != :EOF
            token = token.token_type
        end

        token
    end


end