## Generated by rbison version 0.0.7.

class BDParser

    class ParseError < StandardError ; end
    class LexError < StandardError ; end
    NULL = nil

    attr :yydebug, true
    attr :yyerror, true

    SMALL_STR = 258
    BIG_STR = 259
    ENTER_S = 260
    END_S = 261
    ZAP = 262
    RULE_NEXT = 263
    DOT_ZAP = 264
    DOT = 265
    QUESTION = 266
	
    ## Parser declarations begin
    attr_reader :equals, :facts, :rules
    def init_data
    	@equals = Array.new
    	@facts = Array.new
    	@rules = Array.new
    end
    class Equal
    	def to_s
    		"Equalitation: '"+@name+"' of ('"+@left+"' <=> '"+@right+"')"
    	end
    	def initialize(name, left, right)
    		@name, @left, @right = name, left, right
    	end
    end
    class Fact
    	def to_s
    		"Fact: '"+@name+"' of ('"+@params.join("', '")+"')"
    	end
    	def initialize(name, params)
    		@name, @params = name, params
    	end
    end
    class PredicateTerm
    	def to_s
    		"'"+@name+"' ( '"+@params.join("', '") +"' )"
    	end
    	def initialize(name,params)
    		@name, @params = name, params
    	end
    end
    class Rule
        	def to_s
        		"Rule: get \""+@to_predicate.to_s+"\" from "+"\""+@from_predicates.join("\", \"")+"\""
        	end
        	def initialize(to_predicate, from_predicates_datas)
            		@from_predicates = Array.new
            		from_predicates_datas.each { |i| @from_predicates.push( PredicateTerm.new( i[0], i[1] ) ) }
            		@to_predicate = PredicateTerm.new( to_predicate[0], to_predicate[1] )
    	end
    end
    ## Parser declarations end

    YYFINAL = 49
    YYFLAG = -32768
    YYNTBASE = 12
    YYTRANSLATE = [ 0,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     1,     2,     3,     4,     5,
     6,     7,     8,     9,    10,    11
    ]
    YYPRHS = [ 0,
     0,     1,     4,     7,    10,    12,    14,    19,    24,    26,
    28,    32,    36,    40,    44,    46,    50,    52,    57,    61,
    63,    65,    67,    69,    71,    73
    ]
    YYRHS = [ -1,
    13,    12,     0,    14,    10,     0,    20,    10,     0,    15,
     0,    16,     0,    26,     5,    21,     6,     0,    29,     5,
    17,     6,     0,    18,     0,    19,     0,    28,     7,    28,
     0,    26,     7,    26,     0,    23,     8,    22,     0,    21,
     7,    28,     0,    28,     0,    22,     9,    23,     0,    23,
     0,    26,     5,    24,     6,     0,    24,     7,    25,     0,
    25,     0,    28,     0,    27,     0,     4,     0,     4,     0,
     3,     0,     3,     0
    ]
    YYRLINE = [ 0,
    59,    60,    63,    64,    67,    68,    72,    79,    87,    89,
    94,    99,   103,   111,   113,   118,   120,   125,   132,   134,
   139,   140,   144,   148,   152,   156
    ]
    YYTNAME = [ "$","error","$undefined.","SMALL_STR",
"BIG_STR","ENTER_S","END_S","ZAP","RULE_NEXT","DOT_ZAP","DOT","QUESTION","input",
"bz","fact","predicate_fact","equal","pair_equal_name","pair_const_name","pair_predicate_name",
"rule","const_list","predicate_term_list","predicate_term","parameter_list",
"parameter_name","predicate_name","variable_name","const_name","equal_name",
""
    ]
    YYR1 = [ 0,
    12,    12,    13,    13,    14,    14,    15,    16,    17,    17,
    18,    19,    20,    21,    21,    22,    22,    23,    24,    24,
    25,    25,    26,    27,    28,    29
    ]
    YYR2 = [ 0,
     0,     2,     2,     2,     1,     1,     4,     4,     1,     1,
     3,     3,     3,     3,     1,     3,     1,     4,     3,     1,
     1,     1,     1,     1,     1,     1
    ]
    YYDEFACT = [ 1,
    26,    23,     1,     0,     5,     6,     0,     0,     0,     0,
     2,     3,     4,     0,     0,     0,    13,    17,     0,    25,
    24,     0,     0,    20,    22,    15,     0,     9,    10,     0,
     0,     0,     0,     7,     0,    18,     0,     8,     0,     0,
    16,    21,    14,    19,    12,    11,     0,     0,     0
    ]
    YYDEFGOTO = [ 11,
     3,     4,     5,     6,    27,    28,    29,     7,    22,    17,
     8,    23,    24,     9,    25,    42,    10
    ]
    YYPACT = [ 2,
-32768,-32768,     2,    10,-32768,-32768,    11,     8,    12,    17,
-32768,-32768,-32768,    20,     4,     6,    18,-32768,    21,-32768,
-32768,     5,     7,-32768,-32768,-32768,     9,-32768,-32768,    22,
    23,    20,     4,-32768,    28,-32768,     4,-32768,    20,    28,
-32768,-32768,-32768,-32768,-32768,-32768,    32,    33,-32768
    ]
    YYPGOTO = [ 34,
-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
   -13,-32768,    -2,   -14,-32768,   -12,-32768
    ]
    YYLAST = 35
    YYTABLE = [ 19,
    18,    30,    26,    31,     1,     2,    20,    21,    20,     2,
    34,    35,    36,    37,    38,    14,    15,    19,    41,    12,
    13,    16,    43,     2,    45,    33,    32,    46,    39,    40,
    20,    48,    49,    47,    44
    ]
    YYCHECK = [ 14,
    14,    16,    15,    16,     3,     4,     3,     4,     3,     4,
     6,     7,     6,     7,     6,     8,     5,    32,    32,    10,
    10,     5,    35,     4,    39,     5,     9,    40,     7,     7,
     3,     0,     0,     0,    37
    ]
    YYEMPTY = -2
    YYEOF = 0
    YYTERROR = 1
    
    def initialize
	@yyerror = $stderr
	@yydebug = false
    end
    
    def yyparse(lexer)
	yyerrstatus = 0
	yychar = YYEMPTY
	yystate = 0
	yyss = []
	yyvs = ["nil"]
	yyval = 0
	jump = :YYNEWSTATE

	while true
	    
	    case jump
	
	    when :YYNEWSTATE
		if @yydebug
		    printf(@yyerror, "Entering state %d\n", yystate)
		end
		yyss.push(yystate)
		jump = :YYBACKUP
		next
	
	    when :YYBACKUP
		yyn = YYPACT[yystate]
		if yyn == YYFLAG
		    jump = :YYDEFAULT
		    next
		end
	
		## get a lookahead token if we don't already have one
		if yychar == YYEMPTY
		    if @yydebug
			printf(@yyerror, "Reading a token: ")
		    end
		    begin
			yychar, yylval = lexer.yylex
# sidorovis debug info
#			puts yylval
		    rescue LexError
			raise ParseError, "lex error"
		    end
		end
	
		## if lookahead <= 0, end of input
		if yychar <= 0
		    yychar1 = 0
		    yychar = YYEOF
		    if @yydebug
			printf(@yyerror, "Now at end of input.\n")
		    end
		else
		    yychar1 = yychar < 0 || yychar > 266 ? 30 : YYTRANSLATE[yychar]
		    if @yydebug
			printf(@yyerror, "Next token is %d (%s,%s)\n", yychar,
			       YYTNAME[yychar1], yylval)
		    end
		end
	
		## see if we know what to do with this token in this state
		yyn += yychar1
		if yyn < 0 || yyn > YYLAST || YYCHECK[yyn] != yychar1
		    jump = :YYDEFAULT
		    next
		end
	
		## yyn is what to do for this token type in this state
		## negative -> reduce, - yyn is the rule number
		## positive -> shift, yyn is the new state
		##    New state is final state, don't bother to shift, just
		##    return success
		## 0, or most negative number -> error
		yyn = YYTABLE[yyn]
		if yyn < 0
		    if yyn == YYFLAG
			jump = :YYERRLAB
			next
		    end
		    yyn = - yyn
		    jump = :YYREDUCE
		    next
		elsif yyn == 0
		    jump = :YYERRLAB
		    next
		end
	    
		if yyn == YYFINAL
		    return ## accept
		end
	   
		## shift the lookahead token
		if @yydebug
		    printf(@yyerror, "Shifting token %d (%s), ", yychar,
			   YYTNAME[yychar1])
		end
		
		## discard the token being shifted unless it is eof
		if yychar != YYEOF
		    yychar = YYEMPTY
		end
		yyvs.push(yylval)
		
		## count tokens shifted since error; after, three turn off
		## error status
		yyerrstatus -= 1 if yyerrstatus > 0

		yystate = yyn
		jump = :YYNEWSTATE
		next
	
	    when :YYDEFAULT
		yyn = YYDEFACT[yystate]
		if yyn == 0
		    jump = :YYERRLAB
		    next
		else
		    jump = :YYREDUCE
		    next
		end
	
		## do a reduction. yyn is the number of the rule to reduce with
	    when :YYREDUCE
		yylen = YYR2[yyn]
		if yylen > 0
		    yyval = yyvs[yyvs.size - yylen]
		end
		
		if @yydebug
		    printf(@yyerror, "Reducing via rule %d (line %d), ", yyn,
			   YYRLINE[yyn])
		    i = YYPRHS[yyn]
		    while YYRHS[i] > 0
			printf(@yyerror, "%s ", YYTNAME[YYRHS[i]])
			i += 1
		    end
		    printf(@yyerror, " -> %s\n", YYTNAME[YYR1[yyn]])
		end
	
		case yyn
		when 7
		    	
		    yyval = [ yyvs[-4], yyvs[-2] ]    
		    @facts.push( Fact.new(yyvs[-4], yyvs[-2]) )
		    
		when 8
		    	
		    yyval = [ yyvs[-4], yyvs[-2] ]    
		    @equals.push( Equal.new(yyvs[-4],yyvs[-2][0], yyvs[-2][1]) )
		    
		when 9
		    	yyval = yyvs[-1]   
		when 10
		    	yyval = yyvs[-1]   
		when 11
		    	yyval = [ yyvs[-3], yyvs[-1] ]   
		when 12
		    	yyval = [ yyvs[-3], yyvs[-1] ]   
		when 13
		    	
		    yyval = [ yyvs[-3], yyvs[-1] ]    
		    @rules.push( Rule.new( yyvs[-3] , yyvs[-1] ) )
		    
		when 14
		    	yyval = yyvs[-3].push( yyvs[-1] )   
		when 15
		    	yyval = [ yyvs[-1] ]   
		when 16
		    	yyval = yyvs[-3].push( yyvs[-1] )   
		when 17
		    	yyval = [ yyvs[-1] ]   
		when 18
		    
		    yyval = [ yyvs[-4], yyvs[-2] ]
		    
		when 19
		    	yyval = yyvs[-3].push( yyvs[-1] )   
		when 20
		    	yyval = [ yyvs[-1] ]   
		when 23
		     predicate_name = yylval
		when 24
		     variable_name = yylval
		when 25
		     const_name = yylval
		when 26
		     equal_name = yylval
		when -65536 ## never used, placeholder for ruby
		end
		
		if yylen > 0
		    yyss[(yyss.size - yylen) .. (yyss.size - 1)] = []
		    yyvs[(yyvs.size - yylen) .. (yyvs.size - 1)] = []
		end
		
		yyvs.push(yyval)
	
		if @yydebug
		    printf(@yyerror, "State stack now: %s\n", yyss.join(' '))
		    printf(@yyerror, "Value stack now: %s\n", yyvs.join(' '))
		end
		
		## "Shift" the result of the reduction.
		yyn = YYR1[yyn]
		yystate = YYPGOTO[yyn - YYNTBASE] + yyss[-1]
		if yystate >=0 && yystate <= YYLAST &&
			YYCHECK[yystate] == yyss[-1]
		    yystate = YYTABLE[yystate]
		else
		    yystate = YYDEFGOTO[yyn - YYNTBASE]
		end
		jump = :YYNEWSTATE
		next
	
	    when :YYERRLAB
		if yyerrstatus == 0 && @yydebug
		    printf(@yyerror, "Parse error!\n")
		end
		jump = :YYERRLAB1
		next
		
	    when :YYERRLAB1
		if yyerrstatus == 3
		    if yychar == YYEOF
			raise ParseError, "parse error"
		    end
		    if @yydebug
			printf(@yyerror, "Discarding token %d (%s).\n", yychar,
			       YYTNAME[yychar1])
		    end
		    yychar = YYEMPTY
		end
	    
		yyerrstatus = 3
		jump = :YYERRHANDLE
		next

	    when :YYERRPOP
		if yyvs.empty?
		    raise ParseError, "parse error"
		end
		## don't pop if the state on top of the stack can handle
		## the error token
		yystate = yyss[-1]
		if YYCHECK[YYPACT[yystate] + YYTERROR] != YYTERROR
		    yyvs.pop
		    yyss.pop
		    if @yydebug
			printf(@yyerror, "Error: state stack now: %s\n",
			       yyss.join(' '))
			printf(@yyerror, "Error: Value stack now: %s\n",
			       yyvs.join(' '))
		    end
		end
		jump = :YYERRHANDLE
		next

	    when :YYERRHANDLE
		yyn = YYPACT[yystate]
		if yyn == YYFLAG
		    jump = :YYERRPOP
		    next
		end

		yyn += YYTERROR
		if yyn < 0 || yyn > YYLAST || YYCHECK[yyn] != YYTERROR
		    jump = :YYERRPOP
		    next
		end
    
		yyn = YYTABLE[yyn]
		if yyn < 0
		    if yyn == YYFLAG
			jump = :YYERRPOP
			next
		    end
		    yyn = -yyn
		    jump = :YYREDUCE
		    next
		elsif yyn == 0
		    jump = :YYERRPOP
		    next
		end
    
		if yyn == YYFINAL
		    return ## accept
		end
    
		if @yydebug
		    printf(@yyerror, "Shifting error token, ")
		end
    
		yyvs.push(yylval)
		yystate = yyn
		jump = :YYNEWSTATE
		next
		
	    end ## case
	    
	end ## while true
	
    end ## yyparse

end ## class

## Additional user code
