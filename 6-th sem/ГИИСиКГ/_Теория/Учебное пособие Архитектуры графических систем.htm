<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0040)http://ermak.cs.nstu.ru/kg_rivs/kg03.htm -->
<HTML><HEAD><TITLE>Учебное пособие "Архитектуры графических систем"</TITLE>
<META content="text/html; charset=windows-1251" http-equiv=Content-Type>
<META content="MSHTML 5.00.2014.210" name=GENERATOR></HEAD>
<BODY aLink=#ff0000 
background="Учебное пособие Архитектуры графических систем_files/mainback.gif" 
bgColor=#ffffff bgProperties=fixed link=#0000ff text=#000000 vLink=#008000>
<TABLE align=center width="100%">
  <TBODY>
  <TR>
    <TD align=middle vAlign=top><IMG alt="Логотип НГТУ" border=0 height=100 
      hspace=10 
      src="Учебное пособие Архитектуры графических систем_files/logo.gif" 
      title=НГТУ width=135></TD>
    <TD align=left vAlign=center><A name=top title="Ваше учебное заведение">
      <H3>Новосибирский Государственный Технический Университет.<BR>Факультет 
      автоматики и вычислительной техники<BR>Кафедра вычислительной техники 
      (специальность 220100).</H3></A>
      <HR align=center SIZE=5 width="100%">
    </TD></TR></TBODY></TABLE>
<DIV align=center>
<H2><FONT color=#ff0000 face="">Учебное пособие "Архитектуры графических 
систем"</FONT></H2></DIV>
<P align=center title=""><B>МАШИННАЯ ГРАФИКА<BR>(Учебное пособие в 3-х 
книгах)<BR>Книга 3<BR><BR>П.В.Вельтмандер</B> </P>
<P>Назначение курса - обучение машинной графике студентов физико-технического 
профиля. Курс ориентирован на две основные категории будущих специалистов: 
<UL type=square>
  <LI>разработчики программно-технических средств машинной графики, 
  <LI>разработчики прикладных пакетов, приближенные к техническим средствам. 
  </LI></UL>
<P><BR>Курс разбит на три части, выпущенные в виде отдельных книг:<BR>
<OL>
  <LI><A href="http://ermak.cs.nstu.ru/kg_rivs/kg01.htm" 
  title='Учебное пособие "Вводный курс".'>Вводный курс.</A> 
  <LI><A href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm" 
  title='Учебное пособие "Алгоритмы компьютерной графики ".'>Алгоритмы 
  компьютерной графики.</A> 
  <LI><A href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm" 
  title='Учебное пособие "Архитектуры графических систем"'>Архитектуры 
  графических систем.</A> </LI></OL>
<P>
<CENTER>Рецензент<BR>канд. физ.-мат. наук, С.И.&nbsp;Упольников </CENTER>
<P align=right>ISBN&nbsp;&nbsp;5-230-13583-2<BR>© Новосибирский государственный 
университет, 1997 </P>
<H3>Оглавление </H3><A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#tth_ved">ВВЕДЕНИЕ</A><BR><A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#tth_sEc0.1">0.1&nbsp; 
ИНТЕРАКТИВНЫЕ СИСТЕМЫ МАШИННОЙ ГРАФИКИ</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#tth_sEc0.1.1">0.1.1&nbsp; 
Графические языки высокого уровня</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#tth_sEc0.1.2">0.1.2&nbsp; 
Синтаксические расширения алгоритмических 
языков</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#tth_sEc0.1.3">0.1.3&nbsp; 
Процедурные графические языки</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#tth_sEc0.1.4">0.1.4&nbsp; Языки 
диалога</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#tth_sEc0.1.5">0.1.5&nbsp; 
Выводы</A><BR><A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#tth_sEc0.2">0.2&nbsp; АРХИТЕКТУРА 
ГРАФИЧЕСКИХ РАБОЧИХ СТАНЦИЙ</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#tth_sEc0.2.1">0.2.1&nbsp; 
Компоненты современных растровых дисплейных 
систем</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#tth_sEc0.2.2">0.2.2&nbsp; 
Видеопамять</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#tth_sEc0.2.2.1">Регенерация 
видеопамяти</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#tth_sEc0.2.2.2">Модификация 
данных в видеопамяти</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#tth_sEc0.2.3">0.2.3&nbsp; 
Технические средства формирования 
изображений</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#tth_sEc0.2.3.1">Графические 
процессоры TMS-34010 и 
TMS-34020</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#tth_sEc0.2.3.2">Графический 
сопроцессор Intel 
82786</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#tth_sEc0.2.3.3">Набор графических 
СБИС National AGCS</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#tth_sEc0.2.4">0.2.4&nbsp; 
RISC-процессор с графическим устройством 
(i860)</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#tth_sEc0.2.5">0.2.5&nbsp; 
Высокоскоростные графические 
системы</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#tth_sEc0.2.5.1">Требования к 
высокоскоростным графическим 
системам</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#tth_sEc0.2.5.2">Система Silicon 
Graphics POWER IRIS 4D/380 
VGX</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#tth_sEc0.2.5.3">Система Stardent 
GS2000</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#tth_sEc0.2.6">0.2.6&nbsp; 
Выводы</A><BR><A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#tth_sEc0.3">0.3&nbsp; 
СТАНДАРТИЗАЦИЯ В МАШИННОЙ ГРАФИКЕ</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#tth_sEc0.3.1">0.3.1&nbsp; NGP 
(Network graphics рrotocol)</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#tth_sEc0.3.2">0.3.2&nbsp; 
Международная деятельность по стандартизации в машинной 
графике</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#tth_sEc0.3.3">0.3.3&nbsp; 
Деятельность ISO, IEC по стандартизации в машинной 
графике</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#tth_sEc0.3.4">0.3.4&nbsp; 
Классификация стандартов</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#tth_sEc0.3.5">0.3.5&nbsp; 
Core-System</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#tth_sEc0.3.6">0.3.6&nbsp; GKS 
(Graphical Kernel System)</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#tth_sEc0.3.7">0.3.7&nbsp; GKS-3D 
(Graphical Kernel System for Three Dimensions)</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#tth_sEc0.3.8">0.3.8&nbsp; PHIGS 
(Programmer's Hierarchical Interactive Graphics Sys 
-tem)</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#tth_sEc0.3.9">0.3.9&nbsp; 
PHIGS+</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#tth_sEc0.3.10">0.3.10&nbsp; CGI 
(Computer Graphics Interface)</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#tth_sEc0.3.11">0.3.11&nbsp; 
Графические протоколы</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#tth_sEc0.3.11.1">Аппаратно-зависимые 
графические протоколы</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#tth_sEc0.3.11.2">Языки описания 
страниц</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#tth_sEc0.3.11.3">Аппаратно-независимые 
графические протоколы</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#tth_sEc0.3.11.4">Проблемно-ориентированные 
протоколы</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#tth_sEc0.3.11.5">Растровые 
графические файлы</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#tth_sEc0.3.12">0.3.12&nbsp; X 
Window System</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#tth_sEc0.3.13">0.3.13&nbsp; 
Выводы</A><BR><A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#tth_sEc0.4">0.4&nbsp; СИСТЕМЫ 
УПРАВЛЕНИЯ ПОЛЬЗОВАТЕЛЬСКИМ ИНТЕРФЕЙСОМ (UIMS)</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#tth_sEc0.4.1">0.4.1&nbsp; Системы 
управления окнами (WMS)</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#tth_sEc0.4.2">0.4.2&nbsp; 
Инструментарий создания пользовательского 
интерфейса</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#tth_sEc0.4.3">0.4.3&nbsp; Системы 
управления интерфейсом пользователя</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#tth_sEc0.4.4">0.4.4&nbsp; 
Непосредственное манипулирование</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#tth_sEc0.4.5">0.4.5&nbsp; Пример 
реализации UIDS/UIMS</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#tth_sEc0.4.6">0.4.6&nbsp; 
Выводы</A><BR><A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#tth_sEc0.5">0.5&nbsp; VISC - 
ИНИЦИАТИВА</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#tth_sEc0.5.1">0.5.1&nbsp; AVS - 
Прикладная система научной 
визуализации</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#tth_sEc0.5.1.1">Архитектура 
системы прикладной визуализации</A><BR><A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#tth_sEc0.6">0.6&nbsp; ОЦЕНКА 
ПРОИЗВОДИТЕЛЬНОСТИ</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#tth_sEc0.6.1">0.6.1&nbsp; 
Тестовые программы (Benchmarks)</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#tth_sEc0.6.2">0.6.2&nbsp; 
Результаты тестов</A><BR><A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#tth_bib">СПИСОК 
ЛИТЕРАТУРЫ</A><BR>
<P>
<CENTER>
<H3><A name=tth_ved>ВВЕДЕНИЕ</A></H3></CENTER>Цель данной, третьей части курса 
обучения машинной графике, - дать общий обзор архитектур программных и 
технических средств машинной графики. 
<P><B>Первый раздел</B> носит вводный характер. В нем формулируются общие 
принципы построения интерактивных систем машинной графики. Анализируются подходы 
к построению средств вывода, основанные на использовании специализированных 
графических языков, синтаксических графических расширений существующих 
алгоритмических языков и процедурных расширений алгоритмических языков. 
Показывается, что наибольшее распространение получили процедурные расширения а 
также специализированные графические языки. Завершается первый раздел анализом 
организации языков диалога. 
<P><B>Во втором разделе:</B> 
<P>1.&nbsp;Разъясняются понятия "рабочей станции" и "суперстанции". 
<P>2.&nbsp;Описываются архитектурные решения используемые в рабочих станциях, в 
том числе показывается, что современные станции состоят из трех основных 
компонент - видеопамяти, графического процессора (процессоров) и 
видеоконтроллера. Особое внимание уделяется вопросам организации видеопамяти. 
<P>3.&nbsp;Анализируются основные подходы к построению средств формирования 
изображений (графических процессоров). Показывается, что основными подходами 
являются: 
<P><FONT face=symbol>·</FONT> использование специализированных, полностью 
программируемых процессоров, 
<P><FONT face=symbol>·</FONT> использование непрограммируемых графических 
сопроцессоров, реализующих фиксированный набор функций, 
<P><FONT face=symbol>·</FONT> использование специализированных СБИС для 
построения графического процессора требуемых возможностей и архитектуры. 
<P>Упомянутые основные подходы иллюстрируются на примерах СБИС фирм: 
<P><FONT face=symbol>·</FONT> Texas Instruments - графические программируемые 
микропроцессоры TMS-34010, TMS-34020; 
<P><FONT face=symbol>·</FONT> National Semiconductor - набор графических СБИС 
DP-8500, DP-8510, DP-8512, DP-8515; 
<P><FONT face=symbol>·</FONT> Intel - графический сопроцессор Intel 82786 и RISC 
микропроцессор с включением графического устройства - Intel 860. 
<P>5.&nbsp;Рассматриваются конкретные реализации высокоскоростных 3D 
суперстанций на примере систем POWER IRIS 4D/380 VGX фирмы Silicon Graphics и 
GS2000 фирмы Stardent. 
<P><B>Третий раздел</B> посвящен вопросам стандартизации в машинной графике. В 
нем описывается история работ по стандартизации, ее основные цели и задачи, 
заключающиеся в обеспечении переносимости программного обеспечения. Вводятся и 
поясняются модели переносимой графической системы. Рассматриваются организация и 
направления деятельности по стандартизации в машинной графике. Дается 
классификация стандартов на интерфейсы и протоколы. Приводятся общие описания 
различных стандартов на интерфейс в области машинной графики:<BR><FONT 
face=symbol>·</FONT>&nbsp;Core System,<BR><FONT 
face=symbol>·</FONT>&nbsp;Graphical Kernel System (GKS),<BR><FONT 
face=symbol>·</FONT>&nbsp;Graphical Kernel System for Three Dimensions 
(GKS-3D),<BR><FONT face=symbol>·</FONT>&nbsp;Programmer's Hierarchical 
Interactive Graphics System (PHIGS),<BR><FONT 
face=symbol>·</FONT>&nbsp;Programmer's Hierarchical Interactive Graphics System 
PLUS (PHIGS+), <FONT face=symbol>·</FONT>&nbsp;CGI (Computer Graphics 
Interface).<BR>Рассматриваются протоколы передачи графических данных, 
используемые в различных приложениях машинной графики 
<P><B>В четвертом разделе</B> рассматриваются активно формирующиеся в настоящее 
время подходы к проблеме обеспечения эффективности разработки человеко-машинного 
интерфейса. Важнейшей предпосылкой для решения этой проблемы является широкое 
использование современных растровых дисплейных систем и высокоскоростных каналов 
связи. В числе прочего в этом разделе рассматриваются:<BR><FONT 
face=symbol>·</FONT>&nbsp;системы управления окнами (WMS),<BR><FONT 
face=symbol>·</FONT>&nbsp;инструментарий создания пользовательского интерфейса, 
<P><FONT face=symbol>·</FONT> системы управления интерфейсом пользователя, (UIMS 
- User Interface Management Systems), точнее системы проектирования интерфейса 
пользователя (UIDS - User Interface Development Systems), 
<P><FONT face=symbol>·</FONT> техника "непосредственного манипулирования" (DM - 
Direct Manipulation).<BR>Приводится пример реализации UIDS/UIMS. 
<P><B>Пятый раздел</B> посвящен еще одной современной проблеме - проблеме 
визуализации, особенно обострившейся с широким использованием суперкомпьютеров. 
В этом разделе обсуждается ViSC инициатива в США (Visualization in Scientific 
Computing) - "Визуализация в научных исследованиях". На эти работы в США 
предполагается финансирование порядка 1% от всех затрат на машинную графику. 
<P>ViSC - инициатива охватывает (интегрирует) машинную графику, обработку 
изображений, компьютерное зрение, САПР (дизайн), обработку сигналов, 
пользовательский интерфейс. Серьезная постановка и подходы к решению этой 
проблемы стали возможны благодаря появлению суперстанций и формулированию новых 
идей и методов в программном обеспечении. 
<P>Приводится пример коммерческой системы визуализации - AVS. 
<P><B>В последнем, шестом разделе</B> излагаются методы и средства верификации и 
тестирования графических систем. Приводятся результаты тестирования более чем 
двадцати рабочих станций. 
<P></I></B></TT><U>0.&nbsp;ИНТЕРАКТИВНЫЕ СИСТЕМЫ МАШИННОЙ ГРАФИКИ</U> 
<CENTER>
<H3><A name=tth_sEc0.1>0.1</A>&nbsp;&nbsp;ИНТЕРАКТИВНЫЕ СИСТЕМЫ МАШИННОЙ 
ГРАФИКИ</H3></CENTER>
<P>Задача интерактивной системы машинной графики (рис.&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#r1_1">0.1.1</A>) при выполнении 
вывода заключается в преобразовании информации из исходного высокоуровневого 
представления предметной области в представление команд графических устройств 
вывода. При выполнении ввода, наоборот, требуется преобразование низкоуровневой 
информации от физических устройств ввода в высокоуровневую информацию на языке 
предметной области. 
<P>
<P><A name=tth_fIg0.1></A><A name=r1_1>
<CENTER><BR><IMG alt="Рисунок 1" 
src="Учебное пособие Архитектуры графических систем_files/kg0301.gif">
<P></A></CENTER>
<CENTER>Рис. 0.1.1: Обобщенная модель интерактивной системы</CENTER>
<P>
<P>Можно выделить два основных способа построения средств вывода - системы с 
графическим языком высокого уровня, включающим в себя развитые средства для 
обработки графической и геометрической информации, и системы с расширенным 
языком, которые, как правило, представляют тот или иной алгоритмический язык 
высокого уровня, расширенный средствами обработки графической и геометрической 
информации. На практике это пакет подпрограмм, реализующих требуемые 
функциональные возможности. 
<P>Ввод информации обеспечивается с помощью языка диалога. Диалог обычно 
осуществляется в виде команд, содержащих числовые значения, имена, координаты, 
произвольный текст. Выполняя ввод команд пользователь работает с тем или иным 
набором вводных устройств, определяемых лексикой языка - алфавитно-цифровой и 
функциональной клавиатурами, шаровым указателем (track ball), планшетом 
(tablett) и т.п. 
<P>Далее, в п. 1.1-1.3, будут рассмотрены различные варианты построения 
геометрических языков вывода, в п. 1.4 будут рассмотрены языки диалога. 
<P>
<CENTER>
<H3><A name=tth_sEc0.1.1>0.1.1</A>&nbsp;&nbsp;Графические языки высокого 
уровня</H3></CENTER>
<P>Имеется два подхода к построению систем программирования с языками машинной 
геометрии и графики высокого уровня. Первый подход состоит в создании 
автономного языка, второй - в необходимой модификации того или иного исходного 
алгоритмического языка. 
<P>Первый подход позволяет создать язык, наиболее соответствующий специфике 
работы с графической и геометрической информацией, но только в том классе 
приложений, для которых предназначался язык. Исторически основная область 
приложений таких языков - автоматизация программирования для оборудования с ЧПУ; 
системы автоматизации проектно-конструкторских работ, требующие средств работы с 
данными, отсутствующих в широко распространенных алгоритмических языках; системы 
геометрического моделирования. 
<P>Одним из первых проблемно-ориентированных языков, имеющих средства для 
описания геометрической информации, явился язык АРТ (AUTOMATED PROGRAMMING 
TOOLS) [<A href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#mbib57" 
name=CITEmbib57>57</A>]. Этот язык послужил основой для разработки разнообразных 
систем автоматизации программирования для станков с ЧПУ. 
<P>В работе [<A href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#mbib23" 
name=CITEmbib23>23</A>] предложен базовый проблемно-ориентированный язык 
описания графической информации ОГРА, предназначенный для описания графических 
конструкторских документов и операций их формирования в системах 
автоматизированного проектирования. 
<P>В работах [<A href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#mbib50" 
name=CITEmbib50>50</A>,] описан комплекс САГРАФ, предназначенный для 
использования в учебной системе коллективного пользования МИФИ для решения задач 
машинной геометрии и графики. В комплексе имеются подсистемы геометрического 
синтеза, геометрического анализа и графического моделирования. 
<P>В качестве примеров систем с автономным языком высокого уровня могут также 
служить системы геометрического моделирования трехмерных тел - COMPAC [<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#mbib100" 
name=CITEmbib100>100</A>,] и СИМАК-Д [<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#mbib35" name=CITEmbib35>35</A>]. 
<P>Система COMPAC (COMPUTER ORIENTED PART CODING) предназначена для формирования 
описания объемных тел из объемных элементов формы - (метод конструктивной 
геометрии). Кроме трех базовых объемных элементов (кубы, цилиндры, конусы), 
могут использоваться профилированные детали, получаемые перемещением замкнутого 
контура вдоль прямой или дуги, а также тела вращения, получаемые вращением 
замкнутого контура вокруг оси. Элементы задаются, позиционируются и 
оразмериваются языковыми конструкциями, напоминающими АРТ [<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#mbib57" name=CITEmbib57>57</A>]. 
Составление детали из объемных элементов производится с помощью операций 
объединения, вычитания и отсечения. 
<P>Отличия СИМАК-Д от COMPAC состоят в несколько ином входном языке и ином 
наборе базовых элементов формы, включающем в себя точку, плоскость, 
прямоугольный параллелепипед, круговые цилиндры и конус. 
<P>
<CENTER>* * * </CENTER>
<P>Ясно, что автономные графические языки, как всякая специализированная 
разработка, обладают высокой эффективностью в своей области приложений, однако 
разработка и использование таких языков сопряжена с рядом проблем: 
<P><FONT face=symbol>·</FONT> довольно значительные затраты на создание языка и 
транслятора с него, так, например, трудозатраты на систему COMPAC составили 
около 40 ч/лет [<A href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#mbib117" 
name=CITEmbib117>117</A>]; 
<P><FONT face=symbol>·</FONT> затраты на внедрение, на включение языка в 
работающую систему программирования и на обучение пользователей, которые не 
всегда охотно берутся за изучение еще одного языка, а предпочитают пользоваться 
процедурными расширениями известных им алгоритмических языков: ALGOL, FORTRAN, 
PL-1, PASCAL и т.д.;<BR>
<P><FONT face=symbol>·</FONT> трудности с последующим расширением языка; 
<P><FONT face=symbol>·</FONT> известные в настоящее время языки машинной 
геометрии и графики, в отличие от процедурных расширений, как правило, не 
обеспечивают интерактивного режима, а предназначены для написания пассивных 
программ; 
<P><FONT face=symbol>·</FONT> затруднено объединение в рамках одной прикладной 
программы графических и геометрических действий и обычных вычислений, которое 
легко реализуется в случае процедурных расширений. 
<P>
<CENTER>
<H3><A name=tth_sEc0.1.2>0.1.2</A>&nbsp;&nbsp;Синтаксические расширения 
алгоритмических языков</H3></CENTER>
<P>Ряд из отмеченных выше затруднений снимается при реализации второго подхода - 
синтаксическом расширении некоторого исходного алгоритмического языка. Удобство 
этого подхода заключается в том, что пользователю требуется лишь "доучиться" в 
уже известном ему языке. Расширение заключается в разработке дополнительных 
конструкций языка для описания и манипулирования графическими и геометрическими 
объектами. Возможны несколько способов реализации такого расширенного языка: 
<P><FONT face=symbol>·</FONT> модификация существующего транслятора; 
<P><FONT face=symbol>·</FONT> использование препроцессора, либо макропроцессора, 
обрабатывающего программу на расширенном языке и превращающего его в программу 
на исходном языке;<BR>
<P><FONT face=symbol>·</FONT> использование алгоритмического языка, 
предусматривающего расширение его набора типов данных и операций над ними самим 
пользователем.<BR>
<P>Несмотря на всю неприспособленность FORTRANa для эффективной обработки 
сложноструктурированных данных, неудобство его структур управления и средств 
сегментирования программ, большинство реализаций синтаксических расширений было 
связано именно с FORTRANом из-за его популярности в то время у пользователей. 
<P>Одна из первых реализаций графического расширения FORTRANа система GRAF 
(GRAPHIC ADDITIONS TO FORTRAN) [<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#mbib84" name=CITEmbib84>84</A>]. 
Расширение основывается на введении нового типа переменных DISPLAY, значениями 
которых являются последовательности графических команд устройства. Имеются 
встроенные и пользовательские DISPLAY-функции. Из DISPLAY-переменных и функций 
строятся выражения этого типа. Оператор DISPLAY-присваивания присваивает 
вычисленное значение переменной соответствующего типа. Предусмотрены средства 
стирания и вывода на оконечные устройства дисплейных переменных, чтения/записи 
дисплейного файла, опроса наличия сигналов внимания с графических устройств 
ввода. 
<P>В качестве более мощного (и позднего) графического расширения FORTRANа можно 
упомянуть систему GALA [<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#mbib99" name=CITEmbib99>99</A>]. 
Также вводится новый тип данных - BILD. Значениями этого типа могут обладать 
переменные и константы. В качестве системных констант этого типа имеются 
элементарные изображения (в том числе пустое). Над данными этого типа определены 
операторы преобразований. Для построения сложных изображений используется, так 
называемый, оператор совмещения. Над изображением определены операторы 
манипулирования и опроса. Изображения могут проверяться в условных операторах. 
Имеются операторы вывода изображений с назначением преобразований и окна 
отсечения. Средства ввода обеспечивают ожидание и получение данных, разрешение и 
запрет прерываний. GALA-программа может структурироваться на поименованные 
сегменты с параметрами или без. 
<P>В качестве одной из отечественных разработок по графическому расширению 
FORTRANа можно назвать "AВТОКОД для работы с графическим дисплеем EC-7064" [<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#mbib28" name=CITEmbib28>28</A>], 
при использовании которого обеспечивается пакетный режим работы, когда 
информация только выводится на дисплей. Операторы АВТОКОДа вставляются в текст 
на FORTRANе и помечаются в первой позиции буквой A. Предусмотрено 6 групп 
операторов: резервирования памяти и увязывания с массивами FORTRANа; описания 
точек и процедур; построения совокупностей точек, ломаных, текстов, вызовов 
процедур; ветвления; гнездования операторов; фрагментирования изображения на 
кадры и рисунки. 
<P>Наряду с FORTRANом в качестве языка для графического расширения использовался 
ALGOL. Так в [<A href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#mbib101" 
name=CITEmbib101>101</A>] описана система DIGOS, которая состоит из 
геометрически ориентированного языка, его интерпретатора и трехуровневой 
структуры данных (PDS - параметрической кольцевой структуры, элементы которой 
формируются операторами геометрически-ориентированного языка; DDSR3 - структуры 
данных 3D представления, формируемой из PDS при активации вывода; DDSR2 - 
структуры данных 2D представления, формируемой из DDSR3 при выполнении 
преобразований, проецирования и отображения). В языке предусмотрены 2 группы 
геометрических операндов - простые геометрические элементы (точки, прямые, 
плоскости, последовательности точек, поверхности, тела) и составные 
геометрические элементы, образованные либо из элементов одного, либо разных 
типов. Над геометрическими операндами определены геометрические операции. 
Графические логические операции служат для проверки значения геометрического 
операнда и проверки, содержится ли геометрический операнд в некотором другом. 
Имеются графические операции ввода/вывода и увязывания физико-технических данных 
с геометрическими операндами. 
<P>В качестве примера графического расширения PL-1 можно привести GPL/1 [<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#mbib114" 
name=CITEmbib114>114</A>], где PL-1 расширен на векторные, двух и трехмерные 
типы данных и векторные операции. Введены переменные типа IMAGE, которые могут 
принимать значения, определяемые комбинациями элементов данных изображения 
вектора, строки, функциями изображения и др. Значения переменных типа IMAGE 
состоит из двух частей - атрибутной и собственно изображения. Над изображениями 
определены операции присоединения, объединения, позиционирования, 
масштабирования, вращения. Введен тип данных GRAPHIC и совокупность атрибутов, 
описывающих данные этого типа. 
<P>Предусмотрено три разновидности элементов данных типа GRAPHIC: DESIGN, из 
которых строится изображение, все или некоторые элементы которого могут меняться 
(пример - вывод на дисплей); DISPLAY - аналогично DESIGN, но не может быть 
изменений (пример - вывод на графопостроитель); STORAGE - для запоминания и 
последующего воспроизведения изображений. 
<P>Оператор GET используется для извлечения изображения из элемента данных, 
оператор ERASE - для выборочного либо полного стирания. Предусмотрены также 
средства для ведения очереди ввода и манипулирования ею. 
<P>
<CENTER>* * * </CENTER>
<P>Анализ вышеприведенных, а также других синтаксических расширений 
алгоритмических языков показывает, что: 
<P><FONT face=symbol>·</FONT> вводятся данные графических типов; 
<P><FONT face=symbol>·</FONT> определяются операции над ними; 
<P><FONT face=symbol>·</FONT> разрабатываются средства для структуризации, 
сохранения, манипулирования и отображения изображений; 
<P><FONT face=symbol>·</FONT> устанавливаются правила ведения интерактивной 
работы. 
<P>В целом следует отметить, что подход, основанный на синтаксическом расширении 
того или иного алгоритмического языка, был характерен для раннего, скорее 
исследовательского, периода развития машинной графики и имеет следующие основные 
недостатки: 
<P><FONT face=symbol>·</FONT> требуются значительные затраты труда 
высококвалифицированных системных программистов как на этапе первоначальной 
разработки, так и при необходимости расширений; 
<P><FONT face=symbol>·</FONT> из-за использования в определенной мере 
экзотического языка безусловно нарушается переносимость прикладных программ; 
<P><FONT face=symbol>·</FONT> вводимые в язык графические конструкции не имеют 
сколько-нибудь серьезных преимуществ перед операторами вызова функций или 
подпрограмм;<BR>
<P><FONT face=symbol>·</FONT> практически все графические операторы требуют 
интерпретации, так как они, как правило, программируются как вызовы некоторых 
библиотечных подпрограмм.<BR>
<P>Выше отмеченные недостатки систем с графическим языком высокого уровня 
привели к тому, что в настоящее время наибольшее применение получили процедурные 
графические расширения алгоритмических языков, так называемые процедурные языки. 

<P>
<CENTER>
<H3><A name=tth_sEc0.1.3>0.1.3</A>&nbsp;&nbsp;Процедурные графические 
языки</H3></CENTER>
<P>Процедурные языки - это пакеты графических подпрограмм (графпакеты), 
доступные из программ на самых различных языках. Процедурные языки особенно 
удобны для тех приложений, в которых некоторой функции можно поставить в 
соответствие семантическую подпрограмму. Именно таким приложением и является 
изобразительная машинная графика, объектами которой являются искусственно 
созданные изображения. Тесно к этой области приложений прилегает и перцептивная 
машинная графика, объектами которой являются либо искусственно созданные 
изображения, либо изображения, выделенные из того или иного представления 
окружающего мира. Функционально генерацию изображений и манипуляцию с ними 
естественно представить в виде исполнения команд, использующих имена, 
координатные и иные данные, характеризующие объект манипулирования. Для 
выполнения таких действий нет необходимости в наличии графических типов данных, 
а сами действия удобно представить в соответствующих подпрограммах. Подпрограммы 
при этом фактически представляют собой мощное и легко модифицируемое 
семантическое расширение языка. Именно поэтому графические расширения языков за 
счет создания пакетов графических подпрограмм нашли самую широкую поддержку как 
со стороны разработчиков системного обеспечения, так и со стороны пользователей. 
Обрабатывающую систему (см. рис.&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#r1_1">0.1.1</A>) можно 
представить как состоящую из базовой графической системы, осуществляющую чисто 
графические функции и прикладной программы, осуществляющей необходимые 
вычисления и управление. Концептуальная модель интерактивной системы при таком 
подходе представлена на рис.&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#r1_2">0.1.2</A>. 
<P>
<P><A name=tth_fIg0.2></A><A name=r1_2>
<CENTER><BR><IMG alt="Рисунок 2" 
src="Учебное пособие Архитектуры графических систем_files/kg0302.gif"></A>
<P></CENTER>
<CENTER>Рис. 0.1.2: Концептуальная модель интерактивной системы машинной графики 
с явным выделением графической компоненты</CENTER>
<P>
<P>Назначение графической системы в такой модели состоит в преобразовании двух 
или трехмерной модели объекта, формируемой прикладной программой, в графические 
команды и данные, либо передаваемые на устройства, либо запоминаемые в той или 
иной графической структуре данных. 
<P>На пути использования пакетов графических подпрограмм достигнуты наиболее 
впечатляющие успехи в использовании и развитии средств машинной графики в том 
числе связанные с: 
<P><FONT face=symbol>·</FONT> обеспечением аппаратной независимости прикладных 
программ, т.е. независимости от конкретных используемых графических устройств 
при условии приблизительного соответствия их возможностей;<BR>
<P><FONT face=symbol>·</FONT> обеспечением адаптируемости прикладных программ, 
т.е. легкости приспособления к новым функциональным требованиям;<BR>
<P><FONT face=symbol>·</FONT> обеспечением мобильности прикладных программ, т.е. 
легкости их переноса в иное окружение.<BR>
<P>Аппаратная независимость средств отображения обеспечивается их построением по 
иерархическому принципу в виде некоторого набора логических уровней. Одна из 
разновидностей иерархического принципа - принцип перевернутой пирамиды [<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#mbib61" name=CITEmbib61>61</A>,]. 
При этом подходе на нижнем уровне располагается аппаратно-зависимый драйвер с 
минимально допустимым набором возможностей, например, позиционирование, 
построение отрезка, дуги окружности и т.д. При необходимости использования 
другого устройства достаточно заменить драйвер. Системы, построенные по принципу 
перевернутой пирамиды, например, GINO-3D [<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#mbib124" 
name=CITEmbib124>124</A>], ГРАФОР [<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#mbib3" name=CITEmbib3>3</A>], как 
правило, ориентированы на работу с несложными устройствами. Использование 
устройств с более богатыми возможностями влечет за собой либо их неэффективное 
использование, либо переделку графической системы, т.е. в сущности тормозится 
развитие средств вывода. В этом заключается основной недостаток таких систем. 
<P>Более гибкое и мощное использование иерархического принципа заключается в 
разбиении средств вывода графпакета на три логических уровня с четкой фиксацией 
уровней и соблюдением интерфейсов между ними. Каждый уровень является для 
последующего некоторым виртуальным графическим устройством. Такой подход 
позволяет безболезненно модифицировать (улучшать) отдельные уровни, легко 
распределять программное обеспечение между различными ЭВМ, стыковать графическую 
систему с другими компонентами программного обеспечения. 
<P>На первом - нижнем уровне находятся аппаратно-зависимые драйверы устройств 
(иногда организованные в виде самостоятельных графпакетов [<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#mbib13" name=CITEmbib13>13</A>]), 
обладающие достаточным набором типичных элементарных функций. Назначение этого 
уровня - формирование файлов вывода на графические устройства. 
<P>На втором - среднем уровне находится аппаратно-независимый графпакет общего 
назначения. 
<P>На третьем - верхнем уровне находятся проблемно-ориентированные графпакеты. 
<P>По иерархическому принципу организовано большинство графических систем, 
наряду с упомянутыми GIND-3D и ГРАФОРом можно назвать, например, СМОГ [<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#mbib43" 
name=CITEmbib43>43</A>,,], АТОМ [<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#mbib24" 
name=CITEmbib24>24</A>,,,,,,,], ДИГРАФ [<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#mbib7" name=CITEmbib7>7</A>,,,], 
ГРАФСМ [<A href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#mbib40" 
name=CITEmbib40>40</A>], АНЕГРАФ [<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#mbib19" name=CITEmbib19>19</A>,], 
АТЛАНТ [<A href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#mbib10" 
name=CITEmbib10>10</A>], УНИГРАФ [<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#mbib6" name=CITEmbib6>6</A>,], 
ГРАС [<A href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#mbib37" 
name=CITEmbib37>37</A>,,] и целый ряд других. 
<P>Адаптируемость прикладных программ в части средств вывода естественным 
образом обеспечивается последовательным использованием иерархического принципа, 
т.е. либо заменой требуемого уровня, либо надстройкой необходимых уровней. 
<P>Мобильность прикладных программ по отношению к изменению технических средств 
обеспечивается возможностью использования соответствующих драйверов устройств. 
Мобильность относительно ЭВМ обеспечивается реализацией функционально идентичных 
графпакетов для ЭВМ различных типов. Хорошие предпосылки для этого заключаются в 
решении вопросов стандартизации в машинной графике, которым посвящен раздел 3. 
<P>
<CENTER>* * * </CENTER>
<P>Основные преимущества подхода с использованием графпакетов состоят в 
следующем: 
<OL type=1>
  <P>
  <LI>Легкая обучаемость, так как пользователь пакета не выходит за рамки 
  удобного либо привычного ему языка. 
  <LI>Легкая расширяемость за счет написания самим пользователем подпрограмм, 
  необходимых для его приложения. Задача системных программистов состоит в том, 
  чтобы дать "базисный" пакет, пригодный для многих пользователей и многих 
  приложений. 
  <LI>Легкая переносимость прикладной программы на другие ЭВМ. 
  <LI>Легкая адаптируемость к новым требованиям либо аппаратным возможностям. 
  <LI>Легкое обеспечение многоязыковости либо за счет наличия функционально 
  идентичного пакета для другого языка, либо за счет использования одной и той 
  же библиотеки в рамках многоязыковой системы программирования, либо за счет 
  единого исполнительного модуля, доступного с помощью пакетов процедур связи из 
  различных систем программирования. </LI></OL>
<P>Очевидными недостатками такого подхода являются: 
<OL type=1>
  <P>
  <LI>Недостаточная гибкость, связанная с тем, что заранее фиксированный выбор 
  "базисного пакета" со сравнительно ограниченными средствами может значительно 
  усложнить прикладную программу, требующую функций, выходящих за рамки 
  "базисных". 
  <LI>Громоздкость, связанная с тем, что простота расширений в сочетании с 
  недостаточной гибкостью провоцирует либо на создание множества подпрограмм по 
  разному выполняющих схожие функции, либо на создание универсальных подпрограмм 
  с большим числом разного рода дополнительных параметров для преодоления 
  ограничений или неэффективностей. </LI></OL>
<P>Несмотря на отмеченные недостатки, можно уверенно утверждать, что создание 
пакетов графических подпрограмм является основным средством разработки 
графического программного обеспечения. 
<P>
<CENTER>
<H3><A name=tth_sEc0.1.4>0.1.4</A>&nbsp;&nbsp;Языки диалога</H3></CENTER>
<P>Язык диалога, наряду с прочими атрибутами, такими как полнота, точность и 
скорость решения задачи, является одной из важнейших компонент прикладной 
интерактивной системы. 
<P>Обычно предполагается, что конечным пользователем интерактивной системы 
является специалист в некоторой предметной области, решающий с помощью ЭВМ 
требуемую задачу и взаимодействующий с ЭВМ на языке предметной области (входном 
языке). 
<P>Входные языки существенно отличаются от алгоритмических языков как внешне, 
так и по применению. Фразами такого языка являются изображения и действия. 
Применение такого языка отличается тем, что входные команды интерпретируются и 
исполняются по мере их поступления от пользователя, а не транслируются в 
объектный код и лишь затем исполняются. Наибольшее распространение получили два 
типа диалога - диалог инициируемый ЭВМ и диалог инициируемый пользователем [<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#mbib52" name=CITEmbib52>52</A>]. 
Диалог в этих случаях ведется в форме "запрос-ответ". При диалоге 1-го типа 
пользователь либо заполняет форму, выдаваемую на экран, либо выбирает одну из 
альтернативных возможностей (команд). При диалоге 2-го типа пользователь подает 
те или иные допустимые в данный момент времени директивы. Альтернативные языки 
более просты в обучении и использовании, поскольку не требуют знаний форматов и 
символики различных директив, действия более просты, так как нет необходимости 
полностью вводить фразу или директиву и не надо помещать выбранный элемент 
данных в определенную позицию формата. 
<P>Различные аспекты проблемы взаимодействия человек-ЭВМ освещаются во многих 
работах [<A href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#mbib11" 
name=CITEmbib11>11</A>,,,,,,]. Так, например, в [<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#mbib54" name=CITEmbib54>54</A>] 
сформулированы требования, которым должен удовлетворять диалоговый входной 
язык:<BR><FONT face=symbol>·</FONT>&nbsp;эффективность, полнота, 
естественность;<BR><FONT face=symbol>·</FONT>&nbsp;расширяемость;<BR><FONT 
face=symbol>·</FONT>&nbsp;обеспечение обратной связи;<BR><FONT 
face=symbol>·</FONT>&nbsp;устойчивость к ошибкам;<BR><FONT 
face=symbol>·</FONT>&nbsp;адаптируемость к пользователю. 
<P>В сущности входной язык состоит из двух компонент [<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#mbib54" name=CITEmbib54>54</A>]: 
<P><FONT face=symbol>·</FONT> язык формулирования пользователем команд и входных 
данных для ЭВМ (реплики человека); 
<P><FONT face=symbol>·</FONT> язык ответов пользователю (реплики ЭВМ). 
<P>Реплики человека выражаются в действиях с различными диалоговыми 
устройствами. Реплики ЭВМ выражаются в графических образах, либо звуковых 
сообщениях. 
<P>Как уже отмечалось, к числу существенных характеристик прикладных программ 
относятся аппаратная независимость от используемых графических устройств и 
мобильность - легкость переноса в иное окружение. В пп. 1.1.3. показано, что эти 
характеристики в части средств вывода - исполнения реплик ЭВМ обеспечиваются 
использованием виртуальных устройств отображения. Достижение аппаратной 
независимости при вводе реплик человека также обеспечивается введением понятий 
виртуальных устройств ввода, являющихся абстракциями реальных физических 
устройств. Программная поддержка средств ввода строится по иерархическому 
принципу и организуется в виде пакета подпрограмм. На нижнем уровне находятся 
драйверы устройств. На верхнем - виртуальные устройства ввода. При этом одно 
виртуальное устройство ввода может быть реализовано с использованием нескольких 
физических и наоборот. 
<P>В настоящее время общепринятым считается выделение шести классов виртуальных 
устройств ввода [<A href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#mbib85" 
name=CITEmbib85>85</A>,,,]:<BR><FONT face=symbol>·</FONT>&nbsp;ЛОКАТОР для ввода 
позиции;<BR><FONT face=symbol>·</FONT>&nbsp;ШТРИХ для ввода последовательности 
позиций;<BR><FONT face=symbol>·</FONT>&nbsp;ДАТЧИК для ввода скалярного значения 
(числа);<BR><FONT face=symbol>·</FONT>&nbsp;ВЫБОР для выбора одной из 
альтернативных возможностей;<BR><FONT face=symbol>·</FONT>&nbsp;УКАЗКА для 
указания объекта на изображении;<BR><FONT face=symbol>·</FONT>&nbsp;КЛАВИАТУРА 
для ввода строки символов. 
<P>В стандарте CGI [<A href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#mbib66" 
name=CITEmbib66>66</A>], определяющем интерфейс между аппаратно-независимой и 
аппаратно-зависимой частями графической системы, дополнительно к перечисленным 
предлагаются еще два класса виртуальных устройств:<BR><FONT 
face=symbol>·</FONT>&nbsp;РАСТР (AREA) для ввода растровых картин;<BR><FONT 
face=symbol>·</FONT>&nbsp;ОБЩЕЕ (GENERAL) для ввода иных данных, например, ввод 
голоса. 
<P>Мобильность прикладных программ по отношению к изменению технических средств 
обеспечивается последовательным использованием только виртуальных устройств. 
Мобильность по отношению к ЭВМ обеспечивается реализацией функционально 
идентичных пакетов подпрограмм для ЭВМ различных типов. Хорошие предпосылки для 
этого заключаются (также, как и для средств вывода) в решении вопросов 
стандартизации в машинной графике, которые будут рассмотрены в разделе 3. 
<P>
<CENTER>
<H3><A name=tth_sEc0.1.5>0.1.5</A>&nbsp;&nbsp;Выводы</H3></CENTER>
<P>В концептуальном плане выбора архитектуры построения графических систем можно 
сделать следующие выводы: 
<OL type=1>
  <P>
  <LI>Построение графической системы на базе специального графического языка 
  целесообразно только при ее массовом специализированном, немодифицируемом 
  применении и при отсутствии необходимости объединения в рамках одной 
  прикладной программы графических и вычислительных модулей. 
  <LI>Подход, основанный на геометрическом и графическом синтаксическом 
  расширении того или иного алгоритмического языка, не нашел сколь-нибудь 
  серьезного применения как из-за больших трудозатрат его реализации, так и 
  из-за нарушения переносимости прикладных программ и отсутствия преимуществ в 
  использовании графических конструкций по сравнению с вызовами подпрограмм. 
  <LI>Основное и подавляющее распространение получил подход, основанный на 
  процедурных (семантических) графических расширениях алгоритмических языков. 
  </LI></OL>
<P></I></B></TT><U>1.&nbsp;АРХИТЕКТУРА ГРАФИЧЕСКИХ РАБОЧИХ СТАНЦИЙ</U> 
<CENTER>
<H3><A name=tth_sEc0.2>0.2</A>&nbsp;&nbsp;АРХИТЕКТУРА ГРАФИЧЕСКИХ РАБОЧИХ 
СТАНЦИЙ</H3></CENTER>
<P>В данном разделе: 
<P>1.&nbsp;Разъясняются понятия "рабочей станции" и "суперстанции". 
<P>2.&nbsp;Описываются архитектурные решения, используемые в рабочих станциях. 
<P>3.&nbsp;Анализируются основные подходы к построению средств формирования 
изображений на примерах СБИС фирм: 
<P><FONT face=symbol>·</FONT> Texas Instruments - графические программируемые 
микропроцессоры TMS-34010, TMS-34020; 
<P><FONT face=symbol>·</FONT> National Semiconductor - набор графических СБИС 
DP-8500, DP-8510, DP-8512, DP-8515; 
<P><FONT face=symbol>·</FONT> Intel - графический сопроцессор Intel 82786 и RISC 
микропроцессор с включением графического устройства - Intel 860. 
<P>3.&nbsp;Рассматриваются конкретные реализации высокоскоростных 3D 
суперстанций на примере систем POWER IRIS 4D/380 VGX фирмы Silicon Graphics и 
GS2000 фирмы Stardent. 
<P>
<CENTER>
<H3>Рабочие станции</H3></CENTER>
<P>Рабочие станции (иногда называют "графические станции") появились в конце 
70-х как результат сбалансированного объединения лучших технологий: построение 
процессоров, работа с графическими объектами и устройствами, организация 
ввода/вывода, организация связи - в одной системе, удобной для решения 
инженерных задач. 
<P>Многие идеи, появившиеся в 80-е годы, наложили свой отпечаток на рабочие 
станции, построенные, в основном, из стандартных компонент. Что, в свою очередь, 
отразилось на производстве компьютеров: увеличение роли ОС Unix, рождение 
концепции "открытых систем", разработка новых стратегий производителями 
компьютеров. 
<P>В начале 90-х производительность рабочих станций по многим параметрам 
приблизилась к большим машинам (mainframe). По закону Джой такой показатель как 
MIPS удваивается каждые два года с 1 MIPS в 1984 до 64 MIPS в 1990. Наибольшие 
отличия сегодня можно обнаружить в направлении наиболее быстрого развития - 
визуализации 3D объектов и росте интерактивных возможностей, - поднимающем 
производительность труда исследователей и инженеров. 
<P>В течении длительного времени было довольно трудно сравнивать 
производительность рабочих станций, особенно в области графики. Но сейчас 
ситуация изменилась. В связи с достижением согласия в области стандартов, таких 
как Unix, X Window, Phigs+ , стало гораздо легче разработать и применить 
процедуры для оценки производительности рабочих станций. А также, что не менее 
важно, одинаковым образом проинтерпретировать полученные результаты. 
<P>
<CENTER>
<H3>Суперстанции</H3></CENTER>
<P>Суперстанция (superworkstation) - это соединение в одной системе возможностей 
рабочей станции (3D графика, интегрированность) и суперкомпьютера (быстрый 
ввод/вывод, векторизация вычислений). В настоящее время на западном рынке 
представлено около 120-ти моделей рабочих станций и 20-ти моделей Х-терминалов. 
Среди них около 20-ти можно считать суперстанциями, отобранными, например, по 
производительности при работе с 3D графикой. 
<P>Типичную суперстанцию можно описать, как организованную эффективным образом 
систему из следующих компонент: 
<P><FONT face=symbol>·</FONT> одно или несколько 32/64-битных ЦПУ с кэш-памятью; 

<P><FONT face=symbol>·</FONT> сопроцессоры с плавающей запятой и/или векторный; 
<P><FONT face=symbol>·</FONT> графическая подсистема с процессором, кадровым 
буфером и Z-буфером; 
<P><FONT face=symbol>·</FONT> не менее чем 32-битная внутренняя шина; 
<P><FONT face=symbol>·</FONT> сетевой контроллер (FDDI, Ethernet Token Ring); 
<P><FONT face=symbol>·</FONT> быстрый дисковый контроллер (IPI, SCSI ...); 
<P><FONT face=symbol>·</FONT> от 16 до 256 мегабайт внутренней памяти; 
<P><FONT face=symbol>·</FONT> стандартная шина ввода/вывода (VME, EISA, MCA ...) 
для подключения периферийных устройств (диска, магнитофона ...);<BR>
<P><FONT face=symbol>·</FONT> один или несколько асинхронных портов; 
<P><FONT face=symbol>·</FONT> монитор, клавиатура, мышь; 
<P><FONT face=symbol>·</FONT> Unix, X Window, NFS, PHIGS, GKS, C, Fortran, 
TCP-IP, NCS, эмуляторы графических терминалов, средства отладки ...<BR>
<P>Технические характеристики некоторых суперстанций приведены в таблицах 1-4 
раздела 6. 
<P>
<CENTER>
<H3>Ближайшие перспективы</H3></CENTER>
<P>Рабочие станции развиваются более динамично, чем другие классы компьютеров: 
рост рынка, снижение цен, рост производительности. Современные достижения в 
областях: ЦПУ, шины, графика, ОС, диски, <FONT face=symbol>ј</FONT> могут быть 
использованы в рабочих станциях. 
<P>Указанные процессы приведут к тому, что:<BR><FONT 
face=symbol>·</FONT>&nbsp;возрастет общая производительность рабочих 
станций;<BR><FONT face=symbol>·</FONT>&nbsp;увеличатся периферийные 
возможности;<BR><FONT face=symbol>·</FONT>&nbsp;улучшится программное 
обеспечение;<BR><FONT face=symbol>·</FONT>&nbsp;улучшатся эргономические 
характеристики рабочих станций. 
<P>
<CENTER>
<H3><A name=tth_sEc0.2.1>0.2.1</A>&nbsp;&nbsp;Компоненты современных растровых 
дисплейных систем</H3></CENTER>
<P>Анализируя тенденции развития архитектур растровых графических рабочих 
станций (ГРС), ориентированных на интерактивную графику можно отметить, что за 
последние годы сформировалась и стала традиционной архитектура, включающая 
центральный процессор и растровую графическую дисплейную систему. Центральный 
процессор выполняет функции обмена информацией между ГРС и внешним миром 
(базовой ЭВМ или вычислительной сетью), диспетчеризации потоков данных между 
компонентами рабочей станции и предварительной обработки данных. Растровая 
графическая дисплейная система осуществляет функции формирования и модификации 
наборов данных в памяти изображения (видеопамяти) и управляет режимами вывода 
графической информации на растровый монитор. 
<P>Растровая графическая система современной архитектуры состоит из следующих 
функциональных компонент: 
<OL type=1>
  <P>
  <LI>Видеопамять служит для хранения графических данных в растровой форме. 
  <LI>Графический процессор (либо несколько таких процессоров и, возможно, 
  геометрический процессор) реализует основные функции по формированию 
  изображений в видеопамяти. В современных 2D системах графические процессоры, 
  как правило, выполняют два класса операций: преобразование графических 
  примитивов в растровую форму (функционально-растровые преобразования) и 
  копирование прямоугольных блоков видеопамяти (растровые операции - Raster Op 
  [<A href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#mbib79" 
  name=CITEmbib79>79</A>]). 
  <LI>Видеоконтроллер формирует управляющие сигналы для организации доступа к 
  видеопамяти со стороны графических процессоров (возможно, и со стороны 
  центрального процессора), а также обеспечивает регенерацию экранного буфера 
  видеопамяти - части видеопамяти, отображаемой на экран монитора. Кроме этого в 
  состав видеоконтроллера, как правило, входит аппаратура управления графическим 
  монитором, схемы таблицы цветности для управления оттенками цветов и 
  градациями яркости изображения и, возможно, средства поддержки ряда атрибутов 
  изображения таких ка, например, мерцание, подсветка, наложение и т.п. </LI></OL>
<P>
<CENTER>
<H3><A name=tth_sEc0.2.2>0.2.2</A>&nbsp;&nbsp;Видеопамять</H3></CENTER>
<P>В растровых дисплейных системах видеопамять организована в виде 
прямоугольного массива точек. Элемент видеопамяти, стоящий на пересечении 
конкретных строки и столбца видеопамяти, хранит значение яркости и/или цвета 
соответствующей точки. Отображаемая на экране часть видеопамяти называется 
экранным буфером (буфером регенерации или экранной битовой картой). Регенерация 
изображения осуществляется последовательным построчным сканированием экранного 
буфера. 
<P>Так как каждый элемент видеопамяти определяет один элемент отображения 
размером в точку на экране монитора, то каждая точка экран (и соответствующий ей 
элемент видеопамяти) обозначаются термином пиксел (pixel - picture element). 
<P>
<CENTER>
<H4><A name=tth_sEc0.2.2.1>Регенерация видеопамяти</A></H4></CENTER>
<P>Задача системы вывода изображений (видеоконтроллера) состоит в циклическом 
построчном просмотре экранного буфера от 25 до 100 раз в секунду. Адреса 
видеопамяти генерируются синхронно с координатами растра и содержимое выбранных 
пикселов используется для управления цветом и интенсивностью луча. Общая 
организация системы вывода изображений приведена на рис.&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#r2_01">0.2.3</A>. 
<P>
<P><A name=tth_fIg0.3></A><A name=r2_01>
<CENTER><BR><IMG alt="Рисунок 3" 
src="Учебное пособие Архитектуры графических систем_files/kg0303.gif"></A>
<P></CENTER>
<CENTER>Рис. 0.2.3: Экранный буфер и система вывода изображения</CENTER>
<P>
<P>Генератор растровой развертки формирует сигналы отклонения и управляет 
адресными X и Y регистрами, определяющими следующий элемент буфера регенерации. 
<P>В идеальном случае время, требуемое для регенерации экранного буфера, должно 
быть много меньше, чем время, необходимое для манипуляций с данными, что 
позволит быстро обновлять или двигать изображение. Это означает, что усилители 
отклонения и усилитель, управляющий интенсивностью луча, должны быть очень 
широкополосными, чтобы обеспечить требуемую скорость передачи данных между 
экранным буфером и системой вывода изображения. 
<P>Частота регенерации для графических дисплейных систем среднего разрешения 
лежит в пределах 50 Мгц, а для систем высокого разрешения достигает 100-125 Мгц, 
с явной тенденцией к частотам более 125 Мгц в последнее время. При таких 
частотах таймирование регенерации экранного буфера становится важной задачей при 
проектировании подсистемы графического вывода. Так ка обычная DRAM память не 
обеспечивает времени доступа, подходящего для существующих мониторов высокого 
разрешения, то регенерация видеопамяти на таких частотах требует ее специальной 
организации. Пример организации видеопамяти, построенной на обычной динамической 
памяти с произвольным доступом (DRAM) приведен на рис.&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#r2_02">0.2.4</A>. 
<P>
<P><A name=tth_fIg0.4></A><A name=r2_02>
<CENTER><BR><IMG alt="Рисунок 4" 
src="Учебное пособие Архитектуры графических систем_files/kg0304.gif">
<P></A></CENTER>
<CENTER>Рис. 0.2.4: Регенерация экранного буфера, построенного на обычной 
динамической памяти (DRAM)</CENTER>
<P>
<P>В такой системе регенерация экранного буфера видеопамяти осуществляется с 
помощью параллельно-последовательного преобразования. Выполняя регенерацию, 
видеоконтроллер выставляет адрес слова, требуемое слово данных видеопамяти 
(обычно 16-32-64 бита) затем трансформируется в последовательный видеопоток 
(videostream) с помощью внешнего сдвигового регистра под контролем аппаратуры 
регенерации. На рис.&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#r2_02">0.2.4</A> показана 
реализация регенерации экранного буфера для системы с одним слоем. Системы 
регенерации со многими слоями требуют такого же количества (16-32-64) битовых 
слов, подлежащих регенерации и параллельно-последовательных сдвиговых регистров, 
что и число битовых слоев видеопамяти. 
<P>Если частота регенерации экранного буфера составляет порядка 100 Мгц, то 
такое параллельно-последовательное преобразование уменьшает требования к частоте 
тактирования параллельно считываемого слова из экранного буфера видеопамяти до 
6.25 Мгц, что требует времени доступа порядка 160 нс. При такой организации 
видеопамяти манипуляции с данными и обновление экрана должны происходить во 
времена межстрочного и межкадрового интервалов, когда регенерации не происходит. 
Таким образом, узкое место для обычной DRAM памяти в качестве видеопамяти в 
графических дисплейных системах вытекает из двух противоречивых требований: 
<P><FONT face=symbol>·</FONT> для растровых дисплейных систем должна 
осуществляться постоянная регенерация экранного буфера видеопамяти, что требует 
считывания выводимой на экран монитора графической информации с периодическим, 
жестко заданным циклом;<BR>
<P><FONT face=symbol>·</FONT> с другой стороны, требуется время для обновления 
больших массивов данных видеопамяти со стороны собственно аппаратуры генерации 
изображений, работающей, как правило, в цикле чтение-модификация-запись.<BR>
<P>Доступные в настоящее время DRAM устройства даже с наиболее быстрыми режимами 
доступа не обеспечивают быстрого чтения их содержимого для поддержки требуемого 
ритма регенерации, оставляя крайне мало времени графическому процессору для 
модификации изображения. Таким образом, ограниченная полоса пропускания DRAM 
памяти ограничивает доступ аппаратуры формирования изображений к данным 
видеопамяти на время значительных периодов регенерации экранного буфера. 
Проблема усложняется по мере увеличения экранного буфера из-за возрастания числа 
отображаемых пикселов для мониторов высокого разрешения или при увеличении числа 
битов на пиксел в системах с большим количеством отображаемых цветов. 
<P>Для решения этой проблемы разработаны различные архитектуры видеопамяти, 
включая двухпортовую видеопамять, двойное буферирование и др. 
<P>Однако лучшее решение этой проблемы достигается за счет применения нового 
типа DRAM памяти, получившей название VRAM (Video Random Accses Memory), 
например. Texas Instrument 4161, разработанной специально для использования в 
качестве памяти изображения в растровых дисплейных система. Структурная схема 
подобной памяти приведена на рис.&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#r2_03">0.2.5</A>. 
<P>
<P><A name=tth_fIg0.5></A><A name=r2_03>
<CENTER><BR><IMG alt="Рисунок 5" 
src="Учебное пособие Архитектуры графических систем_files/kg0305.gif">
<P></A></CENTER>
<CENTER>Рис. 0.2.5: Структурная схема VRAM памяти</CENTER>
<P>
<P>Эта видеопамять содержит 2 порта, обеспечивая независимый доступ со стороны 
видеоконтроллера для регенерации и аппаратуры формирования изображений - 
графических процессоров. VRAM фактически представляет собой обычную DRAM память, 
которая была "внутренне" модифицирована посредством добавления сдвигового 
регистра. D и Q - это обычные входы и выходы порта с произвольной выборкой. 
Сигнал TR активируется на время передачи данных между сдвиговым регистром и 
видеопамятью. Сигналы SIN и SOUT - последовательные вход и выход сдвигового 
регистра, а сигнал SCLK - последовательный вход, управляющий сдвиговым 
регистром. Сдвиговый регистр загружается параллельным потоком в 256 бит из 
массива памяти за один цикл регенерации экрана. Длительность этого цикла не 
длиннее, чем стандартный цикл памяти. Обычно сдвиговый регистр загружается 1 раз 
во время обратного хода луча. Когда обратный ход заканчивается, на вход SCLK 
подается сигнал, вызывая сдвиг данных на последовательном выходе SOUT. 
<P>На рис.&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#r2_03">0.2.5</A> показан модуль 
видеопамяти объемом 64 Кбайт. Видеопамять объемом 256 Кбайт может быть построена 
из 4 модулей по 64 Кбайт (рис.&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#r2_04">0.2.6</A>). 
<P>
<P><A name=tth_fIg0.6></A><A name=r2_04>
<CENTER><BR><IMG alt="Рисунок 6" 
src="Учебное пособие Архитектуры графических систем_files/kg0306.gif">
<P></CENTER>
<CENTER>Рис. 0.2.6: Структурная схема многослойной VRAM памяти</CENTER></A>
<P>
<P>В этом случае выходы SOUT от нескольких VRAM модулей подаются на параллельные 
входы внешнего сдвигового регистра, последовательный выход (CLK) которого 
тактируется со скоростью вывода точек (видеопотока битов), требуемой для 
регенерации экрана монитора. 
<P>В видеопамяти с такой организацией время на регенерацию экранного буфера 
(отображения на экран монитора) составляет менее 1.5% времени доступа. В 
системах же с обычной DRAM памятью время на регенерацию экрана составляет от 40% 
до 60% времени доступа. 
<P>Таким образом, применение VRAM обеспечивает практически полное время доступа 
для модификации данных видеопамяти, так как на одну строку сканирования растра 
требуется одна загрузка сдвигового регистра. Следовательно, в то время как 
предварительно загруженные видеоданные "выталкиваются" из сдвигового регистра в 
канал графического вывода, одновременно может осуществляться произвольный доступ 
к видеопамяти со стороны графических процессоров для модификации изображения. 
<P>
<CENTER>
<H4><A name=tth_sEc0.2.2.2>Модификация данных в видеопамяти</A></H4></CENTER>
<P>Рассмотрим архитектуры видеопамяти с точки зрения манипуляции/обновления 
данных. Вопросы, относящиеся к выборке и обработке данных в видеопамяти 
графическим и/или центральным процессором, оказывают существенное влияние как на 
организацию самой видеопамяти, так и на внутреннюю архитектуру технических 
средств формирования изображений. Изображение, хранящееся в видеопамяти, 
концептуально может быть представлено в виде куба (рис.&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#r2_05">0.2.7</A>). 
<P>
<P><A name=tth_fIg0.7></A><A name=r2_05>
<CENTER><BR><IMG alt="Рисунок 7" 
src="Учебное пособие Архитектуры графических систем_files/kg0307.gif">
<P></CENTER>
<CENTER>Рис. 0.2.7: Графический экранный буфер</CENTER></A>
<P>
<P>Каждый пиксел, выводимый на экран монитора, состоит из отдельных битов 
видеопамяти, находящихся внутри куба. 
<P>Соотношение между значением пиксела, отображаемого из экранного буфера 
видеопамяти, и цветом на экране монитора устанавливается с помощью таблицы 
цветности видеоконтроллера. Доступ к данным, хранящимся внутри куба, необходим 
для их модификации и манипуляций с ними, регенерации экранного буфера и его 
обновления. В основном имеются 3 конфигурации: организация видеопамяти "в 
глубину", ориентированная на обработку элементов отображения - ЭО (пикселов), 
организация видеопамяти в виде битовых слоев (разрядных матриц) и "смешанная" 
архитектура.<BR>
<P>
<CENTER>
<H4>Архитектура "в глубину"</H4></CENTER>
<P>При такой организации видеопамяти обрабатываемые в каждый момент данные есть 
пиксел. В этом случае для многих слоев видеопамяти, генерируемый адрес вызывает 
слово данных, представляющих композицию битов "сквозь" слои, составляющие 
видеопамять (отсюда появился термин "глубина пиксела" - "pixel depth"). Такая 
архитектура применяется в системах высокого разрешения, предназначенных для 
обработки цветной трехмерной графической информации, например, в обработке 
изображений и моделировании структур твердых тел, т.е. там где значения каждого 
пиксела подвергаются интенсивным вычислениям. Эти применения, как правило, 
требуют "глубины пиксела" от 8 до 22-24 бит. В архитектуре "в глубину" данные в 
видеопамяти обрабатываются поэлементно. В случае использования для 
воспроизведения изображений, состоящих из нескольких цветовых плоскостей, адрес, 
направляемый в экранный буфер, генерирует слово данных, составленное из битов, 
представляющих собой одноименные разряды требуемых разрядных матриц. 
<P>
<CENTER>
<H4>"Слойная" архитектура</H4></CENTER>
<P>В "слойной" ("plane") архитектуре данные видеопамяти обрабатываются как одно 
слово (обычно 16 бит) в каждый момент времени (пословная обработка) и отдельно 
для каждого слоя (разрядной матрицы). 
<P>Чтобы изменить один разряд слова видеопамяти, вместе с ним необходимо 
передать и оставшиеся 15 разрядов. Кроме того, для того чтобы обеспечить 
позиционирование и перемещение изображения с точностью до бита и с 
удовлетворительной скоростью, требуется специализированная аппаратура, 
осуществляющая быстрые сдвиги и "слияния" цепочек битов видеопамяти ("barrell 
shifter" [<A href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#mbib76" 
name=CITEmbib76>76</A>]). Однако, несмотря на это условие, "слойные" архитектуры 
видеопамяти являются наиболее популярными в интерактивных 2D системах, так как 
требуют менее интенсивных вычислений значений пикселов (по сравнению с 
архитектурой "в глубину"), но более интенсивных вычислений при создании и 
перемещении изображения. Такие архитектуры видеопамяти часто находят применение 
в системах обработки инженерной и экономической информации, поскольку для них 
характерен значительный объем операций, связанных с манипуляциями данными и 
перемещении изображения. 
<P>Кроме того, достоинством такой архитектуры является возможность пословного 
доступа к видеопамяти со стороны центрального процессора (при соответствующей 
организации такая видеопамять для центрального процессора ничем не отличается от 
обычной оперативной памяти). Пословный доступ при достаточной разрядности слова 
(16-32 бит) и ограниченных требованиях к цвету (до 16 цветов, что требует 
четырех слоев видеопамяти) и при наличии аппаратных средств быстрого сдвига дают 
выигрыш в скорости, так как за один цикл памяти считывается сразу 16-32 битов 
данных, подлежащих модификации. 
<P>
<CENTER>
<H4>"Смешанная" архитектура</H4></CENTER>
<P>В этой архитектуре доступ к данным видеопамяти может производиться как по 
"глубине" пиксела, так и в "ширину", реализуя лучшие возможности обеих 
архитектур. 
<P>Следует отметить, что такие архитектуры в последнее время применяются в 
дисплейных системах наиболее дорогих рабочих станций, поскольку требуют 
значительных аппаратных затрат на их реализацию. 
<P>Во многих специальных применениях используются и другие архитектуры, 
например, [<A href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#mbib60" 
name=CITEmbib60>60</A>,,]. 
<P>
<CENTER>
<H3><A name=tth_sEc0.2.3>0.2.3</A>&nbsp;&nbsp;Технические средства формирования 
изображений</H3></CENTER>
<P>В основе архитектуры современных рабочих станций лежат многопроцессорность и 
конвейерная обработка. Такой подход позволяет разделить процессы модельных, 
видовых и функционально-растровых преобразований и дает возможность каждому из 
них выполняться на выделенном, как правило, специализированном устройстве со 
своей собственной скоростью. (Модельные преобразования - преобразования, 
используемые для построения модели объекта в системе координат пользователя. 
Видовые преобразования - преобразования, используемые после модельных при 
выполнении отображения в поле вывода. Математически модельные и видовые 
преобразования имеют одинаковую форму, но применяются в различное время и 
относятся к разным подсистемам графического конвейера. Функционально-растровые 
преобразования - преобразование примитивов вывода в растровую форму). 
<P>Из вышеперечисленных наиболее длительным и обрабатывающим б\'ольшие объемы 
данных является процесс функционально-растровых преобразований. 
<P>Ускорение этого процесса достигается за счет усложнения архитектур дисплейных 
систем, в состав которых вводятся дополнительные вычислительные мощности - от 
высокопроизводительных процессоров общего назначения [<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#mbib73" name=CITEmbib73>73</A>] 
и/или специально разрабатываемых процессоров [<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#mbib79" name=CITEmbib79>79</A>,] 
до специализированных графических СБИС [<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#mbib72" name=CITEmbib72>72</A>,], 
берущих на себя основные функции по формированию изображений в растровой форме и 
управлению видеопамятью. 
<P>Специализированные микросхемы для графических дисплейных систем занимают в 
настоящее время одно из важных мест на мировом рынке. Ведущие фирмы в этой 
области: Advanced Micro Devices, Intel, NEC, Texas Instruments, Hitachi, 
National Semiconductor. Разработки этих фирм в области технических средств 
формирования изображений представляют собой высокопроизводительные графические 
процессоры, которые требуют минимального вмешательства со стороны центрального 
процессора для выполнения графических функций высокого уровня. Например, 
разработки фирм Intel и Texas Instruments выполнены в виде отдельных СБИС, 
реализующих широкий набор функций. Набором функций, реализуемых этими 
однокристалльными процессорами, фирмы намерены обеспечить выполнение всех 
запросов потенциальных потребителей - разработчиков графических дисплейных 
систем. Фирма National Semiconductor разработала набор СБИС, из которых можно 
строить графические системы с различными характеристиками, ориентированные на 
выполнение необходимого набора функций. Предполагается, что в этом случае 
разработчик сам определит требуемый набор функций и реализует его, используя те 
или иные компоненты из набора СБИС. 
<P>Несмотря на то, что при проектировании этих устройств использовались 
концептуально разные подходы, (что наложило свой отпечаток на их функциональные 
возможности и внутреннюю архитектуру) все они ориентированы на формирование 
изображения в битовых картах (BitMap) и обладают рядом общих характеристик: 
<P><FONT face=symbol>·</FONT> поддержка современных 2D графических стандартов 
(GKS, CGI и т.д.), 
<P><FONT face=symbol>·</FONT> возможность адресации больших объемов видеопамяти 
(от 4 Мбайт и более), 
<P><FONT face=symbol>·</FONT> эффективная реализация операции блочной переписи 
(BitBlt Bit boundary Block Transfer), представляющей мощное средство для 
создания многооконных графических систем. Скорость выполнения операций блочной 
переписи превышает 20 Мбит/с.<BR>
<P>Рассмотрим некоторые из устройств более подробно. 
<P>
<CENTER>
<H4><A name=tth_sEc0.2.3.1>Графические процессоры TMS-34010 и 
TMS-34020</A></H4></CENTER>
<P>TMS-34010 - первый графический микропроцессор, поддерживающий 
пользовательскую графику вместо встроенных графических примитивов [<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#mbib59" name=CITEmbib59>59</A>]. 
При постановке задачи разработчики TMS-34010 определили, что простое расширение 
числа аппаратно реализованных графических функций было бы (на их взгляд) 
фундаментальной ошибкой по следующим причинам: 
<P>1.&nbsp;Спектр графических функций устройства был бы жестко зафиксирован. В 
этом случае возможна аппаратная поддержка только относительно немногих 
примитивов вывода (как правило, определенных современными графическими 
стандартами), а новые примитивы или старые, но с расширенными возможностями, не 
смогут быть поддержаны. 
<P>2.&nbsp;Даже стандартизованные графические примитивы могут требовать многих 
атрибутов отрисовки, таких как ТИП ЛИНИИ, ШИРИНА ЛИНИИ, ЦВЕТ ЛИНИИ, ПРОЗРАЧНОСТЬ 
и других. Аппаратная реализация означает "жесткий" выбор поддерживаемых 
атрибутов, следовательно, некоторые не часто используемые либо 
незастандартизованные, но существенные для отдельных применений атрибуты будут 
опущены, например, ФОРМА КОНЦОВ ЛИНИИ (endpoint shape). 
<P>3.&nbsp;Высококачественная графика требует точного контроля над алгоритмами 
формирования изображений. Концептуально отрисовка в битовых картах означает 
выбор ближайших пикселов на растровой дискретной сетке, что вызывает ошибки 
округления, видимые как ступеньки ("зазубрины" - "jaggies"), образующие "эффект 
лестницы" при отрисовке наклонных линий. Графический пакет качественной графики 
может требовать доступа "сверху" (со стороны программы пользователя) для 
исправления такого рода эффектов (алгоритм сглаживания - antialiasing), либо 
дополнительных параметров для реализации этих требований на аппаратном уровне. 
<P>4.&nbsp;Формат дисплейного списка, или команд формирования изображений может 
варьироваться в соответствии с требованиями пользователя. Например, для 
формирования шрифтов с фиксированной матрицей знакоместа (непропорциональный 
шрифт) используется относительно простой формат команды, в то время, как шрифт с 
переменными размерами матрицы (пропорциональный) требует более сложного формата 
команды. 
<P>Единственный способ удовлетворить всем возможным требованиям при реализации 
команд формирования изображений - это иметь полностью программируемый процессор, 
интерпретирующий графические команды. 
<P>Таким образом TMS-34010 был разработан чтобы предоставить пользователю 
максимальную гибкость для реализации графических примитивов и, в то же время, 
обеспечить требуемую скорость формирования изображений (не сильно уступая в этом 
отношении графическим процессорам и контроллерам с "чисто аппаратной" 
реализацией графических функций). С помощью TMS-34010 можно реализовать 
практически любые алгоритмы отрисовки графических примитивов, которые могут быть 
востребованы как для отдельных специальных приложений, так и по мере появления 
новых графических стандартов. 
<P>Набор из 120 инструкций поддерживает восемь типов адресации и четыре основных 
типа данных - массивы упакованных пикселов, X-Y координаты, прямоугольные окна и 
битовые поля произвольной длины. 
<P>Для реализации алгоритмов графических примитивов вывода в TMS-34010 
используются инструкции общего назначения, а для повышения скорости отработки 
этих алгоритмов (собственно манипуляций с пикселами в видеопамяти) используется 
аппаратно реализованный набор графических инструкций. Таким образом, в TMS-34010 
полный набор инструкций общего назначения, который может поддержать 
программирование на языке высокого уровня, "замешан" с мощным набором 
специальных графических инструкций, например, такими как перепись блока битов 
(BitBlt), являющейся базовой операцией в современной растровой графике. 
<P>Графический процессор TMS-34010 содержит полностью программируемый 32-х 
разрядный процессор со схемами адресации памяти и системой команд, 
ориентированной на операции над пикселами, набор из 31 32-битных регистров и 
кэш-память инструкций на 256 байт. В дополнение TMS-34010 содержит контроллер 
управления растровым монитором, отдельный интерфейс с центральным процессором, 
интерфейс с DRAM/VRAM памятью. 
<P>Так как инструкции процессора выбираются из кэш-памяти, то он может выполнять 
вычисления параллельно с работой с памятью его устройства управления ОЗУ. 
<P>Для повышения скорости отработки графических функций используются специальные 
аппаратные средства: барабанный сдвигатель (barrell shifter); логика 
маскирования и слияния цепочек пикселов; аппаратура определения левого 
единичного бита; компаратор окон, связывающий отсечение графических примитивов 
вывода с прямоугольными зонами графического буфера. 
<P>TMS-34010 использует такое упорядоченное расположение пикселов в видеопамяти, 
при котором оно представляет собой единое линейное адресное пространство. 
Процессор имеет возможность адресации от 1 до 32 бит в линейном и координатном 
масштабах. Возможное число битов, описывающих пиксел, ограничено 16-ю битами. 
Слово данных может быть определено как четыре 4-битных пиксела, как два 
8-битных, один 16-битный. Такой подход удачно сочетается с возможностями 
32-битной архитектуры, так как он позволяет производить быстрые операции над 
пикселами любого заранее указанного размера. Однако, скорость выполнения 
операций чтения-модификации-записи элемента отображения при такой архитектуре не 
является постоянной при работе в режимах с различным числом бит на пиксел, что 
несколько затрудняет построение универсальных гибких графических систем. 
<P>С использованием TMS-34010 могут быть построены системы с объемом видеопамяти 
до 8 Мбайт, содержащей некоторое количество неотображаемой "заэкранной" 
информации, такой как различные шрифты или предварительно подготовленные 
изображения в виде битовых карт различного формата, например, пиктограммы. 
Пример использования TMS-34010 при построении графической системы приведен на 
рис.&nbsp;<A href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#r2_06">0.2.8</A>. 
<P><A name=tth_fIg0.8></A>
<P><A name=r2_06>
<CENTER><BR><IMG alt="Рисунок 8" 
src="Учебное пособие Архитектуры графических систем_files/kg0308.gif">
<P></CENTER>
<CENTER>Рис. 0.2.8: Использование TMS-34010 в графической системе</CENTER></A>
<P>
<P>Как правило, система, базирующаяся на TMS-34010, в общем случае содержит 
видеопамять порядка 0.5 Мбайт (VRAM) и 1-3 Мбайт программной памяти (DRAM), ПЗУ 
с программами инициализации, эмуляции предыдущих видеоадаптеров и графическими 
библиотеками [<A href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#mbib48" 
name=CITEmbib48>48</A>]. 
<P>Примером системы, реализованной на базе TMS-34010, может служить плата 
расширения для PC AT GENESIS 1024 фирмы National Design Inc. При разрешении 
1024&times;768&times;4 точек плата обеспечивает скорость рисования до 48 Мпиксел/с и 
поставляется с CGI, AutoCAD и HPG (Harvard Presentation Graphics) совместимыми 
интерфейсами. 
<P>TMS-34010 тактируется от внешнего 50 МГц генератора. Внутренняя частота 
составляет 6.25 МГц, что дает возможность выполнения более 6 млн. инструкций/с 
при работе с кэш-памятью. Устройство выполнено по 1.8 микронной CMOS технологии 
в 68-выводном корпусе. 
<P>
<CENTER>
<H4>Графический процессор TMS-34020</H4></CENTER>
<P>В 1988&nbsp;г. Texas Instrument анонсировала преемника TMS-34010 - 
графический процессор TMS-34020. Он включает 32-разрядный шинный интерфейс (со 
страничным режимом доступа), высокоскоростной тактовый генератор (10 MIPS) и 
дополнительные графические инструкции (3-операндные PixBlt). Графический 
процессор не делает различия между программной и дисплейной памятью. Он может 
адресовать 512 Мбайт. Пикселы могут быть доступны по их X-Y экранным 
координатам, которые автоматически преобразуются в линейное адресное 
пространство памяти. Скорость вычерчивания линий достигает 5 Мпикселов/с. 
<P>Графический процессор выполняет BitBlt операции не только с 16 булевскими 
операциями, но и также и с 8 арифметическими функциями, такими как сложение или 
вычитание значений пикселов. Единственной BitBlt инструкцией графический 
процессор может извлечь данные для символа с 1 битом на пиксел из бинарной 
таблицы шрифта, транслировать их в многобитные цветные данные и разместить в 
некоторое место дисплейной памяти. Скорость выполнения BitBlt операций 
составляет 25 МБит/с. 
<P>Графический процессор поддерживает отсечение во время отрисовки в произвольно 
определенном окне отсечения. Инструкция теста окна определяет находится точка 
внутри или вне окна, так что если линия не пересекает прямоугольник, то она не 
будет вычерчиваться. 
<P>Для использования в 3D графических системах предусмотрен сопроцессор 
TMS-34082 для выполнения операций с плавающей запятой, который подключается к 
графическому. Этот чип работает со скоростью 40 MFLOPS. Он уместен для 
вычислений 3D геометрии и освещенности. В дополнение к функциям АЛУ он 
поддерживает 3D функции типа умножения матриц 4&times;4, отсечения полигона (прямое 
вычисление точки пересечения), тестирование заднего плана и генерацию 3D 
кубических сплайнов. Эти операции выполняются микропрограммно. 
<P>Гибкость графического процессора способствует значительному расширению 
спектра графических акселераторов, построенных на его основе, особенно для 
индексированных цветных дисплеев. 
<P>Использование TMS-34020 в графической системе показано на рис.&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#r2_07">0.2.9</A>. 
<P>
<P><A name=tth_fIg0.9></A><A name=r2_07>
<CENTER><BR><IMG alt="Рисунок 9" 
src="Учебное пособие Архитектуры графических систем_files/kg0309.gif">
<P></CENTER>
<CENTER>Рис. 0.2.9: Использование TMS-34020 в графической системе</CENTER></A>
<P>
<P>
<CENTER>
<H4><A name=tth_sEc0.2.3.2>Графический сопроцессор Intel 82786</A></H4></CENTER>
<P>INTEL 82786 (i82786) предназначен для использования в растровых графических 
станциях САПР, а также в профессиональных персональных ЭВМ высокой 
производительности [<A href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#mbib112" 
name=CITEmbib112>112</A>]. СБИС i82786 обеспечивает скоростную обработку 
графических и текстовых данных, осуществляет их высококачественное отображение и 
поддерживает режим многозадачности. 
<P>Основным положением при разработке i82786 была возможность его использования 
в качестве графического сопроцессора в системах на основе микропроцессоров фирмы 
Intel 80186, 80286, 80386. В отличие от TMS-34010, который работает автономно, 
i82786 работает под управлением центрального процессора: для него не существует 
собственных программ, а лишь поток команд и данных, получаемых от центрального 
процессора графической станции. Графический сопроцессор i82786 имеет собственную 
22-разрядную шину адресов (что позволяет адресовать до 4 Мбайт видеопамяти) и 
16-разрядную шину данных, осуществляет доступ в системную память и выбирает 
данные и команды, сформированные в ЦП. Набор команд сопроцессора делится на 
четыре функциональные группы: общего управления; управления параметрами 
отрисовки изображений; генерации графических примитивов и операций блочной 
переписи и формирования окон. 
<P>Таким образом, в отличие от TMS-34010, специалисты фирмы Intel стремились 
создать графический сопроцессор, который покрывает практически весь спектр 
графических примитивов вывода современных графических стандартов, включая 
операции блочной переписи. 
<P>Особенностью графических систем, построенных на основе i82786, является 
возможность доступа центрального процессора непосредственно к видеопамяти, 
независимо от i82786. Важно отметить, что поскольку при этом центральный 
процессор станции имеет доступ ко всей видеопамяти, то прикладные программы 
пользователя могут реализовывать не часто встречающиеся, но, возможно, 
существенные примитивы отрисовки для высококачественной графики. Этим 
достигается требуемая гибкость реализации "нестандартизованных" графических 
функций, однако при этом теряется скорость их рисования. 
<P>Эффективная поддержка многооконной технологии в многозадачном интерактивном 
режиме достигается за счет введения специальной внутренней архитектуры. СБИС 
i82786 содержит четыре основных модуля: графический и дисплейный процессоры, 
устройство сопряжения с магистралью и контроллер видеопамяти. Все модули 
работают относительно независимо, что обеспечивает высокие скоростные 
характеристики микросхемы. Архитектура и использование i82786 в графической 
системе приведены на рис.&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#r2_08">0.2.10</A>. 
<P>
<P><A name=tth_fIg0.10></A><A name=r2_08>
<CENTER><BR><IMG alt="Рисунок 10" 
src="Учебное пособие Архитектуры графических систем_files/kg0310.gif">
<P></CENTER>
<CENTER>Рис. 0.2.10: Использование сопроцессора Intel 82786 в графической 
дисплейной системе</CENTER></A>
<P>
<P>
<CENTER>
<H4>Графический процессор</H4></CENTER>
<P>Выполняет команды, размещенные в системной памяти и формирует изображения в 
битовых картах видеопамяти для дисплейного процессора во взаимодействии с 
контроллером видеопамяти и интерфейсным устройством шины. Процессор 
оптимизирован для отработки современных графических стандартов (GKS, CGI, 
Microsoft Windows). Все команды, выполняемые графическим процессором, включая 
BitBlt операции, сопровождаются богатым набором атрибутов отрисовки, наиболее 
часто используемых в стандартных графических пакетах. Графический процессор 
обладает развитыми аппаратными возможностями, позволяющими снизить до минимума 
число параметров в командах для формирования примитивов в растровой форме. 
Список графических команд и параметров создается центральным процессором и 
хранится в системной памяти. Графические команды выбираются из связанного списка 
графических команд при обращении к системной памяти через логику шинного 
интерфейса и обрабатываются графическим сопроцессором. 
<P>Для синхронизации работы ЦП и сопроцессора используется флаг завершения 
формирования списка параметров. СБИС i82786 начинает выполнение команды, если ЦП 
завершил формирование списка параметров к этой команде и установил 
соответствующий флаг. Такой режим обмена позволяет значительно повысить 
системную производительность. 
<P>Производительность графического процессора зависит от частоты доступа к 
видеопамяти (каждое модифицируемое в видеопамяти слово требует цикла 
"чтение-модификация-запись"). Скорость работы графического процессора 
определяется также шириной полосы пропускания видеопамяти. Имея специальную 
память (VRAM), графический процессор может использовать до 99% полосы 
пропускания; при использовании в качестве видеопамяти обычных динамических БИС 
ЗУ (DRAM) - 50%-90%. 
<P>
<CENTER>
<H4>Дисплейный процессор</H4></CENTER>
<P>Особенность дисплейного процессора - возможность реализации полиэкранного 
режима за счет имеющихся аппаратных средств поддержки. Дисплейный процессор 
преобразует битовые карты, создаваемые графическим процессором в растровые 
последовательности для видеоконтрольного устройства, которое отображает их в 
виде отдельных окон на экране графического монитора. Процессор оптимизирован для 
данных, представленных в виде битовых карт. Дисплейный процессор работает 
независимо от графического по собственной программе, описывающей таблицу 
конфигурации кадра (экранного буфера), которая формируется ЦП и размещается в 
определенной области видеопамяти. Обрабатывая битовые карты, дисплейный 
процессор воспроизводит их содержимое в нужных областях экрана, выполняя свои 
команды в течение межкадрового промежутка, что обеспечивает получение "чистого" 
(без мерцаний) изображения. Для синхронизации ЦП и дисплейного процессора 
используется механизм квитирования. После выполнения каждой команды дисплейный 
процессор устанавливает флаг, указывающий что ЦП может загружать следующую 
команду. 
<P>Дисплейный процессор разделяет экранную область видеопамяти на горизонтальные 
полосы высотой в произвольной число строк. Полосы представляют собой блоки 
("черепицы" - "tiles"), которые относятся к различным сегментам окна 
(рис.&nbsp;<A href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#r2_09">0.2.11</A>). 
Структура управляющего блока дескриптора приведена на рис.&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#r2_10">0.2.12</A>. 
<P>
<P><A name=tth_fIg0.11></A><A name=r2_09>
<CENTER><BR><IMG alt="Рисунок 11" 
src="Учебное пособие Архитектуры графических систем_files/kg0311.gif">
<P></CENTER>
<CENTER>Рис. 0.2.11: Организация оконных сегментов для i82786</CENTER></A>
<P>
<P>
<P><A name=tth_fIg0.12></A><A name=r2_10>
<CENTER><BR><IMG alt="Рисунок 12" 
src="Учебное пособие Архитектуры графических систем_files/kg0312.gif">
<P></CENTER>
<CENTER>Рис. 0.2.12: Структура управляющего блока дескриптора оконного сегмента 
для i82786. T,B,L,R - управляющие биты для верхней, нижней, левой и правой 
границ; WST - статус окна; Z - увеличение; F - фоновое поле.</CENTER></A>
<P>
<P>Допускается до 16 горизонтальных окон-сегментов на каждую отдельную строку 
растра. Минимальная ширина окна равна 1/16 длины строки. 
<P>Таблица описаний дескрипторов полос ("черепиц") содержит заголовок, в котором 
указаны число строк в полосе, адрес дескриптора следующей полосы, число блоков в 
текущей полосе. Затем идут данные, описывающие блоки и включающие указатели, 
ассоциированные с битовыми картами и атрибуты. Таким образом для каждого кадра 
формируется таблица конфигурации в виде связанного списка команд дисплейного 
процессора. 
<P>Одной из важных особенностей дисплейного процессора является возможность 
поддержки аппаратного курсора. Можно устанавливать размер курсора в матрице 8&times;8 
или 16&times;16 пикселов. Курсор может быть прозрачным, непрозрачным, в виде стрелки, 
креста и т.д. Цвет курсора, его прозрачность и мерцание задаются программным 
способом. Программируются также сигналы синхронизации мониторов с разрешающей 
способностью до 4096&times;4096 пикселов. 
<P>Интерфейсные устройства шины реализуют четыре логических интерфейса: внешний; 
доступа к видеопамяти для внутреннего графического процессора; доступа 
центрального процессора к регистрам графического и дисплейного процессоров и 
видеопамяти; сигналов регенерации видеопамяти. В зависимости от числа бит на 
пиксел изменяется режим работы дисплейного процессора. Так, например, можно 
использовать следующие частоты тактирования: 25&nbsp;МГц при 8 бит/пиксел, 
50&nbsp;МГц при 4 бит/пиксел, 100&nbsp;МГц при 2 бит/пиксел, 200&nbsp;МГц при 1 
бит/пиксел. 
<P>Работа i82786 обеспечивается системным тактированием 10&nbsp;МГц и 
видеотактированием 25&nbsp;МГц и обеспечивает следующие скорости формирования 
изображений: 
<P><FONT face=symbol>·</FONT> построение линий - 2.5 млн. пикс./с, 
<P><FONT face=symbol>·</FONT> построение окружностей и дуг - 2 млн. пикс./с, 
<P><FONT face=symbol>·</FONT> блочная перепись - 24 млн. пикс./с, 
<P><FONT face=symbol>·</FONT> заливка областей - 30 млн. пикс./с (с 
использованием процедуры заливки горизонтальной линией), 
<P><FONT face=symbol>·</FONT> построение символов - 25 млн. символов/с (шрифт 
16&times;16. Более крупные шрифты требуют программной поддержки со стороны ЦП). 
<P>Сопроцессор i82786 может выполнять вертикальный и горизонтальный Roll 
(перемещение) без дополнительной внешней аппаратуры, обеспечивать аппаратное 
увеличение с коэффициентом масштабирования до 64, поддерживать разрешающую 
способность от 640&times;480&times;8 до 1024&times;1024&times;2. 
<P>Микросхема выполнена по CHMOS технологии в 88-выводном корпусе. 
<P>
<CENTER>
<H4><A name=tth_sEc0.2.3.3>Набор графических СБИС National 
AGCS</A></H4></CENTER>
<P>Набор графических СБИС AGCS 85xx (Advanced Graphics Chip Set) фирмы National 
Semiconductor предназначен для построения гибких модульных графических систем, 
имеющих высокую производительность и высокую скорость формирования изображения и 
обмена графической информацией в виде битовых карт [<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#mbib64" name=CITEmbib64>64</A>]. 
В набор AGCS входят: растровый графический процессор DP-8500 (RGP - Raster 
Graphics Processor), процессор обмена блоками информации в виде битовых карт 
DP-8510 (BPU - BitBlt Processing Unit), генератор тактовых импульсов для вывода 
видеоизображения DP-8512 (VCG - Video Clock Generator) и высокоскоростной 
сдвиговый регистр DP-8515 (VSR - Video Shift Register). Набор AGCS соединяет в 
себе производительность функционально-ориентированных устройств (например, 
i82786) с возможностями программируемых графических процессоров (например, 
TMS-34010).<BR>
<P>
<CENTER>
<H4>Растровый графический процессор DP-8500</H4></CENTER>
<P>Изготовлен по 2-х микронной CMOS технологии и работает на частоте 20 МГц. 
Процессор характеризуется 100 нс шинным циклом при работе со следующими 
непосредственно друг за другом векторными и блочными операциями. Скорость 
построения линий на экране равна 300 нс/пиксел. Производительность типичной 
системы на основе растрового процессора лежит в пределах от 10 млн. до 160 млн. 
пикс./с. Достижение подобных характеристик стало возможным благодаря специальной 
внутренней архитектуре растрового процессора DP-8500, использующего отдельное 
АЛУ для адресации и отдельное АЛУ для обработки данных, т.е. разделяющей 
функции, которые в традиционных процессорах, как правило, реализуются единым 
АЛУ. 
<P>Процессор DP-8500 разделен на два блока, которые функционируют под управление 
обычного набора микрокоманд и представляют собой арифметико-логические 
устройства (одно для адресации, а другое для обработки данных), работающих 
параллельно. Оба АЛУ управляются единым потоком команд, считываемых из внешней 
памяти и декодируемых с помощью устройства микропрограммного управления. В число 
этих команд входят команды межрегистровых передач обоих процессоров и другие 
вспомогательные средства, размещенные на кристалле. Благодаря архитектуре со 
сдвоенными АЛУ, процессор DP-8500 можно с успехом применять в системах с 
различными типами архитектуры дисплейной системы. 
<P>Адресный процессор - это 28-разрядное АЛУ со своим набором команд и группой 
их 16 28-разрядных регистров. 
<P>Процессор обработки данных представляет собой 16-разрядное АЛУ, имеющее 
относительно богатый набор команд, оптимизированный для решения графических 
задач и группу из 16 16-разрядных регистров. Кроме того, предусмотрены регистры 
для выполнения ряда специализированных функций, которые связаны с обслуживанием 
графических операций и операций по регенерации изображения. В составе DP-8500 
имеются специализированные схемы для реализации ряда графических операций и, в 
первую очередь, передач блока битов (блочная перепись), построения линий и 
отсечения участков изображения, а также видеоконтроллер кадровой развертки. 
<P>Располагаясь в тракте конвейерной обработки графической информации, DP-8500 
ожидает поступления (завершения формирования) дисплейного списка: списка 
подлежащих отработке графических примитивов вывода. После его получения DP-8500 
приступает к непосредственной интерпретации команд дисплейного списка и 
графические примитивы, переведенные в растровую форму, записываются в 
видеопамять. Выполнив последнюю команду в списке, DP-8500 сигнализирует о 
завершении процедуры, заканчивает обмен с ЦП и дает разрешение на готовность 
отработки следующего потока команд. Структурная схема растрового графического 
процессора DP-8500 приведена на рис.&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#r2_11">0.2.13</A>. 
<P>
<P><A name=tth_fIg0.13></A><A name=r2_11>
<CENTER><BR><IMG alt="Рисунок 13" 
src="Учебное пособие Архитектуры графических систем_files/kg0313.gif">
<P></CENTER>
<CENTER>Рис. 0.2.13: Структурная схема растрового графического процессора 
DP-8500 фирмы National Semiconductor</CENTER></A>
<P>
<P>Следует отметить, что в отличие от конкурирующих графических процессоров, 
применение DP-8500 не ограничено его использованием с экранным буфером всего 
лишь одного типа. Процессор можно применять не только с любой из двух основных 
архитектур видеопамяти ("слойной" или "в глубину"), но также и в комбинированных 
подходах ("смешанная" архитектура видеопамяти). 
<P>
<CENTER>
<H4>Процессор обмена блоками графической информации DP-8510</H4></CENTER>
<P>Представляет собой сопроцессор манипулирования данными, работающий на частоте 
20&nbsp;МГц. DP-8510 - специализированное CMOS устройство, разработанное для 
использования в приложениях BitMap растровой графики. DP-8510 включает 
высокопроизводительную логику, конвейеризующую все необходимые функции, 
связанные с реализацией механизма блочной переписи: сдвиги (за один такт) на 
требуемое число разрядов, маскирования и побитные логические операции. 
Устройство может работать под управлением процессора общего назначения 
(центрального процессора), машины микросостояний либо под управление растрового 
графического процессора DP-8500 (один DP-8500 может управлять до 16-ти DP-8510). 
Устройство поддерживает все манипуляции с данными, необходимыми для построения 
различных BitBlt систем. Для синхронизации с ЦП либо с DP-8500 используется 
механизм квитирования. 
<P>DP-8510 имеет два режима работы: BitBlt (блочная перепись) и формирование 
линий в растровой форме. Построение линий может рассматриваться как специальный 
случай BitBlt с высотой и шириной блока равными единице (точка). Для выполнения 
операций BitBLt управляющие регистры DP-8510 загружаются четырьмя параметрами: 
числом сдвигов, левой и правой масками и кодом операции. Далее происходит 
отработка операции блочной переписи под управлением, например, DP-8500. 
<P>
<CENTER>
<H4>Видеогенератор DP-8512</H4></CENTER>
<P>Служит для таймирования и управления растровой дисплейной графической 
системой. Устройство вырабатывает системный клок на частотах 20 МГц для DP-8500 
и DP-8510, а также обеспечивает тактовые сигналы для управления и параллельной 
загрузки сдвиговых регистров DP-8515. 
<P>
<CENTER>
<H4>Сдвиговый регистр DP-8515</H4></CENTER>
<P>Преобразует параллельное слово данных из экранного буфера видеопамяти в 
высокоскоростной последовательный поток данных (пикселов), подаваемый на вход 
электронно-лучевой трубки, с максимальной частотой до 225 МГц. 
<P>Следует отметить, что набор DP-85xx может поддерживать все типы RAM памяти, 
включая статическую, динамическую и специальную видеопамять (VRAM). 
<P>Техническое решение построения дисплейной системы, реализованное фирмой 
National Semiconductor, сводится к разделению функциональных аппаратных средств 
графической обработки на две специализированные СБИС (DP-8500 и DP-8510), при 
этом DP-8500 выполняет все функции адресации и синхронизации, связанные с 
экранным буфером, и одновременно является интерфейсом, через который 
осуществляется передача адресов и команд центрального процессора. Манипуляции с 
данными, связанными с каждым слоем видеопамяти, осуществляются отдельным 
подчиненным процессором DP-8510, который выполняет операции маскирования, 
циклического сдвига и операции поблочной передачи данных с адресацией с 
точностью до бита. Структурная схема типичной графической системы, предлагаемой 
фирмой National Semiconductor, приведена на рис.&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#r2_12">0.2.14</A>. 
<P>
<P><A name=tth_fIg0.14></A><A name=r2_12>
<CENTER><BR><IMG alt="Рисунок 14" 
src="Учебное пособие Архитектуры графических систем_files/kg0314.gif">
<P></CENTER>
<CENTER>Рис. 0.2.14: Архитектура дисплейной системы со слойной организацией 
видеопамяти на базе набора СБИС AGCS фирмы National Semiconductor</CENTER></A>
<P>
<P>В типичной графической системе с несколькими слоями видеопамяти растровый 
графический процессор DP-8500 производит формирование графических примитивов в 
видеопамяти и управляет подчиненными процессорами DP-8510, осуществляющими обмен 
блоками графической информации. После того как требуемая графическая функция 
выполнена, графический растровый процессор больше не участвует в графических 
манипуляциях (собственно в формированиях графических примитивов вывода в 
растровой форме). При необходимости передачи данных между различными слоями 
видеопамяти один подчиненный процессор DP-8510 выступает в качестве источника 
информации, а любая комбинация оставшихся подчиненных процессоров - в качестве 
места назначения передачи. 
<P>
<CENTER>
<H3><A name=tth_sEc0.2.4>0.2.4</A>&nbsp;&nbsp;RISC-процессор с графическим 
устройством (i860)</H3></CENTER>
<P>В качестве альтернативы фирма Intel [<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#mbib78" name=CITEmbib78>78</A>,] 
предприняла разработку RISC микропроцессора с включением графического 
устройства. i860 в первую очередь является высокоскоростным процессором и, 
во-вторых, он может выступать в рабочих станциях в качестве процессора, 
используемого в 3D графических подсистемах. 
<P>В состав i860 входят (рис.&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#r2_13">0.2.15</A>) управление 
памятью и шиной, кэш-память, центральный RISC-процессор для целых чисел, 
процессор плавающей арифметики из устройств для сложения и умножения 
вещественных и графическое устройство. Тактовая частота i860 - 50 МГц. 
Применение конвейера позволяет в каждом такте выполнять до трех команд - одну 
команду для целых, а также сложение и умножение вещественных. 
<P>
<P><A name=tth_fIg0.15></A><A name=r2_13>
<CENTER><BR><IMG alt="Рисунок 15" 
src="Учебное пособие Архитектуры графических систем_files/kg0315.gif">
<P></CENTER>
<CENTER>Рис. 0.2.15: Архитектура i860</CENTER></A>
<P>
<P>Выборку и декодирование команд выполняет центральный процессор. Кроме этого 
он осуществляет следующие операции: 
<P><FONT face=symbol>·</FONT> загрузка и запоминание в целочисленных регистрах 
операндов, выбранных из памяти;<BR>
<P><FONT face=symbol>·</FONT> пересылка операндов в регистры процессора с 
плавающей запятой; 
<P><FONT face=symbol>·</FONT> арифметические операции над 8, 16 и 32-битными 
целыми числами (операции с 64-битными целыми поддерживает графический 
процессор); 
<P><FONT face=symbol>·</FONT> сдвиговые и логические операции (И, И-НЕ, ИЛИ и 
исключающее ИЛИ);<BR>
<P><FONT face=symbol>·</FONT> управление пересылками, к которым относятся 
команды переходов (непосредственные и косвенные) и команды вызова;<BR>
<P><FONT face=symbol>·</FONT> управление системой; 
<P><FONT face=symbol>·</FONT> загрузка регистров управления, работа с 
кэш-памятью и шиной. 
<P>Процессор плавающей арифметики (ППЗ) содержит файл из 32 регистров и два 
самостоятельных устройства для сложения и умножения вещественных. ППЗ работает в 
скалярном или конвейерном режимах, используя для них различные наборы 
инструкций. В скалярном режиме на выполнение одной операции тратится от трех до 
четырех циклов. В конвейерном режиме результаты выдаются, в основном, после 
каждого цикла или после двух. 
<P>Скалярные инструкции ППЗ включают в себя: 
<P><FONT face=symbol>·</FONT> операции сложения, вычитания, сравнения, 
преобразования в целое и округления до целого (эти операции выполняет устройство 
сложения); 
<P><FONT face=symbol>·</FONT> операции умножения, получения обратной величины и 
извлечения квадратного корня (их выполняет устройство умножения); 
<P><FONT face=symbol>·</FONT> операции пересылки в целочисленные регистры. К 
конвейерным инструкциям, также выполняемым или устройством сложения или 
устройством умножения, относятся операции умножения, сложения, вычитания, 
преобразования в целое и округления до целого. 
<P>Графическое устройство фактически использует данные, поступающие от ППЗ и 
поддерживает размер пиксела в 8, 16 или 32 бита. Вне зависимости от размера 
пиксела оно может обрабатывать до нескольких пикселов одновременно в одном 
64-битном слове. Конфигурация цветов пикселов следующая: 
<P>
<CENTER>
<TABLE>
  <TBODY>
  <TR>
    <TD align=middle>Размер </TD>
    <TD>Битов на цвет </TD>
    <TD align=middle>Битов на цвет </TD>
    <TD>Битов на цвет </TD>
    <TD align=middle>Битов на </TD>
  <TR>
    <TD align=middle>пиксела </TD>
    <TD>Компонента 1 </TD>
    <TD align=middle>Компонента 2 </TD>
    <TD>Компонента 3 </TD>
    <TD align=middle>атрибут </TD>
  <TR>
    <TD align=middle></TD>
    <TD></TD>
    <TD align=middle></TD>
    <TD></TD>
    <TD align=middle></TD>
  <TR>
    <TD align=middle>8 </TD>
    <TD align=middle colSpan=3>N(<FONT face=symbol>Ь</FONT> 8) битов на 
      интенсивность </TD>
    <TD align=middle>8-N </TD>
  <TR>
    <TD align=middle>16 </TD>
    <TD>6 </TD>
    <TD align=middle>6 </TD>
    <TD>4 </TD>
  <TR>
    <TD align=middle>32 </TD>
    <TD>8 </TD>
    <TD align=middle>8 </TD>
    <TD>8 </TD>
    <TD align=middle>8 </TD></TR></TBODY></TABLE>
<P></CENTER>Поля компонент цвета могут быть назначены для RGB или другой 
цветовой модели в зависимости от потребностей приложения. При 8-ми битных 
пикселах до 8 бит могут использоваться для интенсивности, а оставшиеся биты 
могут использоваться для любых других атрибутов. 
<P>Для поддержки 3D операций отображения в графическом устройстве имеется 
дополнительный режим. Сравнения в Z-буфере (для 16 и 32 бит) обеспечиваются 
аппаратурой. Интерполяция цветов и Z значений облегчают реализацию алгоритмов 
закраски. Может быть использована любая комбинация размера пиксела и глубины 
Z-буфера. Скорость закраски Гуро достигает 50&nbsp;000 треугольников в сек для 
треугольников из 100 8-битных пикселов. 
<P>В соcтав i860 входят четыре файла регистров: 
<P><FONT face=symbol>·</FONT> файл из 32 32-битных целочисленных регистров, 
используемых для адресации и скалярных целочисленных вычислений;<BR>
<P><FONT face=symbol>·</FONT> файл из 32 32-битных регистров процессора с 
плавающей запятой. Они используются в операциях вещественной арифметики и при 
выполнении графических целочисленных операций. Эти регистры могут использоваться 
как 64-х или 128-битные. Файл регистров ППЗ имеет два порта чтения, порт записи 
и два двунаправленных порта. Все порты 64-битные и могут работать 
одновременно.<BR>
<P><FONT face=symbol>·</FONT> файл регистров управления; 
<P><FONT face=symbol>·</FONT> файл специальных регистров. 
<P>Пиковое быстродействие i860 в 40 MIPS и 80 MFLOPS хорошо соответствует 
высокоскоростной геометрической обработке. Достигается скорость до 500&nbsp;000 
однородных преобразований векторов. Большая ширина шины данных (64 бита внешняя 
и несколько внутренних 64-битных параллельных шин) обеспечивают высокоскоростной 
доступ к памяти. 
<P>
<CENTER>
<H3><A name=tth_sEc0.2.5>0.2.5</A>&nbsp;&nbsp;Высокоскоростные графические 
системы</H3></CENTER>
<P>
<CENTER>
<H4><A name=tth_sEc0.2.5.1>Требования к высокоскоростным графическим 
системам</A></H4></CENTER>
<P>В дополнение к задачам растеризации, высокоскоростные графические машины 
требуют сбалансированной обработки моделирования, геометрических вычислений, 
освещенности и свойств материала. Эти требования необходимы для: 
<P><FONT face=symbol>·</FONT> реального времени: изображение должно 
генерироваться в 1/30 секунды для обеспечения малого времени ответа на ввод от 
пользователя а также для отображения "живых" сцен. 
<P><FONT face=symbol>·</FONT> реализм: многие приложения требуют возможностей 
генерации высококачественных картин (фотореализм), 
<P><FONT face=symbol>·</FONT> стандарты: с повышением сложности графического 
программного обеспечения важна поддержка стандартизованных интерфейсов и систем 
типа PHIGS, X Window System и т.д. с целью обеспечения переносимости 
программного обеспечения. 
<P>
<CENTER>
<H4><A name=tth_sEc0.2.5.2>Система Silicon Graphics POWER IRIS 4D/380 
VGX</A></H4></CENTER>
<P>POWER IRIS 4D/380VGX (рис.&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#r2_14">0.2.16</A>) фирмы Silicon 
Graphics является одной из наиболее мощных суперстанций. Она представляет собой 
мультимикропроцессорную систему, построенную на 8 RISC процессорах MIPS RS3000 с 
сопроцессорами плавающей запятой RS3010, разделяющих общую память. Система 
предоставляет более 200 MIPS и более 30 MFLOPS. 
<P>Графическая подсистема VGX системы IRIS VISION отображает в секунду более 1 
миллиона Z-буферизованных треугольников, закрашенных по Гуро или Фонгу, со 
скоростью доступа к кадровому буферу более 20 млн. пикселов/с. Она содержит 85 
соответствующих СБИС десяти различных типов. VGX архитектура содержит 4 
подсистемы объединенных в конвейер:<BR><FONT 
face=symbol>·</FONT>&nbsp;геометрическую подсистему,<BR><FONT 
face=symbol>·</FONT>&nbsp;подсистему растеризации,<BR><FONT 
face=symbol>·</FONT>&nbsp;растровую подсистему,<BR><FONT 
face=symbol>·</FONT>&nbsp;дисплейную подсистему. 
<P>
<P><A name=tth_fIg0.16></A><A name=r2_14>
<CENTER><BR><IMG alt="Рисунок 16" 
src="Учебное пособие Архитектуры графических систем_files/kg0316.gif">
<P></CENTER>
<CENTER>Рис. 0.2.16: Архитектура системы POWER IRIS 4D/380VGX</CENTER></A>
<P>
<P>Геометрическая подсистема подсоединена к параллельному ЦП через 64-битный 
шинный интерфейс MPlink. Она принимает геометрические данные, определенные в 
мировых координатах, выполняет преобразования и вычисление освещенности и 
передает данные в пространстве экрана подсистеме растеризации. Компонентами 
геометрической подсистемы являются Командный Процессор и SIMD Геометрическая 
Машина. Командный Процессор принимает данные из шины MPlink и распределяет 
команды между четырьмя модулями Геометрической Машины. Он преобразует все 
принятые слова данных в форму с плавающей запятой вне зависимости от 
представления входных данных. Геометрическая Машина содержит четыре идентичных 
процессорных устройства с плавающей запятой, использующих чипы Texas Instument 
74ACT8867, дающими пиковую скорость в 128 MFLOPS. Эти 4 устройства вместе 
работают как SIMD машина под управлением секвенсора, одновременно обрабатывая до 
четырех вершин многоугольника. 
<P>Подсистема растеризации выполняет вычисления по преобразованию данных по 
вершинам, переданных геометрической подсистемой, в индивидуальные пикселы. С 
каждым пикселом увязаны X,Y экранные координаты и ряд параметров, включающих 
Z-координату, R, G, B, Alpha и текстурные данные. Все эти параметры линейно 
интерполируются между вершинами многоугольника. Подсистема растеризации содержит 
четыре процессора: сортировщик вершин, машину полигонов, машину области и Span 
процессор. 
<P>Первый процессор - сортировщик вершин упорядочивает поток команд и данных с 
плавающей запятой, принятых от Геометрической Машины, в точки, отрезки, 
треугольники и т.д. и передает от одного до четырех примитивов Машине Полигонов. 
Он также сортирует треугольники и квадрилатеральные вершины для последующих 
вычислений. 
<P>Машина полигонов представляет собой SIMD процессор с плавающей запятой, 
содержащих четыре устройства, и структурно подобна Геометрической Машине. Она 
начинает преобразование сканирования треугольников вычисляя углы наклона сторон 
и параметры в X и Y направлении. 
<P>Машина областей представляет собой SIMD процессор с фиксированной запятой, 
также содержащий четыре устройства, работающих под управлением 
микропрограммируемого секвенсора. Она преобразует исходные значения с плавающей 
запятой и информацию об углах для формирования X,Y и значений параметров для 
вертикального расстояния между нижним и верхним ребрами треугольника. Она 
передает эту информацию с углами наклона в Y-направлении Span-процессору. 
<P>Параметры расстояний и углов принимаются от 5 до 10 Span процессорами. В 
базовой конфигурации с пятью Span-процессорами, каждый процессор управляет 1/5 
из видимых 1280 столбцов экрана. Span-процессор номер 0 управляет столбцами 0, 
5, 10 и т.д., процессор номер 1 управляет столбцами 1, 6, 11 и т.д. В связи с 
тем, что полосы, генерируемые через некоторый треугольник, всегда являются 
близлежащими, то обработка полос равномерно распределяется между пятью 
процессорами. Конфигурация с 10 процессорами распределяет загрузку подобным 
образом, но каждый Span-процессор управляет каждым 10-м столбцом. 
<P>Каждый Span процессор итерирует между заданным и конечным Y адресами, 
используя данные по углам для генерации Z-координаты, цветовых и текстурных 
координат в заданном столбце. Эти значения передаются растровой подсистеме. 
Растровая подсистема содержит 20 или 40 Машин образов, каждая из которых 
контролирует прямоугольную область экрана. В конфигурации с 20-ю машинами 
отдельная машина образов имеет доступ к 64 К пикселов. Каждый пиксел содержит, 
по крайней мере, 140 бит данных, т.е. кадровый буфер должен иметь емкость в 23 
Мбайта. Растровая подсистема выполняет чтение, запись и копирование между 
банками кадрового буфера со скоростью до 20 млн. пиксел/сек. 140-битный пиксел 
устроен следующим образом: кадровый буфер запоминает по одному байту для R, G, B 
и Alpha-информации для каждого пиксела плоскости отображения дисплея размером 
1280&times;1024. В режиме двойной буферизации это суммируется до 64 бит. Система VGX 
поддерживает 24-битный Z-буфер со знаком. Девять бит глубины банка служат для 
различения раскрашенных планов. Машины образов имеют возможности условного 
стирания, записи, инкремента и декремента этих планов независимо от 24-битного 
значения глубины. 32 бита используются в качестве текстурных планов для R, G, B 
и Alpha информации. 9 бит используются для перекрытия и оконных планов, 
поддерживаемых для использования системой управления окнами. Последние 4 бита, 
называемые Display WID планы, определяют стиль отображения каждого пиксела, 
например, однократное буферирование или двойное буферирование, RGB или индекс 
цвета. 
<P>Дисплейная подсистема принимает пиксельную информацию из кадрового буфера, 
маршрутизирует ее в соответствии с требуемым режимом отображения и передает ее 
на отображение. 
<P>
<CENTER>
<H4><A name=tth_sEc0.2.5.3>Система Stardent GS2000</A></H4></CENTER>
<P>Системы типа Silicon Graphics POWER IRIS используют специализированную 
аппаратуру для быстрого вычисления изображений. Многие из этих вычислений, в 
частности геометрические преобразования, близки к обработке, требуемой во многих 
видах научных вычислений. Stardent GS2000 разработана для предоставления ее 
вычислительных ресурсов как для генерации изображений, так и для ускорения 
других вычислительно интенсивных заданий, которые могут вызываться на машине. 
<P>Stardent GS2000 включает следующие типы процессоров (рис.&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#r2_15">0.2.17</A>): 
<P><FONT face=symbol>·</FONT> мультипотоковый процессор (MSP) - единое 
устройство, которое работает как четыре идентичных логических процессора. Каждый 
процессор или поток может выполнять некоторое множество машинных инструкций. Эти 
потоки обеспечивают скорость 20-25 MIPS; 
<P><FONT face=symbol>·</FONT> процессор векторных операций и операций с 
плавающей запятой (VFP) - отдельное устройство интегрированное в MSP. VFP 
обеспечивает скорость 80 MFLOPS на данных одинарной точности и 40 MFLOPS - на 
двойной. VFP играет важную роль в обработке графики, работая в качестве 
"front-end" для процессора отображения. Специальные векторные инструкции 
выполняют координатные преобразования (600 К 3D преобразований векторов в сек), 
отсечение и вычисления освещенности. Геометрические данные и результаты расчета 
освещенности передаются процессору отображения; 
<P><FONT face=symbol>·</FONT> процессор отображения (Rendering processor - RP) - 
микропрограммная машина, которая одновременно оперирует блоками 4&times;4 пиксела. Для 
отображения графических примитивов процессор отображения "прогуливается" поверх 
блоков пикселов, вычисляя различные 16-ти пиксельные блоки, пока не будут 
обработаны все пикселы, покрывающие примитив. Процессор отображения принимает от 
VFP результаты преобразования, отсечения и расчета освещенности примитивов, 
преобразует их в пикселы и запоминает результаты в виртуальной памяти в виде 
виртуальных пиксельных карт.<BR>
<P>
<P><A name=tth_fIg0.17></A><A name=r2_15>
<CENTER><BR><IMG alt="Рисунок 17" 
src="Учебное пособие Архитектуры графических систем_files/kg0317.gif">
<P></CENTER>
<CENTER>Рис. 0.2.17: Архитектура системы Stardent GS2000</CENTER></A>
<P>
<P>Процессор отображения может читать, модифицировать и записывать изображения 
со скоростью до 80 Мпикселов/с. Он может вычерчивать 600&nbsp;K 3D клиппируемых 
десятипиксельных векторов и 160&nbsp;K 100 пиксельных треугольников Гуро с 
Z-буферизацией. 
<P>Каждое изображение читаемое и записываемое процессором отображения 
запоминается в виртуальной памяти как комплект из одной или более виртуальных 
пиксельных карт (virtual pixel maps - VMAPs) каждая до 64&nbsp;K&times;64&nbsp;K 
пикселов с 32 битами на пиксел (128 Гбайт). 
<P>Это освобождает графическую подсистему от ограничений единственного кадрового 
буфера фиксированного разрешения. VMAP может листоваться на/с дисковой памяти, 
наподобие других данных в виртуальной памяти. VMAP отображается при копировании 
видимой порции в видеопамять. 
<P>Видеопамять содержит 1024 строки по 1280 пикселов. Они могут быть глубиной 16 
или 32 бита (40&nbsp;Мбайт). Двойная буферизация делает возможным 
стереоотображение. 
<P>
<CENTER>
<H3><A name=tth_sEc0.2.6>0.2.6</A>&nbsp;&nbsp;Выводы</H3></CENTER>
<P>Таким образом, с точки зрения разработчиков графических дисплейных систем, на 
примере продукции ведущих фирм, специализирующихся в области технических средств 
машинной графики, можно выделить три основных подхода: 
<P><FONT face=symbol>·</FONT> создание функционально завершенного ("закрытого" 
для разработчика) графического сопроцессора, аппаратно реализующего основные 
примитивы графических стандартов GKS/CGI (Intel 82786);<BR>
<P><FONT face=symbol>·</FONT> предоставление разработчику средств строить 
архитектуры растровых графических дисплейных систем (с различными 
функциональными и скоростными характеристиками) на основе набора 
специализированных СБИС, выполняющих строго регламентированные функции (National 
Semiconductor); 
<P><FONT face=symbol>·</FONT> создание универсального (полностью 
программируемого на языке высокого уровня) процессора, аппаратно реализующего 
основные растровые операции и предоставляющего разработчику максимальную 
гибкость в реализации собственных алгоритмов (Texas Instruments, i860). 
<P></I></B></TT><U>2.&nbsp;СТАНДАРТИЗАЦИЯ В МАШИННОЙ ГРАФИКЕ</U> 
<CENTER>
<H3><A name=tth_sEc0.3>0.3</A>&nbsp;&nbsp;СТАНДАРТИЗАЦИЯ В МАШИННОЙ 
ГРАФИКЕ</H3></CENTER>
<P>Начальный период создания и развития средств машинной графики 
характеризовался развитием многочисленных, иногда достаточно эффективных, 
графических систем, ориентированных на то или иное оборудование [<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#mbib1" name=CITEmbib1>1</A>,]. 
Фактически этот период можно охарактеризовать как период основного внимания к 
техническим средствам [<A href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#mbib2" 
name=CITEmbib2>2</A>]. Программное обеспечение рассматривалось, как удачно 
заметил Гантер [<A href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#mbib18" 
name=CITEmbib18>18</A>], чем-то вроде "верхнего слоя краски на аппаратуре". 
<P>В следующий период более актуальной стала проблема создания программного 
обеспечения. Во-первых, велись разработки алгоритмов машинной графики - 
генерация примитивных элементов, интерполяция, аппроксимация, формы и методы 
представления изображений и т.д.; во-вторых, создавались инструментальные 
средства машинной графики - графические языки, пакеты процедур, языки диалога. 
<P>Постепенно сформировалось представление о программном продукте как о 
промышленном изделии, что выдвинуло проблему стандартизации графического 
программного обеспечения. Развитие сетей ЭВМ, оснащенных терминальными 
устройствами различных типов, потребовало обеспечить независимость программного 
обеспечения от аппаратуры. 
<P>
<CENTER>
<H3><A name=tth_sEc0.3.1>0.3.1</A>&nbsp;&nbsp;NGP (Network graphics 
рrotocol)</H3></CENTER>
<P>Первые результаты по стандартизации были получены применительно к сети ARPA в 
рамках работ по разработке протоколов для аппаратно и машинно-независимого 
представления графических данных в сети [<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#mbib116" 
name=CITEmbib116>116</A>]. 
<P>Модель работы пользователя в сети с применением графического протокола [<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#mbib116" 
name=CITEmbib116>116</A>] приведена на рис.&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#r3_1">0.3.18</A>. 
<P>
<P><A name=tth_fIg0.18></A><A name=r3_1>
<CENTER><BR><IMG alt="Рисунок 18" 
src="Учебное пособие Архитектуры графических систем_files/kg0318.gif">
<P></CENTER>
<CENTER>Рис. 0.3.18: Модель организации работы в сети</CENTER></A>
<P>
<P>В начале сеанса работы пользователь располагается перед дисплеем, 
подключенным к терминальной ЭВМ, инициирует терминальную программу и 
устанавливает связь с ЭВМ сети, на которой ему будет предоставлено необходимое 
обслуживание. Прикладная программа главной ЭВМ при необходимости выполнить 
ввод/вывод использует обслуживающую программу, функцией которой является 
интерфейс прикладной программы с сетевым графическим протоколом. 
<P>Терминальная программа используется для интерпретации протокола в подходящую 
аппаратно-зависимую форму и для реализации функций ввода и запроса к обстановке. 

<P>Данные в сети передаются только в стандартной форме, следовательно, на 
передающей стороне выполняется кодирование, а на приемной - декодирование 
информации. Предусмотрено два уровня протокола вывода: сегментированный и 
структурированный форматы. В сегментированном формате изображение строится из 
отдельных сегментов, представляющих собой список графических примитивов (точек, 
линий, строк текста). ТП выполняет только перекодировку и может быть достаточно 
простой. В структурированном формате изображение строится из вызовов отдельных 
подкартин, состоящих из примитивов и вызовов других подкартин. Объем 
передаваемых данных уменьшается, но на ТМ, как правило, требуется программное 
выполнение преобразований. 
<P>Для работы с виртуальными устройствами ввода, служащими для выполнения 
позиционирования, ввода скалярного значения, ввода состояния кнопки (вкл/выкл), 
ввода строки символов, ввода времени, используется два метода: 1) запроса и 
получения состояния устройства ввода, например, строки символов; 2) разрешения 
пользователю совершить действия, приводящие к возникновению события ввода и 
получения на главной ЭВМ "сообщения" события. 
<P>Аппаратная независимость обеспечивается средствами опроса, котоpый позволяет 
выяснить конфигурацию и возможности используемых устройств. Адаптация к 
возможностям реализуется необходимыми настройками прикладной и обслуживающей 
программ. 
<P>После публикации [<A href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#mbib116" 
name=CITEmbib116>116</A>] появился целый ряд работ, посвященных использованию 
идей протокола в нашей стране [<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#mbib4" name=CITEmbib4>4</A>,,,]. 
<P>
<CENTER>
<H3><A name=tth_sEc0.3.2>0.3.2</A>&nbsp;&nbsp;Международная деятельность по 
стандартизации в машинной графике</H3></CENTER>
<P>Работы по протоколам послужили отправной точкой по развитию стандартизации в 
машинной графике. В 1974&nbsp;г. в США был создан комитет по стандартизации 
машинной графики GSPC в АСМ/SIGGRAPH. В 1975&nbsp;г. в ФРГ в Институте 
стандартов был создан подкомитет по машинной графике - DIN-NI/UA-5.9. В 
1977&nbsp;г. в международной организации по стандартизации (ISO) была создана 
рабочая группа TC97/SC5/WG2 "машинная графика" [<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#mbib70" name=CITEmbib70>70</A>]. 
<P>Важную роль в разработке методологии стандартизации машинной графики сыграла 
конференция в Сейлаке (Франция), организованная графическим подкомитетом WG 5.2 
IFIP в 1976&nbsp;г. На конференции были сформулированы и обсуждены основные 
условия и проблемы стандартизации. Было установлено, что основная цель 
стандартизации - переносимость графических систем, которая достигается 
стандартизацией интерфейса между графическим ядром системы (базовой графической 
системой), реализующим собственно графические функции, и моделирующей системой - 
проблемно-ориентированной прикладной программой, использующей функции 
графического ядра. Базовая система должна обладать: независимостью от 
вычислительных систем; независимостью от языков программирования; независимостью 
от области применения; независимостью от графических устройств. 
<P>Структура прикладной графической системы, удовлетворяющей сформулированным 
требованиям, может быть представлена в виде шестиуровневой модели (рис.&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#r3_2">0.3.19</A>). 
<P>
<P><A name=tth_fIg0.19></A><A name=r3_2>
<CENTER><BR><IMG alt="Рисунок 19" 
src="Учебное пособие Архитектуры графических систем_files/kg0319.gif">
<P></CENTER>
<CENTER>Рис. 0.3.19: Уровневая модель прикладной графической 
системы</CENTER></A>
<P>
<P>Процесс преобразования информации при выполнении вывода может быть 
представлен состоящим из следующих этапов (рис.&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#r3_3">0.3.20</A>): 
<P>1.&nbsp;Модельные преобразования. Проблемно-ориентированный уровень из 
геометрических моделей отдельных объектов, задаваемых в собственных локальных 
системах координат, формирует описание совокупного объекта в некоторой единой 
(мировой) системе координат. Описание совокупного объекта подается в графическую 
систему. 
<P>2.&nbsp;Нормализующие преобразования. Графическая система переводит описание 
из мировой, вообще говоря произвольной, системы координат в т.н. нормализованные 
координаты устройства, имеющие фиксированные пределы изменения координат, 
например, от 0.0 до 1.0. 
<P>3.&nbsp;Преобразования сегментов. Если графическая система предоставляет 
средства манипулирования отдельными подкартинами изображения (часто именуемыми 
сегментами), например, для независимого размещения отдельных самостоятельных 
частей изображения, то могут потребоваться такие преобразования. 
<P>4.&nbsp;Видовые преобразования. В случае 3D описания изображения и 2D 
устройства вывода необходимо выполнить проецирование изображения на заданную 
картинную плоскость. Наоборот, при 2D сцене и 3D устройстве вывода необходимо 
выполнить преобразование, связанное с размещением изображения. При выполнении 
этих преобразований, естественно, может потребоваться выполнение отсечения 
частей изображения. После этого этапа по сути дела готово описание изображения в 
некоторой аппаратно-независимой форме, пригодной для вывода на любое устройство. 

<P>5.&nbsp;Преобразование рабочей станции. Для выполнения вывода на конкретное 
устройство необходимо преобразование данных из аппаратно-независимой формы в 
координаты устройства. 
<P>Процесс преобразования координатной информации при вводе от координатных 
устройств обратен вышеописанному преобразованию при выводе. 
<P>
<P><A name=tth_fIg0.20></A><A name=r3_3>
<CENTER><BR><IMG alt="Рисунок 20" 
src="Учебное пособие Архитектуры графических систем_files/kg0320.gif">
<P></CENTER>
<CENTER>Рис. 0.3.20: Схема преобразований координатной информации в графической 
системе</CENTER></A>
<P>
<P>Концептуальная модель переносимой графической системы показана на 
рис.&nbsp;<A href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#r3_4">0.3.21</A>. 
Штриховые линии на нем обозначают интерфейсы, при стандартизации которых может 
быть обеспечена переносимость. 
<P>Верхний уровень стандартизации - IGES предназначен для обеспечения 
мобильности компонент САПР. 
<P>Средний уровень стандартизации - уровень базового графического пакета (GKS) 
определяется выбором базовых функций системы. Этот интерфейс делает базовую 
графическую систему независимой от области применения. 
<P>Нижний уровень стандартизации - уровень связи с виртуальным графическим 
устройством (CGI) зависит от выбора примитивов ввода/вывода, являющихся 
абстракцией возможностей устройств. Этот интерфейс делает базовую графическую 
систему аппаратно-независимой. 
<P>
<P><A name=tth_fIg0.21></A><A name=r3_4>
<CENTER><BR><IMG alt="Рисунок 21" 
src="Учебное пособие Архитектуры графических систем_files/kg0321.gif">
<P></CENTER>
<CENTER>Рис. 0.3.21: Архитектура переносимой графической системы</CENTER></A>
<P>
<P>Независимость от вычислительных систем и языков программирования 
обеспечивается соответствующей дисциплиной программирования и взаимодействия с 
системами программирования. 
<P>
<CENTER>
<H3><A name=tth_sEc0.3.3>0.3.3</A>&nbsp;&nbsp;Деятельность ISO, IEC по 
стандартизации в машинной графике</H3></CENTER>
<P>Главными организациями формирующими международные стандарты в области 
информационной технологии являются ISO (International Organization for 
Standartization) и IEC (International Electrotechnical Commission). В конце 
1987&nbsp;г. был сформирован первый совместный технический комитет (JTC1) 
ISO/IEC с целью стандартизации в области информационной технологии. 
Стандартизацией в машинной графике занимается 24-й подкомитет (ISO/IEC 
JTC1/SC24). В 1988&nbsp;г. была создана постоянная советская часть этого 
подкомитета. Основными стандартами являются [<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#mbib68" name=CITEmbib68>68</A>]: 
<P>1.&nbsp;GKS (Graphical Kernel System) - набор базовых функций для 2D 
аппаратно-независимой машинной графики. 
<P>2.&nbsp;GKS-3D (Graphical Kernel System for 3 Dimensions) - расширение GKS 
для поддержки базовых функций в 3D. 
<P>3.&nbsp;PHIGS (Programmer's Hierarchical Interactive Graphics System) - набор 
базовых функций 3D графики аналогичный GKS-3D, но в отличие от GKS-3D, 
ориентированной на непосредственный вывод графических примитивов, группируемых в 
сегменты, графическая информация накапливается в иерархической структуре данных. 
В целом PHIGS ориентирован на приложения, требующие быстрой модификации 
графических данных, описывающих геометрию объектов. 
<P>4.&nbsp;Языковые интерфейсы (Language bindings) - представление функций и 
типов данных функциональных графических стандартов в стандартизованных языках 
программирования. 
<P>5.&nbsp;CGM (Computer Graphics Metafile) - аппаратно-независимый формат 
обмена графической информацией. Используется для передачи и запоминания 
информации, описывающей изображения. 
<P>6.&nbsp;CGI (Computer Graphics Interafce) - набор базовых элементов для 
управления и обмена данными между аппаратно-независимым и аппаратно-зависимым 
уровнями графической системы. 
<P>7.&nbsp;CGRM (Computer Graphics Reference Model) - модель стандартов в 
машинной графике, которая определяет концепции и взаимосоотношения применительно 
к будущим стандартам в машинной графике. 
<P>8.&nbsp;Регистрация - механизм регистрации стандартизуемых аспектов 
примитивов вывода, обобщенных примитивов, escape-функций (для доступа к 
аппаратным возможностям устройств) и других графических элементов. 
<P>9.&nbsp;Тестирование реализаций на соответствие графическим стандартам - 
основные цели этого проекта: специфицирование характеристик стандартизованных 
тестов, используемых для определения соответствия реализаций графическим 
стандартам, и выработка предписаний разработчикам функциональных стандартов 
относительно правил соответствия. 
<P>В составе 24-го подкомитета имеется 5 рабочих групп (WG): 
<P><B>WG1:</B> Архитектура. Цель этой группы - развитие CGRM - модели стандартов 
машинной графики. 
<P><B>WG2:</B> Интерфейсы прикладных программ. Стандартизация функциональных 
спецификаций для интерфейсов прикладных программ. 
<P><B>WG3:</B> Метафайлы и интерфейсы с устройствами. Стандартизация обмена 
графической информацией, включая метафайл и интерфейс с устройствами. 
<P><B>WG4:</B> Языковые интерфейсы. Стандартизация языковых интерфейсов для 
функциональных стандартов машинной графики. 
<P><B>WG5:</B> Верификация, тестирование и регистрация. Разрабатывает методы и 
процедуры проверки соответствия и тестирования реализаций функциональных 
стандартов машинной графики и методов и процедур регистрации графических 
примитивов. 
<P>
<CENTER>
<H3><A name=tth_sEc0.3.4>0.3.4</A>&nbsp;&nbsp;Классификация 
стандартов</H3></CENTER>
<P>Из рис.&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#r3_4">0.3.21</A> видно, что для 
обеспечения мобильности программного обеспечения требуется стандартизовать: 
<P><FONT face=symbol>·</FONT> базовую графическую систему, т.е. стандартизовать 
графический интерфейс (набор базовых графических функций) - Core System, GKS, 
GKS-3D, PMIG, PHIGS, PHIGS+ и т.д.<BR>
<P><FONT face=symbol>·</FONT> графический протокол (порядок и правила обмена 
информацией) - IGES, CGM и др.<BR>
<P>Далее будут рассмотрены графические интерфейсы, являющиеся международными 
графическими стандартами, а затем - графические протоколы, среди которых большая 
часть - стандарты де-факто и только один - CGM - международный стандарт. 
<P>
<CENTER>
<H3><A name=tth_sEc0.3.5>0.3.5</A>&nbsp;&nbsp;Core-System</H3></CENTER>
<P>Существенным этапом в области стандартизации машинной графики явилась 
публикация проекта стандарта CORE-SYSTEM (GSPC-77) [<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#mbib118" 
name=CITEmbib118>118</A>], модель которой приведена на рис.&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#r3_5">0.3.22</A>. Главные идеи, 
положенные в основу системы CORE [<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#mbib118" 
name=CITEmbib118>118</A>,]: разделение функций ввода и вывода; минимизация 
отличий между выводом на графопостроитель и интерактивный дисплей; концепция 
двух координатных систем - мировой системы координат, в которой конструируется 
выдаваемое изображение, и приборной системы координат, в которой представляются 
данные для отображения; концепция дисплейного файла, содержащего приборную 
координатную информацию; понятие дисплейного файла сегментов, каждый из которых 
может независимо модифицироваться как элемент; обеспечение функций 
преобразования данных из мировой системы координат в приборную путем вызова 
видового преобразования. 
<P>В системе выделены следующие группы функций: вывода; сегментирования 
дисплейного файла; установления и опроса атрибутов примитивов (цвет, яркость, 
ширина линии и т.д.) и атрибутов сегментов (тип, видимость, указуемость и т.д.); 
визуализации; выполнения ввода с виртуальных устройств ввода типа указка, 
клавиатура, кнопка, локатор, датчик; управления и доступа к специальным 
аппаратным возможностям. 
<P>В 1979&nbsp;г. был опубликован уточненный проект стандарта CORE-SYSTEM 
(GSPC-79) [<A href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#mbib119" 
name=CITEmbib119>119</A>]. Кроме прочих изменений, в этой версии предусмотрена 
(весьма ограниченно) поддержка растровых устройств. Всего предлагалось 266 
функций, так что охватывался широкий спектр применения машинной графики, начиная 
от пассивного вывода до интерактивных систем высокого уровня. 
<P>
<P><A name=tth_fIg0.22></A><A name=r3_5>
<CENTER><BR><IMG alt="Рисунок 22" 
src="Учебное пособие Архитектуры графических систем_files/kg0322.gif">
<P></CENTER>
<CENTER>Рис. 0.3.22: Модель графической системы, положенная в основу 
CORE-SYSTEM</CENTER></A>
<P>
<P>Ясно, что для многих приложений требуется лишь часть возможностей графпакета, 
все остальные, если будут присутствовать, будут приводить к неэффективности 
прикладной программы. Для устранения этого противоречия система разбита на три 
не зависящие друг от друга группы уровней - группа уровней вывода, группа 
уровней ввода, группа уровней размерности. Уровни внутри группы совместимы 
снизу-вверх. 
<P>Группа уровней вывода включает в себя: 
<P><FONT face=symbol>·</FONT> базовый вывод, поддерживающий полный набор 
примитивов вывода, их атрибутов и операций визуализации и предназначенный для 
приложений, не требующих выборочного редактирования изображений;<BR>
<P><FONT face=symbol>·</FONT> буферизованный вывод дополнительно к предыдущему 
уровню позволяет использовать сохраняемые сегменты без преобразования образа - 
преобразования графической информации, содержащейся в сегменте в момент 
выполнения вывода.<BR>
<P>Группа уровней ввода включает: 
<P><FONT face=symbol>·</FONT> без ввода, т.е. применяется для пассивных 
приложений; 
<P><FONT face=symbol>·</FONT> синхронный ввод - ввод производится синхронно с 
работой прикладной программы, т.е. ее исполнение приостанавливается до 
завершения ввода;<BR>
<P><FONT face=symbol>·</FONT> асинхронный ввод - ввод производится независимо от 
работы прикладной программы, а вводимые оператором данные накапливаются в 
обрабатываемой прикладной программой очереди ввода.<BR>
<P>На последних двух уровнях поддерживаются виртуальные устройства ввода классов 
ЛОКАТОР, ШТРИХ, ДАТЧИК, ВЫБОР, УКАЗКА и КЛАВИАТУРА. 
<P>Группа уровней размерности включает:<BR><FONT face=symbol>·</FONT>&nbsp;2D - 
поддерживаются только 2D операции;<BR><FONT face=symbol>·</FONT>&nbsp;3D - 
дополнительно к 2D поддерживаются и 3D операции. 
<P>Предложения GSPC получили широкий отклик в виде многочисленных реализаций 
версий базовой системы [<A href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#mbib7" 
name=CITEmbib7>7</A>,,,,]. 
<P>
<CENTER>
<H3><A name=tth_sEc0.3.6>0.3.6</A>&nbsp;&nbsp;GKS (Graphical Kernel 
System)</H3></CENTER>
<P>Результатом работ в ФРГ было создание системы GKS. Модель графической 
системы, положенная в ее основу, приведена на рис.&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#r3_6">0.3.23</A>. В 1979&nbsp;г. 
GKS была принята в качестве отправной точки международного стандарта. В процессе 
разработки международного стандарта в исходную версию GKS был внесен целый ряд 
изменений, приблизивших ее к CORE-SYSTEM, но сохранивших ряд отличительных 
фундаментальных концепций. Основной из таких отличительных черт является 
введение понятия рабочей станции, представляющей собой абстракцию совокупности 
виртуальных устройств ввода/вывода, более полно соответствующей современной 
тенденции использования интеллектуальных терминалов. 
<P>По максимуму рабочая станция обладает следующими свойствами: имеет одну 
адресуемую поверхность вывода с фиксированным разрешением; допускается только 
прямоугольное поле отображения, которое не может состоять из нескольких 
отдельных частей; позволяет задание и использование поля отображения, которое 
меньше максимально возможного, с гарантией того, что изображение не генерируется 
вне заданного поля отображения; поддерживает несколько типов линий, шрифтов 
текста, размеров символов и т.д. для вывода примитивов с различными атрибутами; 
имеет одно или больше устройств ввода для каждого класса устройств, которые 
независимо друг от друга могут работать в одном из трех режимов - синхронный 
ввод, опрос, асинхронный ввод; запоминает сегменты и обеспечивает средства для 
изменений сегментов и манипуляций с ними. 
<P>Ясно, что выделение рабочей станции излишне громоздко, когда приходится иметь 
дело с одним устройством вывода и ввода. Основная ценность введения понятия 
рабочей станции состоит в удобной и естественной возможности разделения 
аппаратно-независимой и аппаратно-зависимой частей. 
<P>Следует отметить, что в GKS столь же последовательно проводится разделение 
функций ввода/вывода, как и в CORE. 
<P>Набор примитивов GKS подобен набору примитивов CORE, хотя меньше и несколько 
более приспособлен для целей растровой графики (ломаная; полимаркер; текст; 
многоугольник, который может быть "залит" одним цветом, заштрихован, покрыт 
узором, либо может быть не закрашен за исключением границ; массив прямоугольных 
ячеек, закрашенных одним цветом; обобщенный примитив черчения, дающий доступ к 
специальным геометрическим и графическим возможностям устройств). 
<P>В отличие от CORE в GKS нет понятия текущей позиции, так что построение 
примитива не зависит от предыстории вычерчивания. В GKS имеется 2 способа 
задания атрибутов примитивов. Первый - индивидуальный способ аналогичен 
используемому в CORE, не зависит от рабочей станции и основан на индивидуальном 
задании атрибутов, которые сохраняют свое значение пока не будут изменены 
прикладной программой. Второй - групповой способ зависит от рабочей станции и 
основан на задании независимых групп значений атрибутов. Для использования 
требуемой группы атрибутов задается ее номер, который сохраняет свое значение 
пока не будет переустановлен. 
<P>Видовые операции, определяющие переход от входных (мировых) координат к 
физическим координатам устройства, также похожи, но в GKS, в отличие от CORE, 
допускается наличие не одной, а нескольких пар окно/поле вывода. 
<P>Средства сегментации GKS напоминают средства сегментации CORE, но в GKS 
добавлены средства манипулирования сегментами на заданной рабочей станции и 
средства работы с рабочей станцией специального типа - приборно-независимым 
хранилищем сегментов (ПНХС). 
<P>Виртуальные устройства ввода также подобны, хотя названия несколько 
отличаются и в GKS правила работы с устройствами лучше проработаны. 
<P>
<P><A name=tth_fIg0.23></A><A name=r3_6>
<CENTER><BR><IMG alt="Рисунок 23" 
src="Учебное пособие Архитектуры графических систем_files/kg0323.gif">
<P></CENTER>
<CENTER>Рис. 0.3.23: Модель графической системы, положенная в основу 
GKS</CENTER></A>
<P>
<P>Для повышения эффективности конкретных приложений в GKS, аналогично CORE, 
предусмотрено разбиение на уровни. Предлагается три уровня вывода и три уровня 
всех остальных функций. 
<P>Уровни вывода: 
<P><B>0:</B> Минимальный вывод. Доступны все примитивы. Используются только 
групповые, немодифицируемые атрибуты примитивов. В каждый момент времени активна 
только одна рабочая станция вывода. Опросы параметров системы - только базовые. 
Доступно чтение пикселов - отдельных точек изображения из растровых устройств. 
<P><B>1:</B> Базовая сегментация с полным выводом. Все возможности уровня 0. 
Полное управление рабочей станцией. Полные возможности вывода. Полные 
возможности групповых таблиц атрибутов. Одновременно могут быть активными 
несколько рабочих станций. Есть рабочие станции типа метафайл для 
сохранения/воспроизведения изображений. Может использоваться требуемое число пар 
окно/поле вывода. Есть базовая сегментация (без ПНХС). Доступны требуемые 
опросы. 
<P><B>2:</B> Приборно-независимое хранилище сегментов. Все возможности уровня 1. 
Имеется ПНХС. 
<P>Уровни ввода: 
<P><B>A:</B> Нет ввода. 
<P><B>B:</B> Синхронный ввод. Существуют виртуальные устройства ввода каждого 
класса, работающие в режиме синхронного ввода (request). 
<P><B>C:</B> Полный ввод. Все возможности ввода уровня B. Предусмотрены режимы 
асинхронного ввода и ввода по опросу (event и sample). 
<P>В 1985&nbsp;г. GKS была принята в качестве международного стандарта [<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#mbib86" name=CITEmbib86>86</A>]. 
В 1988&nbsp;г. для стандартизованных языков программирования были приняты 
международные стандарты на интерфейс GKS c языками Fortran, Pascal, Ada, C [<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#mbib89" name=CITEmbib89>89</A>]. 
<P>
<CENTER>
<H3><A name=tth_sEc0.3.7>0.3.7</A>&nbsp;&nbsp;GKS-3D (Graphical Kernel System 
for Three Dimensions)</H3></CENTER>
<P>Отличия GKS-3D от GKS заключаются в добавлении 3D функций: 
<P><FONT face=symbol>·</FONT> примитивов 3D вывода; 
<P><FONT face=symbol>·</FONT> установки атрибутов вывода (2 функции); 
<P><FONT face=symbol>·</FONT> поддержки 3D преобразований (9 функций); 
<P><FONT face=symbol>·</FONT> работы с 3D сегментами и преобразований 2D 
сегментов в 3D и наоборот (4 функции); 
<P><FONT face=symbol>·</FONT> ввода с 3D координатных устройств (10 функций); 
<P><FONT face=symbol>·</FONT> утилит работы с матрицами 3D преобразований (2 
функции). 
<P>В целом GKS может рассматриваться как подмножество GKS-3D, т.е. 2D 
приложения, написанные на GKS, гарантированно исполняются в 3D окружении без 
каких-либо изменений. 
<P>В 1988&nbsp;г. GKS-3D была принята в качестве международного стандарта [<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#mbib90" name=CITEmbib90>90</A>]. 
В период с 1988 по 1990&nbsp;гг. прорабатывались проекты стандартов ISO 8806 на 
интерфейсы GKS-3D с языками программирования. В 1991&nbsp;г. завершилось их 
принятие в качестве международных стандартов [<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#mbib91" name=CITEmbib91>91</A>]. 
<P>
<CENTER>
<H3><A name=tth_sEc0.3.8>0.3.8</A>&nbsp;&nbsp;PHIGS (Programmer's Hierarchical 
Interactive Graphics System)</H3></CENTER>
<P>Во многих приложениях возникает необходимость геометрического моделирования 
трехмерных тел (САПР машиностроительного, строительного, архитектурного и других 
направлений, системы автоматизации научных исследований, системы визуализации и 
т.д.). 
<P>Использование GKS или GKS-3D для отображения результатов моделирования 
предполагает, что моделирование целиком должна выполнять прикладная программа, 
так как эти системы ориентированы на прямой ввод/вывод и в них не предусмотрено 
иного манипулирования графическими данными кроме накопления в сегментах. 
<P>PHIGS [<A href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#mbib68" 
name=CITEmbib68>68</A>,,,,] же комбинирует графику с техникой моделирования и 
представляет собой набор функций программирования графики с поддержкой быстрой 
модификации графических данных, описывающих геометрические соотношения объектов. 

<P>Набор примитивов вывода и их атрибутов в PHIGS тот же самый, что и в GKS-3D с 
добавлением примитива "annotation text relative" для пометки объектов. 
<P>Принципиальное отличие PHIGS от GKS состоит в том, что в PHIGS создание и 
отображение изображения разделены на две независимых фазы - занесения в 
централизованную структурную память (CSS - Centralized Structure Store) и 
отображения заданной структуры на требуемую рабочую станцию. 
<P>Структура состоит из графических и неграфических элементов. Поддерживаются 
возможности создания и редактирования структур в CSS. Структура может вызывать 
другие структуры за счет чего создаются иерархии. Предусмотрено 9 классов 
структурных элементов: 
<P>
<CENTER>
<TABLE>
  <TBODY>
  <TR>
    <TD>примитивы вывода; </TD>
    <TD align=right>спецификация атрибута; </TD>
  <TR>
    <TD>локальное преобразование моделирования; </TD>
    <TD align=right>редактирование; </TD>
  <TR>
    <TD>обобщенный структурный элемент; </TD>
    <TD align=right>прикладные данные; </TD>
  <TR>
    <TD>глобальное преобразование моделирования; </TD>
    <TD align=right>управление; </TD>
  <TR>
    <TD>отсечение. </TD></TD></TR></TBODY></TABLE></CENTER>
<P>Графический вывод задается в т.н. модельных координатах. Элемент "локальное 
преобразование моделирования" задает преобразование, которое применяется к 
последующим примитивам вывода. 
<P>Элемент "редактирование" определяет метку, используемую при редактировании и 
несущественную при отображении. Предоставлены возможности поиска метки и 
установки на нее указателя. 
<P>"Обобщенный структурный элемент" позволяет определить нестандартные действия. 

<P>Элемент "прикладные данные" несущественен при отображении. Обычно 
представляет собой указатель на прикладную базу данных. 
<P>Основное отличие между системами PHIGS и GKS-3D заключается в наличии 
элемента "Исполнить структуру" (Execute Structure), позволяющего при отображении 
исполнить структуру как часть другой. Когда такой элемент принимается 
интерпретатором, то текущее состояние упрятывается и управление переключается на 
структуру, заданную в элементе. После завершения интерпретации вызванной 
структуры восстанавливается исходное состояние и интерпретация продолжается с 
элемента, следующего за элементом "Исполнить структуру". 
<P>При вызове структуры она наследует глобальное модельное преобразование 
вызвавшей структуры. Даже если при исполнении вызванной структуры глобальное 
модельное преобразование будет изменено с помощью соответствующих функций, тем 
не менее по возврату исходное глобальное преобразование будет восстановлено. 
<P>Локальное модельное преобразование, комбинируясь с глобальным, формирует 
текущее модельное преобразование. 
<P>В PHIGS может быть отредактирован отдельный графический элемент структуры, 
что обеспечивает большую скорость модификации изображения по сравнению с GKS, в 
которой, как минимум, требуется перегенерация сегмента, содержащего изменяемый 
примитив. 
<P>
<CENTER>
<H4>Отображение в PHIGS</H4></CENTER>
<P>PHIGS - 3D система, хотя ряд функций позволяет работать в 2D. При этом все 
функции преобразуются в эквивалентные 3D вызовы. 
<P>В отличие от ряда подобных систем, все координатные системы в PHIGS - правые 
координатные системы с возрастанием координаты по оси Z при движении по 
направлению к наблюдателю. 
<P>При интерпретации структуры из ее элементов генерируются примитивы вывода с 
использованием текущего модельного преобразования. Координаты сгенерированных 
примитивов вывода заданы в мировой системе координат (World Coordinates - WC). 
<P>Отображение в PHIGS выполняется в две стадии. На первой, называемой View 
Orientation (ориентация отображения), координатная система изменяется к 
необходимой для отображения выводимого объекта. На второй стадии, называемой 
View Mapping (преобразование отображения), объект преобразуется в 
аппаратно-независимые нормализованные координаты устройства, готовые для вывода 
на каждой открытой рабочей станции. Проецирование выполняется на этой стадии. 
<P>View Orientaion изменяет мировую систему координат к системе координат точки 
наблюдения (View Reference Coordinate system - VRC). Суть состоит в переносе 
начала координат в точку фактического наблюдения объекта и с направлением осей 
согласно требуемой проекции. 
<P>View Mapping более сложна и зависит от выбранного типа проекции - 
"параллельной" или "перспективной". При параллельной проекции объем видимости 
определяется как параллелепипед преобразуемый в порт проекции, который 
представляет собой прямоугольный параллелепипед в нормализованных координатах 
проекции с ребрами параллельными осям. При перспективной проекции объем 
видимости - конус. 
<P>Для каждого типа проекции плоскость проекции - окно, определяемое X-Y 
размерами параллелепипеда или конуса. Плоскость проекции перпендикулярна Z-оси. 
Для параллельных проекций угол, который образуют проекторы с плоскостью 
проекции, определяется точкой центра проекции (Projection Reference Point - 
PRP). Проекторы параллельны линии из PRP в центр окна на плоскости проекции. При 
перспективной проекции все проекторы проходят через PRP. 
<P>Не требуется, чтобы точка проецирования (PRP) лежала на оси Z. В общем случае 
все типы проекций могут быть получены путем ориентации объекта относительно VRC 
осей и посредством размещения PRP относительно VRC-осей и плоскости проекции. 
<P>Для многих применений требуется одновременное наличие нескольких видов 
объекта. В PHIGS возможно определение множества видов одного или различных 
объектов. Для каждого вида SET VIEW REPRESENTATION (установить представление 
вида) задает как он будет показан на требуемой рабочей станции. Отсечение 
производится для создания части пространства нормазизованных координат проекции 
(Normalized Projection Coordinates - NPC), потенциально видимой на рабочей 
станции для этого вида. 
<P>Преобразования окно/порт рабочей станции близки к GKS в определении 
расположения пространства нормализованных координат проекции на рабочей станции 
и в одинаковости коэффициентов масштабирования вдоль направлений X и Y. 
<P>
<CENTER>
<H3><A name=tth_sEc0.3.9>0.3.9</A>&nbsp;&nbsp;PHIGS+</H3></CENTER>
<P>PHIGS+ [<A href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#mbib94" 
name=CITEmbib94>94</A>,,] - расширение PHIGS, имеющее дополнительные 
функциональные возможности для приложений, требующих учета освещенности, 
раскраски (интерполяции цветов по поверхности), а также дополнительные 
возможности по управлению отображением и новые примитивы для поддержки 
эффективного описания сложных поверхностей. Эти расширения были сформулированы 
как поправка к существующим частям 1-3 стандарта PHIGS и введением новой части 4 
стандарта. 
<P>Поддержка освещенности и раскраски основана на предоставлении средств задания 
позиции источника света и наличии примитивов "с данными", задающими вектора 
нормалей и цвета вершин. 
<P>Предоставлена возможность задания в структуре "ограничивающего бокса". Когда 
он обрабатывается, то устанавливаются флаги отсечения (если ограничивающий бокс 
полностью вне области вывода) и отбраковки (если ограничивающий бокс меньше 
заданного размера). Этот дополнительный элемент структуры предназначен для 
управления пропуском исполнения структуры, образ котрой находится вне области 
вывода, и позволяет повысить скорость отображения. 
<P>
<CENTER>
<H3><A name=tth_sEc0.3.10>0.3.10</A>&nbsp;&nbsp;CGI (Computer Graphics 
Interface)</H3></CENTER>
<P>Это стандарт ISO [<A href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#mbib66" 
name=CITEmbib66>66</A>] на интерфейс между аппаратно-независимой частью 
графического программного обеспечения (базисной графической системой) и 
аппаратно-зависимой (драйверами). Этот интерфейс ранее (в рамках ANSI) назывался 
интерфейсом виртуального устройства. 
<P>Для эффективного использования аппаратных возможностей современных 
графических устройств набор функций CGI перекрывает аппаратно-реализуемые 
возможности и включает в себя следующие функции:<BR><FONT 
face=symbol>·</FONT>&nbsp;управление устройством,<BR><FONT 
face=symbol>·</FONT>&nbsp;вывод графических примитивов,<BR><FONT 
face=symbol>·</FONT>&nbsp;изменение графических атрибутов,<BR><FONT 
face=symbol>·</FONT>&nbsp;сегментация изображений,<BR><FONT 
face=symbol>·</FONT>&nbsp;графический ввод,<BR><FONT 
face=symbol>·</FONT>&nbsp;растровые операции. 
<P>Отличительными особенностями CGI (по сравнению со стандартами на интерфейс 
базисной графической системы) являются следующие: расширенный набор графических 
примитивов, одноступенчатое преобразование координат, увеличенное количество 
логических устройств ввода, наличие растровых операций. В целом набор функций 
CGI достаточно удобен для создания надстроенного над ним графического 
программного обеспечения. Последнее позволяет эффективно создавать на основе CGI 
различные базисные графические системы. 
<P>Следует отметить, что стандарт на интерфейс виртуального устройства 
ориентирован в первую очередь на унификацию способа взаимодействия с различными 
графическими устройствами и предназначен для системных, но не прикладных 
программистов. Он был утвержден после появления множества проектов по 
стандартизации программных интерфейсов базисной графической системы. 
<P>
<CENTER>
<H3><A name=tth_sEc0.3.11>0.3.11</A>&nbsp;&nbsp;Графические 
протоколы</H3></CENTER>
<P>Анализ применяемых в настоящее время графических протоколов и проектов по их 
стандартизации позволяет выделить протоколы следующих типов: 
<P><FONT face=symbol>·</FONT> аппаратно-зависимые графические протоколы или 
команды графических устройств,<BR>
<P><FONT face=symbol>·</FONT> аппаратно-независимые графические протоколы или 
метафайлы, 
<P><FONT face=symbol>·</FONT> прикладные графические протоколы, 
<P><FONT face=symbol>·</FONT> растровые графические файлы. 
<P>
<CENTER>
<H4><A name=tth_sEc0.3.11.1>Аппаратно-зависимые графические 
протоколы</A></H4></CENTER>
<P>Аппаратно-зависимые графические протоколы разрабатываются фирмами, 
производящими графическое оборудование. Они представляют собой 
последовательность команд для построения изображений на устройствах выпускаемых 
данной фирмой. Для интерпретации таких протоколов не требуется дополнительных 
ресурсов если используется соответствующее устройство. Поэтому, такие протоколы 
могут успешно применяться в распределенных системах при отсутствии локальной 
ЭВМ. 
<P>Вопрос о поддержке тех или иных аппаратно-зависимых графических протоколов 
определяется составом используемого оборудования. Целесообразно, чтобы 
центральная ЭВМ обеспечивала возможность генерации команд для наиболее 
распространенных графических устройств. В настоящее время значительная часть 
производящейся в мире графической аппаратуры работает с протоколами TEKTRONIX, 
REGIS и HPGL. Поддержка этих протоколов обеспечивается также в наиболее 
распространенных зарубежных программных продуктах.<BR>
<P>
<CENTER>
<H4>Протокол TEKTRONIX</H4></CENTER>
<P>Разработан одноименной фирмой, выпускающей графические дисплеи. Ввиду широкой 
распространенности устройств этой фирмы другие разработчики графической 
аппаратуры часто обеспечивают режим совместимости с TEKTRONIX'ом в своих 
устройствах. Поддержка этого протокола производится также в некоторых эмуляторах 
терминала (например, VTERM, ST240, TEEMTALK) работающих на персональных 
компьютерах типа IBM PC. 
<P>Существуют две разновидности протокола TEKTRONIX, соответствующие дисплеям 
серии 4010/12/14 и дисплеям серий 41ХХ, 42ХХ, 43ХХ. Дисплеи 4010/12/14 это 
дисплеи на запоминающей трубке с минимальным набором графических команд. Дисплеи 
серии 41ХХ и выше это цветные растровые дисплеи, работающие с более развитым 
графическим протоколом, который предусматривает следующие основные группы 
графических команд:<BR><FONT face=symbol>·</FONT>&nbsp;команды построения 
векторных примитивов,<BR><FONT face=symbol>·</FONT>&nbsp;команды работы с 
растровыми изображениями,<BR><FONT face=symbol>·</FONT>&nbsp;команды управления 
сегментацией изображения,<BR><FONT face=symbol>·</FONT>&nbsp;команды задания 
цветовых и геометрических атрибутов,<BR><FONT face=symbol>·</FONT>&nbsp;команды 
графического ввода,<BR><FONT face=symbol>·</FONT>&nbsp;команды управления 
плоскостями вывода,<BR><FONT face=symbol>·</FONT>&nbsp;команды выполнения 
видовых преобразований,<BR><FONT face=symbol>·</FONT>&nbsp;команды определения 
символов (графических образов). 
<P>Кроме перечисленных графических функций протоколы серии TEKTRONIX 41XX и 
старше включают множество функций управления алфавитно-цифровым режимом, каналом 
передачи данных и дополнительными внешними устройствами (hardcopy, планшет, 
диск). 
<P>Для представления команд используется символьное кодирование с использованием 
служебных символов в имени команды (чаще всего - символа Esc), что затрудняет 
чтение операторов человеком. 
<P>
<CENTER>
<H4>Протокол REGIS</H4></CENTER>
<P>Разработан для дисплеев серии VT (240 и выше). С этим протоколом работают 
также персональные компьютеры фирмы LabTam и ряд графопостроителей различных 
фирм. Поддержка протокола REGIS обеспечивается в некоторых эмуляторах терминала 
на IBM PC (VTERM, ST240). По функциональным возможностям протокол REGIS заметно 
уступает протоколу TEKTRONIXа. В частности, в нем гораздо беднее набор растровых 
операций, задания атрибутов построений, средств графического ввода и управления 
плоскостями вывода, полностью отсутствуют возможности сегментации изображения, 
выполнения видовых преобразований, определения символов. 
<P>
<CENTER>
<H4>Протокол HP-GL</H4></CENTER>
<P>Графический протокол HP-GL (язык описания данных Graphic Language) разработан 
фирмой Hewlett Packard в 1976&nbsp;г. и поддерживается множеством других фирм, 
выпускающих графопостроители. В настоящее время используется версия HP-GL/2. 
Операторы языка содержат символьное имя команды и несколько параметров, также 
подготовленных в печатном текстовом виде. Всего в языке 88 операторов, разбитых 
на 9 функциональных групп. Ядро языка содержит 5 групп из 55 операторов, которые 
должны поддерживаться на всех устройствах. Оставшиеся 3 группы из 33 операторов 
являются специфичными для некоторых из устройств. В целом, благодаря 
использованию явного текстового представления, язык легко читается и 
интерпретируется. 
<P>
<CENTER>
<H4><A name=tth_sEc0.3.11.2>Языки описания страниц</A></H4></CENTER>
<P>Любая страница может быть описана как просто пиксельный массив, но это 
практически неприемлемо. Язык описания страниц должен описывать любой текст и 
графику на высоком уровне в терминах абстрактных графических элементов. 
<P>Выполнение вывода с использованием языка описания страниц идет в две стадии: 
<P>1.&nbsp;Приложение генерирует аппаратно-независимое описание на языке 
описания страниц. 
<P>2.&nbsp;Программа, управляющая некоторым растровым устройством вывода, 
интерпретирует описание и отображение его на устройство. 
<P>Эти две стадии могут быть выполнены в разное время и в разных местах. 
<P>Примитивы вывода выдаются на растровое устройство вывода процессом, 
называемым преобразованием сканирования (растеризация). 
<P>
<CENTER>
<H4>Язык PostScript</H4></CENTER>
<P>Особое место среди графических языков высокого уровня занимает 
интерпретируемый язык описания страниц PostScript [<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#mbib109" 
name=CITEmbib109>109</A>,], разработанный фирмой Adobe и используемый не только 
для описания и построения изображений, но и качестве высокоуровневого 
аппаратно-независимого протокола обмена между компонующей и отображающей 
системами. 
<P>В первую очередь PostScript - это общий язык программирования с встроенными 
мощными графическими примитивами. С другой стороны, это язык описания страниц, 
который включает возможности языка программирования, и используется для связи с 
электронными печатающими устройствами. 
<P>На PostScript'е можно описывать любые графические формы, двухуровневые 
изображения и печатаемые формы. Для построения изображений (в том числе и 
всевозможных шрифтов) в языке PostScript предоставляется возможность управления 
каждой точкой печатающего устройства. 
<P>Естественно, что вследствие наглядности PostScript, как и другие языки 
программирования неоптимален в смысле минимальности кодирования информации. 
Поэтому его использование в качестве графического протокола представляется 
нецелесообразным. Однако он становится незаменим при передаче тексто-графических 
документов, предназначенных для воспроизведения на печатающих устройствах с 
высоким разрешением (например, лазерных принтерах). 
<P>Аппаратная независимость достигается тем, что построение изображения ведется 
в пользовательской системе координат с помощью обычных графических примитивов и 
описание изображения не содержит никакой информации об устройстве отображения. 
<P>В языке предусмотрен ряд типов данных - числа, строки, одномерные массивы, 
словари (таблицы, задающие соответствие между ключом и значением). Элементы 
массивов могут быть различных типов. Примитивы управления включают в себя 
условия, циклы и процедуры, которые могут вызываться рекурсивно. 
<P>Операторы (арифметические, логические, графические и управления) записываются 
в постфиксной записи и манипулируют со стеком типа LIFO. 
<P>В язык встроены следующие изобразительные возможности: 
<P><FONT face=symbol>·</FONT> изображения строятся из отрезков линий, дуг и 
кубических кривых; 
<P><FONT face=symbol>·</FONT> примитивы могут быть выведены линиями требуемого 
вида, закрашены любым цветом или использоваться для задания области отсечения 
для других графических элементов;<BR>
<P><FONT face=symbol>·</FONT> текст полностью интегрирован с графикой, символы 
как стандартных шрифтов, так и определенных пользователем, рассматриваются как 
графические образы, которые обрабатываются графическими операторами языка;<BR>
<P><FONT face=symbol>·</FONT> 2D общая координатная система поддерживает обычные 
линейные преобразования и их комбинации (сдвиг, поворот, масштабирование, 
отражение и т.д.);<BR>
<P><FONT face=symbol>·</FONT> как построенные графическими операторами, так и 
естественные изображения, введенные, например, со сканера, могут иметь требуемые 
разрешение и динамический диапазон.<BR>
<P>PostScript стал стандартом "де-факто" и получил чрезвычайно широкое 
распространение как язык описания страниц для лазерных принтеров и других 
устройств с высоким разрешением, его интерпретаторы входят в состав контроллеров 
растровых принтеров многих типов. 
<P>Языки описания страниц, близкие по возможностям к PostScript, разработаны 
также фирмами Xerox (язык Interpress) и Imagen (язык DDL). 
<P>На основе расширения языка PostScript фирмой Sun Microsystems разработана 
система NEWS [<A href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#mbib105" 
name=CITEmbib105>105</A>] (the Network extensible Window System) для управления 
окнами в сети. 
<P>
<CENTER>
<H4>Язык PCL</H4></CENTER>
<P>Несколько версий языка описания страниц Printer Communication Language (PCL) 
было разработано фирмой Hewlett-Packard для вывода на лазерный принтер рисунков 
и текстов с использованием различных шрифтов. В версии PCL5 имеется 64 
оператора, разбитых на 10 функциональных групп. Все операторы начинаются с 
символа Esc (шестнадцатиричный код 01BH) и содержат один или несколько 
последующих символов. Символьное кодирование, используемое в PCL, менее 
приспособлено для чтения человеком, чем явное текстовое кодирование, 
используемое в языке PostScript, но значительно компактнее последнего. 
<P>
<CENTER>
<H4><A name=tth_sEc0.3.11.3>Аппаратно-независимые графические 
протоколы</A></H4></CENTER>
<P>Аппаратно-независимый графический протокол или метафайл представляют собой 
процедурное описание изображения в функциях виртуального графического 
устройства. Он обеспечивает возможность запоминать графическую информацию единым 
образом, передавать ее между различными графическими системами (в том числе 
работающими на различных ЭВМ) и интерпретировать информацию для вывода на 
различные графические устройства. Для интерпретации метафайла требуется 
локальная ЭВМ, выполняющая эмуляцию не реализованных в аппаратуре функций и 
кодирование в команды конкретных устройств. 
<P>В настоящее время в мировой практике наиболее активно поддерживаются 
стандартизованные аппаратно-независимые протоколы NAPLPS, GKSM, CGM и WMF - 
стандарт де-факто фирмы Microsoft на метафайл.<BR>
<P>
<CENTER>
<H4>NAPLPS - North American Presentation Level Protocol Syntax</H4></CENTER>
<P>Это американский стандарт на представление графических данных в сетях 
VIDEOTEX (имеется также европейский аналог этого стандарта - SET). Основными 
требованиями при разработке этого протокола были следующие: 
<P><FONT face=symbol>·</FONT> возможность передачи графической информации в 
потоке буквенно-цифровых данных,<BR>
<P><FONT face=symbol>·</FONT> минимальность объема передаваемых графических 
данных, 
<P><FONT face=symbol>·</FONT> минимальность усилий для интерпретации и 
возможность вывода изображений на простейшие графические устройства.<BR>
<P>Обеспечение этих требований привело к тому, что был разработан эффективный 
способ упаковки графической информации в 7-ми или 8-битные коды ASCII. Эти же 
требования привели к ограничению функциональных возможностей протокола, что не 
позволяет получить высокое качество изображений при использовании современных 
графических устройств. 
<P>
<CENTER>
<H4>GKSM - Graphical Kernel System Metafile</H4></CENTER>
<P>Это de-facto стандарт на графический метафайл в рамках базисной графической 
системы GKS (приложение Е к стандарту GKS). По функциональным возможностям этот 
протокол полностью соответствует системе GKS со всеми ее достоинствами и 
недостатками. Поэтому, он легко интерпретируется в системах, соответствующих 
стандарту GKS. 
<P>Недостатком GKSM-протокола (равно как и системы GKS) является, например, 
минимальный набор стандартизованных графических примитивов (их всего 5), что не 
дает возможности эффективного использования современных интеллектуальных 
графических устройств и увеличивает объем передаваемой информации. Возможность 
же использования обобщенного графического примитива или ESCAPE-механизма 
(предназначенных для нестандартных функций) не обеспечивает однозначность 
интерпретации графических данных при передаче их между различными системами. 
<P>Кодирование в GKSM текстовое, что позволяет читать (просматривать, 
редактировать) метафайл но требует большего объема чем символьное кодирование 
применяемое в NAPLPS или CGM. 
<P>
<CENTER>
<H4>CGM - Computer Graphics Metafile</H4></CENTER>
<P>Это стандарт ISO [<A href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#mbib88" 
name=CITEmbib88>88</A>] на графический метафайл. Функционально этот протокол 
соответствует стандарту на интерфейс виртуального устройства CGI (Computer 
Graphics Interface), предназначенного для обеспечения связи различных 
графических систем с различным графическим оборудованием и являющегося 
обобщением текущего уровня развития графического программного и аппаратного 
обеспечения. По этой причине протокол CGM может совмещаться с различными 
программными системами и позволяет наиболее эффективно использовать возможности 
имеющихся графических устройств. 
<P>В CGM предусмотрены три способа кодирования - символьное, двоичное и 
текстовое. Символьное кодирование (по идеологии близкое к принятому в NAPLPS) 
достаточно компактно и предназначено для хранения и транспортировки графической 
информации. Двоичное кодирование требует минимальных усилий по генерации и 
интерпретации и предназначено для внутрисистемного использования. Текстовое 
кодирование наиболее наглядно и обеспечивает возможность визуального просмотра и 
редактирования графических файлов. При необходимости в рамках графической 
системы могут быть предусмотрены соответствующие перекодировщики. 
<P>
<CENTER>
<H4>DXF</H4></CENTER>
<P>Это формат графических файлов с которыми работает система AutoCad. Его 
следовало бы отнести к категории аппаратно-зависимых протоколов, но (в настоящее 
время) нет ни одного устройства понимающего этот формат. Использование этого 
формата целесообразно в том случае, когда есть необходимость использования 
графических возможностей системы Autocad. 
<P>
<CENTER>
<H4>WMF - Windows Metafile Format</H4></CENTER>
<P>В системе Windows фирмы Microsoft для сохранения и последующего использования 
цветных изображений используется свой формат метафайла. В WMF используется 
единственный способ кодирования - двоичный, который, как это отмечалось выше, 
наиболее компактен и обеспечивает наибольшие скорости упаковки и 
воспроизведения, но неудобен для просмотра и анализа человеком. Метафайл 
содержит заголовок и собственно описание изображения в виде записей GDI 
(Graphical Device Interface) функций. Всего предусмотрено три варианта метафайла 
- стандартный, размещаемый (placeable) и буферный (clipboard). Отличия вариантов 
состоят только в разных структурах заголовков. В составе Windows предусмотрены 
функции для создания и проигрывания метафайлов и манипулирования ими.<BR>
<P>
<CENTER>*&nbsp;*&nbsp;* </CENTER>
<P>Перечисленные аппаратно-независимые графические протоколы ограничиваются 
2-мерными графическими примитивами, что не позволяет использовать ресурсы 
локальной ЭВМ для сокращения объема передаваемой информации при работе с 3D 
изображениями. Поэтому, представляется целесообразной разработка двухуровневого 
графического протокола согласованного с CGM и обеспечивающего возможность 
передачи 3D объектов. Сокращение нагрузки на линию связи будет происходить в 
данном случае не только за счет повышения семантической насыщенности 
передаваемой информации, но и за счет возможности получения на локальной ЭВМ 
множества изображений с различными параметрами визуализации (например, множество 
изображений пространственного объекта с различных точек зрения). 
<P>
<CENTER>
<H4><A name=tth_sEc0.3.11.4>Проблемно-ориентированные 
протоколы</A></H4></CENTER>
<P>Прикладные графические протоколы это объектно - ориентированные протоколы 
передачи данных между прикладными системами. Они наиболее компактны (вследствие 
высокой семантической насыщенности), допускают свободу в выборе различных 
способов графического представления, но требуют большей мощности локальной ЭВМ 
для интерпретации. Прикладные протоколы стандартизованы пока только для САПР 
машиностроения и электроники. В качестве примеров можно привести следующие 
стандарты:<BR><FONT face=symbol>·</FONT>&nbsp;IGES (Initial Graphics Exchange 
Specification),<BR><FONT face=symbol>·</FONT>&nbsp;STEP (STandard for the 
Exchange Product Model Data),<BR><FONT face=symbol>·</FONT>&nbsp;MAP 
(Manufacturing Automation Protocol),<BR><FONT face=symbol>·</FONT>&nbsp;VDAFS 
(Sculptured Surface Interface),<BR><FONT face=symbol>·</FONT>&nbsp;EDIF 
(Electronic Design Interchange Format). 
<P>Основные трудности, связанные с разработкой протоколов этого уровня, состоят 
в том, что во многих областях применения до сих пор не унифицированы основные 
объекты (в том числе графические) и операции над ними. Для работы в этом 
направлении потребуются объединенные усилия проблемных специалистов, математиков 
и системных программистов в области баз данных, машинной графики, 
телекоммуникаций и т.д. 
<P>
<CENTER>
<H4><A name=tth_sEc0.3.11.5>Растровые графические файлы</A></H4></CENTER>
<P>С появлением и широким распространением персональных ЭВМ, использующих 
растровые дисплеи и устройства документирования (лазерные и струйные принтеры и 
т.д.), для целей компактного хранения и транспортировки графической информации 
стали активно применяться различного рода растровые графические файлы. 
Используется более десятка различных типов растровых графических файлов. К 
наиболее известным относятся:<BR><FONT face=symbol>·</FONT>&nbsp;TIFF (Tag Image 
File Format),<BR><FONT face=symbol>·</FONT>&nbsp;GIF (Graphics Interchange 
Format),<BR><FONT face=symbol>·</FONT>&nbsp;PIC,<BR><FONT 
face=symbol>·</FONT>&nbsp;PCX,<BR><FONT face=symbol>·</FONT>&nbsp;MAC 
(MacPaint),<BR><FONT face=symbol>·</FONT>&nbsp;BMP (Bitmap).<BR>
<P>
<CENTER>
<H4>TIFF (Tag Image File Format)</H4></CENTER>
<P>Разработан корпорациями Aldus и Microsoft совместно с некоторыми фирмами, 
производящими сканеры и принтеры. Этот формат поддерживается целым рядом систем 
подготовки документации и является наиболее реальным претендентом на стандарт 
для хранения и транспортировки растровых изображений. 
<P>Основной концепцией формата TIFF является цветовая модель изображения. Под 
этим понимается набор характеристик изображения, определяющих способ 
представления цвета. Стандартизованы следующие цветовые модели:<BR><FONT 
face=symbol>·</FONT>&nbsp;двух-уровневое изображение (bi-level image);<BR><FONT 
face=symbol>·</FONT>&nbsp;монохромное изображение (gray-scale image);<BR><FONT 
face=symbol>·</FONT>&nbsp;индексированное цветное изображение (paletted color 
image);<BR><FONT face=symbol>·</FONT>&nbsp;полное цветное изображение (full RGB 
image). 
<P>TIFF является открытым форматом и позволяет создать любую модель изображения. 
Естественно, что выбор требуемой модели определяется решаемой задачей. Например, 
двух-уровневая модель наиболее удобна в системах подготовки документации. 
Индексированное цветное изображение совместимо с форматом хранения графической 
информации в наиболее распространенных в настоящее время растровых графических 
дисплеях. 
<P>Помимо информации о модели изображения формат TIFF содержит метрические 
характеристики, а именно: размеры изображения, плотность (количество пикселов на 
единицу длины), с которой создавалось изображение. Эти характеристики особенно 
полезны в системах подготовки документации. TIFF не накладывает практически 
никаких ограничений на параметры изображения. Так, например размеры изображения 
могут достигать 4 миллиардов. Количество битов на пиксел ограничено этим же 
числом. 
<P>Формат TIFF позволяет хранить в одном файле любое количество изображений. 
Кроме того, есть возможность хранить несколько копий одного изображения с 
различными характеристиками. Так, например, можно иметь несколько вариантов 
изображения, отличающихся различной плотностью, что полезно опять же в 
издательских системах для работы с несколькими принтерами. 
<P>В формате TIFF имеется возможность упаковывать изображение различными 
методами. В том числе изображение может храниться и в неупакованном виде, что 
представляется удобным, так как, например, при создании изображения важен 
произвольный доступ к любому элементу изображения за достаточно малое время. 
Одним из методов кодирования является LZW (Lempel, Ziv &amp; Welch), который 
дает высокий коэффициент сжатия. 
<P>
<CENTER>
<H4>GIF (Graphics Interchange Format)</H4></CENTER>
<P>Разработан в CompuServe Incorporation для хранения и транспортировки 
растровых изображений. GIF позволяет содержать в одном файле несколько 
изображений, не связанных между собой. 
<P>По сравнению с форматом TIFF он более прост. В GIF используется наиболее 
распространенная модель изображения - индексированное цветное изображение. Хотя 
это не мешает хранить в нем изображения двух-уровневой и монохромной моделей. 
Это реализуется путем соответствующей настройки таблицы цветности. Модель 
полноцветного изображения с хранением для каждого пиксела компонент R, G и B 
принципиально не вписывается в формат GIF, так как существует ограничение на 
количество битов в пикселе - 8. 
<P>Достоинством формата GIF является наличие стандартизованного протокола 
передачи GIF-изображения по линии связи. Формат GIF, в отличие от TIFF, 
организован по принципу последовательного доступа. Т.е. он не содержит 
оглавлений или каких-либо ссылок внутри себя. Это делает его удобным при 
передаче изображений в распределенной графической системе. 
<P>GIF использует единственный метод кодирования изображений - LZW. Это свойство 
следует отнести к недостаткам формата, так как использование одного метода 
кодирования ограничивает область его применения. Кроме того, следует отметить, 
что не существует графических редакторов, понимающих формат GIF. 
<P>
<CENTER>
<H4>ZSoft (PCX)</H4></CENTER>
<P>Формат распространен на IBM PC и используется в графических редакторах 
(Paintbrush, EgaPaint) и системах подготовки документации (Ventura Deck Top 
Publisher, First Publisher). 
<P>В PCX используется очень неэффективный метод кодирования, он дает низкий 
коэффициент сжатия. Однако время, используемое на кодирование/декодирование 
практически равно времени кодирования без всякой упаковки. Это дает преимущества 
при использовании этого формата в интерактивных системах с быстрой сменой 
изображений. 
<P>
<CENTER>
<H4>MacPaint (MAC)</H4></CENTER>
<P>Является основным форматом в системах подготовки документации и графических 
редакторах на персональных компьютерах фирмы Apple (Macintosh, Lisa). 
<P>
<CENTER>
<H4>BitMap (BMP)</H4></CENTER>
<P>Является одним из основных форматов представления растровых изображений в 
системе Windows. Файл имеет достаточно простую структуру и сохраняет 
единственное изображение с одним, четырьмя, восемью и двадцатью четырьмя битами 
на пиксел. Одно-, четырех- и восьмибитное представления соответствуют 
индексированному цветному изображению. Для таких изображений в заголовке 
BMP-файла хранится таблица цветности. Изображение может быть сжато с 
использованием кодированием длин серий для четырех- и восьмибитных изображений. 
<P>Наряду с перечисленными имеется еще ряд форматов для хранения растровых 
файлов, используемых в отдельных системах, но не получивших широкого 
распространения. Их применение может оказаться целесообразным в случае 
использования соответствующих систем. 
<P>
<CENTER>
<H3><A name=tth_sEc0.3.12>0.3.12</A>&nbsp;&nbsp;X Window System</H3></CENTER>
<P>В отличие от большинства других предложений по стандартизации, таких как, 
например, GKS, система Х спроектирована и реализована небольшой группой 
разработчиков из Массачусетского технологического института в рамках проекта 
Athena, спонсорами которого были фирмы DEC и IBM. 
<P>Система Х - программное окружение для программистов и пользователей 
прикладного программного обеспечения инженерных рабочих станций и представляет 
собой целостную систему, в рамках которой синтезированы предложения по 
управлению окнами, функциональному и языковому интерфейсам, 
аппаратно-независимому протоколу и программному обеспечению рабочей станции. 
<P>Основой Х является "базовая оконная система". Полное Х-окружение надстроено 
над ней в виде уровней (рис.&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#r3_7">0.3.24</A>). 
<P>
<P><A name=tth_fIg0.24></A><A name=r3_7>
<CENTER><BR><IMG alt="Рисунок 24" 
src="Учебное пособие Архитектуры графических систем_files/kg0324.gif">
<P></CENTER>
<CENTER>Рис. 0.3.24: Структура X</CENTER></A>
<P>
<P>Базовая оконная система взаимодействует с окружающим миром только через 
сетевой интерфейс. Какого-либо специального привилегированного доступа к ней не 
предусмотрено. 
<P>Архитектура Х-системы базируется на модели клиент-сервер (рис.&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#r3_8">0.3.25</A>). Клиент - 
прикладная программа. Сервер - программа, вызванная на компьютере, к которому 
физически подключен дисплей. В ней сосредоточена вся аппаратная зависимость. 
<P>
<P><A name=tth_fIg0.25></A><A name=r3_8>
<CENTER><BR><IMG alt="Рисунок 25" 
src="Учебное пособие Архитектуры графических систем_files/kg0325.gif">
<P></CENTER>
<CENTER>Рис. 0.3.25: Архитектура Х-системы</CENTER></A>
<P>
<P>Основные критерии, которыми руководствовались в разработке Х-системы: 
<P><FONT face=symbol>·</FONT> транспортабельность - система должна быть 
применима к различным дисплеям;<BR>
<P><FONT face=symbol>·</FONT> аппаратная независимость приложений; 
<P><FONT face=symbol>·</FONT> сетевая прозрачность - приложения могут быть 
вызваны как локально, так и на удаленных ЭВМ без каких-либо их изменений и без 
необходимости информирования об отличиях. Должны быть поддержаны различные 
сетевые протоколы;<BR>
<P><FONT face=symbol>·</FONT> конкурирующие приложения - дисплей может делиться 
между несколькими приложениями. Возможен вывод из нескольких приложений как в 
единственное, так и в несколько окон;<BR>
<P><FONT face=symbol>·</FONT> интерфейсы с приложениями и управление окнами - Х 
не предписывает какого либо одного способа работы с окнами, например, только 
перекрывающимися;<BR>
<P><FONT face=symbol>·</FONT> перекрытия окон - ввод/вывод должны быть возможны 
для полностью или частично затененных окон. 
<P><BR>&nbsp;
<P>
<CENTER>*&nbsp;*&nbsp;* </CENTER>
<P>Одно из основных отличительных свойств Х-системы - работа одного сервера с 
несколькими клиентами и наоборот одного клиента с несколькими серверами 
представляется весьма удобным и естественным. Подобный подход использовался, 
например, в системах ДИГРАФ.К и ДИГРАФ.Р [<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#mbib13" name=CITEmbib13>13</A>]. 
<P>Другое же основополагающее положение, что за перечерчивание окон, получивших 
экспозицию на экране, несет ответственность прикладная программа, приводит к 
необходимости иметь высокоскоростные каналы связи (например, Ethernet). Другими 
словами, за сравнительно малые результаты приходится платить несуразно высокую 
цену. Представляется целесообразным иметь управление окнами на терминальной ЭВМ, 
возможно и с какими-либо прагматическими ограничениями на возможности такой 
локальной системы управления окнами. 
<P>
<CENTER>
<H3><A name=tth_sEc0.3.13>0.3.13</A>&nbsp;&nbsp;Выводы</H3></CENTER>
<P>В машинной графике широко распространилось понимание необходимости 
стандартизации, которая позволяет обеспечить переносимость пакетов прикладных 
программ, унифицировать графические методы работы, углубить их понимание и 
практического использования, ставить задачи перед разработчиками аппаратуры. 
<P>В настоящее время работы по стандартизации, в основном, сосредоточены на 
узком фронте специфицирования некоторого минимального набора "базисных" функций 
с одновременным стремлением к многофункциональности пакетов графических 
подпрограмм. Следует ожидать, что дальнейшее продвижение стандартизации будет 
идти по пути повышения ее функционального уровня в определенных, 
сформировавшихся областях приложений. 
<P>В целом, текущее состояние работ по стандартизации машинной графики - 
необходимый, но пока первый шаг в этой части создающейся на наших глазах 
индустрии программного обеспечения [<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#mbib21" name=CITEmbib21>21</A>]. 
<P>Наряду с положительными аспектами стандартизации следует отметить и 
определенные минусы, имеющие общий характер. 
<P>1.&nbsp;Стандартизация всегда означает затверждение некоторого определенного 
уровня достижений и понимания, тем самым в определенной степени тормозится 
развитие новых, нестандартных технических средств и программного обеспечения. 
Особенно, если учесть то, что первой строчкой наших стандартов является: 
"несоблюдение стандарта преследуется по закону". 
<P>2.&nbsp;Стремление покрыть широкий спектр применений, начиная от пассивного 
вывода до высокоинтерактивных приложений, несмотря на наличие уровней, все-таки 
приводит к громоздкости и набора средств, и структуры данных и, естественно, 
программного кода. 
<P>3.&nbsp;Стремление к легкой адаптируемости влечет за собой чрезвычайно 
большое количество средств запроса к обстановке (в GKS - 75 функций из общего 
числа 185, т.е. более 40%). Такое количество несомненно избыточно для многих 
конкретных приложений. Не случайно поэтому, например, еще в 1987 г. темой одной 
из дискуссий на Всесоюзной школе-семинаре по "Информатике и интерактивной 
компьютерной графике" (Цахкадзор, 16-20 марта 1987 г.) было: "Стандартизация - 
закон или методология, тормоз или ускорение". 
<P>Важно отметить, что в предложениях по стандартизации наряду со стремлением к 
многофункциональности пакетов очевидно и стремление к минимизации набора 
стандартизованных примитивных функций, что, вообще говоря, неверно для 
конкретной области приложений. В последнем случае повышение функционального 
уровня стандартизации обеспечит как легкость изучения, так и легкость адаптации, 
которая важна ведь не вообще, а в каждом случае в некотором конкретном классе 
приложений. Практика написания прикладных систем показывает, что для повышения 
эффективности прикладных программ требуется набор различных функциональных 
возможностей из различных, предлагаемых стандартами уровней. 
<P>В этой связи, интересным представляется решение, предложенное в [<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#mbib32" name=CITEmbib32>32</A>], 
положенное в основу графпакета АТОМ. Система машинной графики представляется в 
виде совокупности пяти сравнительно слабо связанных подмножеств: средств 
формирования изображений; средств промежуточного хранения информации; средств 
ввода; средств преобразований изображений; средств управления графическими 
устройствами. 
<P>Требуемая конфигурация графической системы собирается из отдельных модулей, 
объединяемых в конвейер [<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#mbib34" name=CITEmbib34>34</A>]. 
Конвейер собирается либо статически - на этапе проектирования программы, либо 
динамически, в процессе ее исполнения. Передача данных в конвейере 
осуществляется через единый межмодульный интерфейс. 
<P></I></B></TT><U>3.&nbsp;СИСТЕМЫ УПРАВЛЕНИЯ ПОЛЬЗОВАТЕЛЬСКИМ ИНТЕРФЕЙСОМ 
(UIMS)</U> 
<CENTER>
<H3><A name=tth_sEc0.4>0.4</A>&nbsp;&nbsp;СИСТЕМЫ УПРАВЛЕНИЯ ПОЛЬЗОВАТЕЛЬСКИМ 
ИНТЕРФЕЙСОМ (UIMS)</H3></CENTER>
<P>Начало интерактивных вычислений и, следовательно, исследование 
человеко-машинного интерфейса принято отсчитывать с 1959&nbsp;г., когда на 
конференции Юнеско по обработке информации Г.Стречи предложил режим разделения 
времени при решении задач на компьютерах. 
<P>По мере роста мощности компьютеров росли и затраты на диалоговую компоненту 
программного обеспечения. Вопрос эффективности использования машин обострился во 
время стремительного выхода на рынок рабочих станций, объединивших 
интерактивность с графикой. Термин эффективность с тех пор изменил свое значение 
- если раньше он отражал такие характеристики как процессорное время и объем 
занимаемой памяти, то теперь под ним понимают простоту разработки, легкость 
сопровождения и удобство работы с программой. Поэтому затраты на исследование и 
разработку пользовательского интерфейса являются оправданными. В настоящее время 
большие усилия прикладываются к разработке методов и созданию инструментальных 
средств в рамках систем, получивших название UIMS - User Interface Management 
System. 
<P>Основные концепции UIMS были выработаны на ряде семинаров: 
<P><FONT face=symbol>·</FONT> 1983 Workshop on "User Interface Management 
Systems", Seeheim, FRG;<BR>
<P><FONT face=symbol>·</FONT> 1986 ACM SIGGRAPH Workshoop on "Software Tools for 
User Interface Management Systems", Seattle, USA;<BR>
<P><FONT face=symbol>·</FONT> 1987 Glasgow University Workshop on "User 
Interface Management Systems";<BR>
<P><FONT face=symbol>·</FONT> 1990 ESPRIT/Eurographics International Workshop on 
"User Interface Management Systems and Environments", Lisbon.<BR>
<P>Традиционный графический подход к интерфейсу с пользователем связан с 
работами Сазерленда, Ньюмена и др. [<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#mbib120" 
name=CITEmbib120>120</A>,], в котором взаимодействие базируется на использовании 
графического дисплея с регенерацией и светового пера. Дальнейшее развитие 
графического диалога связано с прогрессом в области систем интерактивной 
машинной графики, который привел к регламентации в виде международных 
стандартов. 
<P>GKS - первый международный графический стандарт. В нем впервые зафиксированы 
концепции "рабочих станций" и логических устройств ввода (ЛОКАТОР, ШТРИХ, 
ДАТЧИК, ВЫБОР, УКАЗКА и КЛАВИАТУРА). К сожалению GKS был задуман во время 
превосходства парадигмы векторного рисования. Отсюда слабость поддержки диалога: 
отсутствие возможности ввода новых устройств или видоизменения изображения 
устройства на экране даже из прикладной программы (пользователя графического 
пакета), что приводит к необходимости использования в основном символьного ввода 
при организации диалога. Реализация диалога в GKS прерогатива прикладной 
программы, возможности раздельного проектирования не предполагается. 
<P>Второе направление графики - растровая графика оказала чрезвычайно большое 
влияние на все последующее развитие интерактивных систем. Все основные черты 
интерфейса с пользователем на современных рабочих станциях суть производные от 
работ по Xerox Park: 
<P><FONT face=symbol>·</FONT> управление окнами; 
<P><FONT face=symbol>·</FONT> использование графических символов ("икон") для 
представления объектов;<BR>
<P><FONT face=symbol>·</FONT> стиль взаимодействия, называемый непосредственным 
манипулированием; 
<P><FONT face=symbol>·</FONT> популярность "мыши" как устройства 
позиционирования на экране; 
<P><FONT face=symbol>·</FONT> объектно-ориентированный стиль 
программирования.<BR>
<P>С тех пор система классификации инструментария для создания и управления 
пользовательским интерфейсом рассматривается на трех уровнях: 
<P><FONT face=symbol>·</FONT> Системы управления окнами (WMS-Window Manager 
System); 
<P><FONT face=symbol>·</FONT> Специализированный 
инструментарий;<BR>&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;обычный (MacIntosh, SunView 
<FONT 
face=symbol>ј</FONT>),<BR>&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;объектно-ориентированный 
(Smalltalk-80, Andrew, InterView).<BR>
<P><FONT face=symbol>·</FONT> Системы управления пользовательским 
интерфейсом.<BR>
<P>В следующих разделах будут даны краткие характеристики, статус и 
функциональное описание каждого из этих уровней. 
<P>
<CENTER>
<H3><A name=tth_sEc0.4.1>0.4.1</A>&nbsp;&nbsp;Системы управления окнами 
(WMS)</H3></CENTER>
<P>Многооконная технология обеспечивает пользователя доступом к большему объему 
информации, чем это возможно при работе с одним экраном. Окна дают доступ ко 
множеству источников информации. Пользователь может объединять информацию от 
нескольких источников, исследовать информацию на разных уровнях детализации. В 
мультипрограммном режиме есть возможность управлять несколькими параллельными 
задачами. Вход и выход каждой задачи отображается в разных окнах, позволяя 
пользователю сосредоточиться по необходимости на каждой задаче. 
<P>WMS операционная среда связанных с окнами ресурсов управления осуществляет 
поддержку:<BR><FONT face=symbol>·</FONT>&nbsp;перекрывающихся окон 
(прямоугольных областей экрана);<BR><FONT face=symbol>·</FONT>&nbsp;различных 
устройств ввода (цифровых и аналоговых);<BR><FONT 
face=symbol>·</FONT>&nbsp;курсоров;<BR><FONT face=symbol>·</FONT>&nbsp;шрифтов. 
<P>Интерфейс со стороны оператора и прикладной программы содержит команды 
заведения/уничтожения окон, изменения их размеров и положения, поднятие наверх, 
сжатия окна до пиктограммы и восстановления. Содержит графическую библиотеку 
вывода (только основные примитивы) и обработчик событий. Тем самым есть некие 
механизмы для реализации пользовательского интерфейса. 
<P>Возможны реализации WMS двух типов: базовая система (Kernel System), 
работающая на одной машине, и сетевая (Network oriented), реализуемая на основе 
модели клиент-сервер (client-server model). 
<P>
<CENTER>
<H3><A name=tth_sEc0.4.2>0.4.2</A>&nbsp;&nbsp;Инструментарий создания 
пользовательского интерфейса</H3></CENTER>
<P>По Майеру [<A href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#mbib103" 
name=CITEmbib103>103</A>], "Инструментарий создания пользовательского интерфейса 
есть библиотека технологических интерактивных средств, дающих возможность 
использовать физические устройства ввода (мышь, клавиатура, планшет...) для 
ввода значений (таких как команда, число, положение или имя) при наличии 
обратной связи, отображаемой на экране". Программист использует этот 
инструментарий для организации взаимодействия с человеком. Инструментарий 
содержит набор функций, реализующий компоненты интерфейса нижнего уровня такие 
как: меню, кнопки, зоны диалога, подокна, зоны прокрутки. 
<P>Возможные модели управления, по терминологии конференции 1982&nbsp;г. в 
Сиэтле: 
<P><B>1.</B>&nbsp;Внутренняя (прикладная программа вызывает подпрограмму при 
необходимости ввода/вывода). Все управление диалогом сосредотачивается в 
прикладной программе, которая должна создаваться с учетом этого факта. 
<P><B>2.</B>&nbsp;Внешняя (интерфейсные процедуры обращаются к прикладной 
программе в случае наступления требуемого события). 
<P><B>3.</B>&nbsp;Смешанная, включающая модули с управлением по той и другой 
модели. 
<P>Пути реализации: 
<P><FONT face=symbol>·</FONT> механизм обратного вызова (прикладная программа 
организована как набор процедур вызываемых инструментарием);<BR>
<P><FONT face=symbol>·</FONT> разделяемая память; 
<P><FONT face=symbol>·</FONT> передача сообщений; 
<P><FONT face=symbol>·</FONT> механизм обработки событий. 
<P>Дальнейшее развитие инструментария привело к появлению понятия Widget 
(заготовка) - объекта более сложного, чем перечисленный выше набор простых 
средств ввода в прикладную программу, хотя и включающих в себя эти средства. 
Такой инструментарий не стандартизован, различные фирмы (Apple, Sun etc.) 
предлагают существенно разный набор средств, как по номенклатуре, так и по 
функциональным возможностям. В качестве примера рассмотрим набор простых, 
составных и дополнительных заготовок, предоставляемых программным продуктом 
OSF/Motif. 
<P>Основные: 
<P>
<TABLE>
  <TBODY>
  <TR>
    <TD>Область рисования </TD>
    <TD>графическое пространство </TD>
  <TR>
    <TD>Разделитель </TD>
    <TD>линии разделяющие области </TD>
  <TR>
    <TD>Метка </TD>
    <TD>статический текст </TD>
  <TR>
    <TD>Шкала </TD>
    <TD>слайдер для получения числа </TD>
  <TR>
    <TD>Зона прокрутки </TD>
    <TD>управление прокруткой </TD>
  <TR>
    <TD>Три типа Кнопок </TD>
    <TD>управляющие кнопки с различным статусом </TD>
  <TR>
    <TD>Каскадные Кнопки </TD>
    <TD>кнопки для каскадных меню </TD>
  <TR>
    <TD>Необязательные поля</TD>
    <TD>отображение перечислимых значений </TD>
  <TR>
    <TD></TD>
    <TD>переменной </TD>
  <TR>
    <TD>Текст </TD>
    <TD>ввод и редактирование текста </TD>
  <TR>
    <TD>Команды </TD>
    <TD>клавиатура с описанием </TD></TD></TR></TBODY></TABLE>
<P>Составные: 
<P>
<TABLE>
  <TBODY>
  <TR>
    <TD>Доска объявлений </TD>
    <TD>панель с произвольным размещением </TD>
  <TR>
    <TD></TD>
    <TD>объектов </TD>
  <TR>
    <TD>Экранная форма </TD>
    <TD>форма размещения объектов с </TD>
  <TR>
    <TD></TD>
    <TD>выравниванием </TD>
  <TR>
    <TD>Список </TD>
    <TD>список строк </TD>
  <TR>
    <TD>Вертикальное подокно </TD>
    <TD>столбец с изменяемой высотой </TD>
  <TR>
    <TD>СтрокаСтолбец </TD>
    <TD>объект с ограничениями по строкам и </TD>
  <TR>
    <TD></TD>
    <TD>столбцам </TD>
  <TR>
    <TD>Зона меню </TD>
    <TD>область меню для выпадающего меню </TD>
  <TR>
    <TD>Кадр </TD>
    <TD>контейнер для поддержки 3D обрамления </TD></TD></TR></TBODY></TABLE>
<P>Дополнительные: 
<P>
<TABLE>
  <TBODY>
  <TR>
    <TD>Прокрутка текста </TD>
    <TD>область прокрутки текста </TD>
  <TR>
    <TD>Прокрутка списка </TD>
    <TD>область прокрутки списка </TD>
  <TR>
    <TD>Окно прокрутки </TD>
    <TD>обобщенная область прокрутки </TD>
  <TR>
    <TD>Радио поле </TD>
    <TD>набор радио кнопок </TD>
  <TR>
    <TD>Поле выбора </TD>
    <TD>выбор из списка строк </TD>
  <TR>
    <TD>Поле выбора файла </TD>
    <TD>специализированная область селектирования </TD>
  <TR>
    <TD></TD>
    <TD>файлов</TD>
  <TR>
    <TD>Основное окно </TD>
    <TD>прикладное окно верхнего уровня </TD>
  <TR>
    <TD>Поле диалога </TD>
    <TD>транзитное поле диалога </TD>
  <TR>
    <TD>Диалог в экранной </TD>
    <TD>транзитное поле диалога для экранных </TD>
  <TR>
    <TD>форме </TD>
    <TD>форм "выпадающее"/"выпрыгивающее" меню </TD>
  <TR>
    <TD>Сообщение/ </TD>
    <TD>зона диалога для печати сообщений </TD>
  <TR>
    <TD>предупреждение </TD>
    <TD></TD></TR></TBODY></TABLE>
<P>Несмотря на явное облегчение создания интерфейса пользователя с помощью 
такого инструментария, сейчас ставится задача создания интегрированной среды 
разработки и управления диалогом. Основной целью таких систем является отделение 
процесса конструирования интерфейса от разработки прикладной программы. 
<P>
<CENTER>
<H3><A name=tth_sEc0.4.3>0.4.3</A>&nbsp;&nbsp;Системы управления интерфейсом 
пользователя</H3></CENTER>
<P>В научной литературе пока нет согласованного взгляда на термин UIMS - точное 
его значение само является объектом исследования. Одна из версий принадлежит 
Майерсу: "Система проектирования интерфейса пользователя есть интегрированный 
набор средств, помогающих программисту в создании и управлении различными 
интерфейсами пользователя. Эти системы обычно называют системами управления 
пользовательским интерфейсом (UIMS - User Interface Management Systems), но 
предпочтительнее называть их системами проектирования (UIDS - User Interface 
Development Systems), поскольку UIMS ассоциируется только с частью системы, 
работающей во время исполнения программы (но не с частью, используемой во время 
разработки), или с системами, включающими явные компоненты управления диалогом. 
UIDS обеспечивает как разработку, так и реализацию интерфейса и, таким образом, 
покрывает более широкий класс программ". 
<P>Основной концепцией UIDS является идея строгого разделения интерфейса и 
прикладной программы. В идеале она должна поддерживать все стили диалога и 
упрощать построение сложных интерфейсов. UIDS должен обеспечивать язык 
определения интерфейса для представления требуемого диалога и генератор, которой 
автоматически создает необходимый код из исходного определения в этом языке. Эти 
функции во многом похожи на функции компилятора или интерпретатора для обычных 
языков программирования. 
<P>Можно выделить три объекта, для каждого из которых ставятся различные цели 
при разработки UIDS. 
<OL type=1>
  <P>
  <LI>Интерфейс с пользователем: 
  <UL>
    <P>
    <LI>согласованность; 
    <LI>поддержка пользователя разного уровня; 
    <LI>обеспечение обработки ошибок и восстановления. </LI></UL>
  <P></P>
  <LI>Разработчик программного обеспечения: 
  <UL>
    <P>
    <LI>предоставление абстрактного языка для конструирования интерфейса 
    пользователя; 
    <LI>предоставление согласованных интерфейсов для связанных прикладных задач; 

    <LI>простота изменения интерфейса на стадии его проектирования (быстрое 
    создание прототипа); 
    <LI>упрощение разработки повторным использованием программных компонент; 
    <LI>обеспечение простоты изучения и использования прикладных программ. 
  </LI></UL>
  <P></P>
  <LI>Конечный пользователь: 
  <UL>
    <P>
    <LI>согласованность интерфейса по прикладным программам; 
    <LI>многоуровневая поддержка сопровождения или функций помощи; 
    <LI>поддержка процесса обучения; 
    <LI>поддержка расширяемости прикладных программ. </LI></UL>
  <P></P></LI></OL>Эти цели определяют следующие ФУНКЦИОНАЛЬНЫЕ ХАРАКТЕРИСТИКИ 
UIDS/UIMS:<BR><FONT face=symbol>·</FONT>&nbsp;работа с входными 
устройствами;<BR><FONT face=symbol>·</FONT>&nbsp;проверка допустимости 
ввода;<BR><FONT face=symbol>·</FONT>&nbsp;обработка ошибок 
пользователя;<BR><FONT face=symbol>·</FONT>&nbsp;реализация обратной 
связи;<BR><FONT face=symbol>·</FONT>&nbsp;поддержка обновления/изменения данных 
прикладной задачи,<BR><FONT face=symbol>·</FONT>&nbsp;поддержка задач развития 
интерфейса;<BR><FONT face=symbol>·</FONT>&nbsp;синтаксическая поддержка. 
<P>Наиболее часто используется модель, введенная на конференции в Seeheim, в 
соответствии с которой UIMS состоит из трех КОМПОНЕНТ: 
<P><FONT face=symbol>·</FONT> система представления, обеспечивающая 
низкоуровневый ввод и вывод;<BR>
<P><FONT face=symbol>·</FONT> система управления диалогом, обрабатывающая 
лексические единицы, получаемые в системе представления, в соответствии с 
синтаксисом диалога;<BR>
<P><FONT face=symbol>·</FONT> модель интерфейса прикладной программы, 
представляющая семантику диалога и управляющая функциональностью прикладной 
программы.<BR>
<P>Структурная схема компонент UIMS/UIDS представлена на рис.&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#r4_1">0.4.26</A>. 
<P>
<P><A name=tth_fIg0.26></A><A name=r4_1>
<CENTER><BR><IMG alt="Рисунок 26" 
src="Учебное пособие Архитектуры графических систем_files/kg0326.gif">
<P></CENTER>
<CENTER>Рис. 0.4.26: Уровни в системах разработки пользовательского 
интерфейса</CENTER></A>
<P>
<P>Конкретные реализации моделей основываются на различных СПОСОБАХ СПЕЦИФИКАЦИИ 
интерфейса, среди которых можно выделить следующие типы:<BR><FONT 
face=symbol>·</FONT>&nbsp;языковая;<BR><FONT 
face=symbol>·</FONT>&nbsp;графическая;<BR><FONT 
face=symbol>·</FONT>&nbsp;автогенерация по спецификации прикладной 
задачи;<BR><FONT face=symbol>·</FONT>&nbsp;объектно-ориентированный подход. 
<P>Каждая из этих спецификаций имеет свои особенности. В языковой используется 
спецязык для спецификации синтаксиса интерфейса. Такими языками могут 
служить:<BR><FONT face=symbol>·</FONT>&nbsp;сети меню;<BR><FONT 
face=symbol>·</FONT>&nbsp;диаграммы состояний и переходов;<BR><FONT 
face=symbol>·</FONT>&nbsp;контекстно-свободные грамматики;<BR><FONT 
face=symbol>·</FONT>&nbsp;языки событий;<BR><FONT 
face=symbol>·</FONT>&nbsp;декларативные языки;<BR><FONT 
face=symbol>·</FONT>&nbsp;обычные языки программирования;<BR><FONT 
face=symbol>·</FONT>&nbsp;объектно-ориентированные языки. 
<P>Этот подход приложим к широкому кругу прикладных задач. Его недостатком 
является то, что разработчик диалога должен обладать профессиональной 
программисткой подготовкой. 
<P>Графическая спецификация связана с определением интерфейса с помощью 
размещения объектов на экране (визуальное программирование). Она проста для 
использования не программистами, НО:<BR><FONT face=symbol>·</FONT>&nbsp;трудна в 
реализации;<BR><FONT face=symbol>·</FONT>&nbsp;поддерживает лишь ограниченные 
интерфейсы. 
<P>Здесь также существуют разные реализации: 
<P><FONT face=symbol>·</FONT> размещение на экране интерактивных средств (меню, 
кнопки и т.п.) и их привязка к фрагментам, написанным разработчиком 
интерфейса;<BR>
<P><FONT face=symbol>·</FONT> сеть статичных страниц (кадров), содержащих 
тексты, графики, интерактивные средства;<BR>
<P><FONT face=symbol>·</FONT> спецификация по демонстрации. 
<P>В третьем подходе создают интерфейс автоматически по спецификации семантики 
прикладных задач. Этим, в сущности, предпринимается попытка преодолеть сложности 
использования других технологий, однако ввиду сложности адекватного описания 
интерфейса, трудно ожидать скорого появления систем, реализующих такой подход в 
полной мере. 
<P>Возможные реализации: 
<P><FONT face=symbol>·</FONT> создание интерфейса на основе списка процедур 
прикладной программы (Mike); 
<P><FONT face=symbol>·</FONT> создание интерфейса по типам параметров процедур 
(Control Panel Interface);<BR>
<P><FONT face=symbol>·</FONT> создание интерфейса на основе определения 
семантики прикладной задачи, описываемой на специальном языке (IDL).<BR>
<P>Четвертый подход связан с принципом, называемом 'Direct Manipulation' - DM, 
рассматриваемым в следующем разделе. Основное свойство этого подхода состоит в 
том, что пользователь взаимодействует с индивидуальными объектами, а не со всей 
системой как единым целым. 
<P>
<CENTER>
<H3><A name=tth_sEc0.4.4>0.4.4</A>&nbsp;&nbsp;Непосредственное 
манипулирование</H3></CENTER>
<P>Во многих отношениях технология непосредственного манипулирования (DM - 
Direct Manipulation) рассматривается как новая генерация методов 
программирования в области проектирования интерфейса с пользователем, имеющих 
такое же значение как разработка языка четвертого поколения для разработки баз 
данных. Начало этому подходу положили исследования, проводимые в центре Palo 
Alto корпорацией Xerox. 
<P>Что же такое непосредственность? Можно выделить четыре аспекта этого понятия: 

<P>Семантическая непосредственность. Определяется через "расстояние" между 
пользовательскими намерениями и операциями предоставляемыми системой. 
Пользователю важно, что: (1) в любое время он может передать свои намерения 
системе и (2) он может их выразить простым и кратким способом. 
<P>Для достижения этих целей необходимо, чтобы система предоставляла 
соответствующую функциональность, наряду с концептуальными объектами и 
операциями на уровне абстракции, удовлетворяющей пользователя. Эта проблема 
хорошо известна из области языков программирования высокого уровня - конструкции 
языка должны соответствовать проблемной области. Другими словами, семантическая 
непосредственность заключается в предоставлении пользователю возможности 
определять собственные классы графических объектов, соответствующих его 
прикладной задаче, а не заставлять его использовать базовые графические 
примитивы системы. 
<P>Операционная непосредственность. На уровне диалога можно рассматривать 
временной аспект непосредственности. Диалоговая последовательность не обладает 
нужной непосредственностью, если пользователь хочет воспользоваться 
последовательностью действий, не предоставляемых системой. Например, выбор 
пиктограммы с помощью мыши и получение возможности тут же передвинуть ее по 
экрану является реализацией непосредственности в операционном смысле, поскольку 
действие не подразделяется на дополнительные команды ввода (не надо нажимать 
клавишу "двигать"). 
<P>Но не просто определить последовательность действий в намерениях 
пользователя. Большинство DM систем пытаются сделать все видимые объекты 
доступными способами инициируемыми пользователем и поддержать развитие 
последовательности действий непосредственной обратной связью на каждом шаге. 
<P>Формальная непосредственность. Этот аспект относится к естественности 
восприятия системного вывода, простоте и эффективности ввода (клавиатура, 
кнопки, работа с мышью и т.п). Увеличению степени формальной непосредственности 
может способствовать использование представления в виде пиктограмм при выборе 
объектов и функций вместо символических имен команд, хорошо структурированный 
экран и понятное обозначение функциональных клавиш. Еще одним важным требованием 
является использование принципа "То что вы видите - то и получите" (WYSIWYG - 
What You See Is What You Get), благодаря которому на экране формируется именно 
то изображение, которое будет получено при распечатке. 
<P>Компоненты DM интерфейса. На верхнем уровне DM систем обычно находится одна 
из метафор графического представления (типа метафоры письменного стола, 
конкретный объект). Через этот верхний уровень пользователю доступны прикладные 
программы, работающие на окнах. В окнах, подокнах и компонентах экрана доступны 
различные средства выбора объектов, функций инициирования и управления. 
Типичными компонентами используемыми для манипуляций с объектами и управляющими 
функциями являются: 
<UL>
  <P>
  <LI>Обработчики (Handlers): управление непосредственно связанное с объектами, 
  определяемыми прикладной программой. Обычно проявляются после выбора объекта и 
  могут быть "захвачены" с помощью мыши для выполнения самых разнообразных 
  манипуляций типа перемещения, изменения размеров, вращения и т.п. 
  <LI>Управления (Controls): элементарные средства инициации функций или ввода 
  параметров. Например, Motif предоставляет следующие типы управления: 
  <UL>
    <P>
    <LI>кнопки различного вида (простые, радио, контрольные); 
    <LI>зоны (boxes) вывода, ввода, форматного ввода; 
    <LI>датчики (шкалы, <FONT face=symbol>ј</FONT>). </LI></UL>
  <P></P>
  <LI>Меню: рассматриваемые как совокупность элементарных управлений с типовой 
  организацией (в Open Look меню есть просто набор кнопок). Наиболее часто 
  используемые типы меню: "выпадающие" (pull-down), "выпрыгивающие" (pop-up) и 
  каскадные. 
  <LI>Зоны диалога (Dialog boxes): для выдачи сообщений или ввода подтверждения. 
  </LI></UL>
<P>
<CENTER>
<H4>Синтаксические режимы и обратная связь</H4></CENTER>
<P>DM часто называют интерактивной технологией с отсутствием режимов. Это 
конечно не так, но верно, что пользователь получает доступ к множеству 
функциональностей работая в нормальном контексте, команды и режимы ввода, 
присущие командно-ориентированным редакторам в этой технологии по возможности не 
используются. Обычной синтаксической композицией взаимодействия в DM является 
"выбор объекта" за которым следует "активация функции". Переход в режим "объект 
выбран" отражается изменением яркости объекта, после активации функции возможен 
переход в новый режим (например ожидания ввода параметра) отображаемый 
изменением формы курсора. 
<P>Требования к конструированию DM интерфейсов: 
<P><FONT face=symbol>·</FONT> поддержка разных классов интерактивной технологии; 

<P><FONT face=symbol>·</FONT> возможность создания новых типов технологий; 
<P><FONT face=symbol>·</FONT> использования подходящего, простого в изучении 
языка программирования для описания частей системы, которую трудно 
специфицировать графически;<BR>
<P><FONT face=symbol>·</FONT> предоставление разной интерактивной технологии 
одновременно; 
<P><FONT face=symbol>·</FONT> обеспечение семантической обратной связи, проверки 
семантики и использования в семантике установок по умолчанию;<BR>
<P><FONT face=symbol>·</FONT> гибкость компоненты представления; 
<P><FONT face=symbol>·</FONT> выражение синтаксиса в терминах индивидуальных 
объектов. 
<P>
<CENTER>
<H3><A name=tth_sEc0.4.5>0.4.5</A>&nbsp;&nbsp;Пример реализации 
UIDS/UIMS</H3></CENTER>
<P>В заключении приведем в качестве примера описание системы UIMS XFaceMaker2 
фирмы Non Standard Logics, созданной на базе OSF/Motif и X Window System. 
<OL type=1>
  <P>
  <LI>Проектирование интерфейса. Пользователь создает интерфейс в интерактивном 
  режиме, используя предопределенные элементы - заготовки (Widgets). 
  <LI>Спецификация ресурсов. Реализует простую установку параметров (ресурсов) 
  для заготовок. Многообразие ресурсов заготовок и их взаимодействия делает 
  задачу установки параметров чрезвычайно сложной. XFM2 везде, где это возможно, 
  предоставляет предопределенную установку соответствующего выбора, в частности 
  в зонах диалога. 
  <LI>Спецификация поведения интерфейса. Описывается на С-подобном командном 
  языке (Face). Динамика поведения интерфейса трактуется XFM2 как целостная 
  часть вместе с геометрическим представлением. 
  <LI>Простая и естественная связь между интерфейсом и прикладной задачей. 
  Реализована двумя способами: вызовом функции прикладной задачи из описания или 
  с помощью разделяемых переменных (активных значений). Разделяемые переменные 
  могут быть любого типа. Таким образом возможна связь с прикладной задачей 
  через указатель на заготовку в интерфейсе. 
  <LI>Непосредственное и полное тестирование интерфейса и его поведения (так 
  называемый режим попытки (try mode). В этом режиме интерпретируется описание 
  связанное с какими либо событиями, но без вызова функций прикладной задачи. 
  <LI>Эффективность конечного приложения. Результат проектирования реализуется 
  двумя способами: либо интерпретацией описания, аналогично режиму TRY, либо 
  компиляцией интерфейса вместе со всеми описаниями в С код. </LI></OL>
<P>
<CENTER>
<H3><A name=tth_sEc0.4.6>0.4.6</A>&nbsp;&nbsp;Выводы</H3></CENTER>
<P>Ситуация в области разработки систем построения и управления интерфейсом 
пользователя в наши дни напоминает ситуацию с графикой до выработки 
международных стандартов: нет единой терминологии, есть разные подходы к 
построению моделей (лингвистический, графический), которые часто пересекаются. 
<P>Анализ разработок в области UIMS позволяет представить соотношение между 
различными компонентами в виде слойной структуры, напоминающей структуру OSI [<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#mbib104" 
name=CITEmbib104>104</A>]. При реализации конкретной прикладной задачи 
необходимый уровень UIMS и набор компонент может определяться из соображений 
требуемой эффективности и доступных ресурсов. 
<P>
<P><A name=tth_fIg0.27></A><A name=r4_2>
<CENTER><BR><IMG alt="Рисунок 27" 
src="Учебное пособие Архитектуры графических систем_files/kg0327.gif">
<P></CENTER>
<CENTER>Рис. 0.4.27: Рекомендованная модель UIMS</CENTER></A>
<P>
<P>Открытые проблемы в разработки UIMS можно определить как:<BR><FONT 
face=symbol>·</FONT>&nbsp;эргономика взаимодействия;<BR><FONT 
face=symbol>·</FONT>&nbsp;управление диалогом;<BR><FONT 
face=symbol>·</FONT>&nbsp;отделение интерфейса пользователя;<BR><FONT 
face=symbol>·</FONT>&nbsp;сопровождение, мобильность и эффективность. 
<P>Пока не существует единственной стратегии конструирования UIMS. Нужны 
эксперименты и опыт. Сфера быстро развивающаяся, сулящая многочисленные выгоды. 
Появившиеся стандарты (пока де-факто), по крайней мере на нижних уровнях систем 
(X-Windows и, в какой-то степени OSF/Motif), и активность разработчиков многих 
фирм дают надежду что ситуация в ближайшее время может измениться к лучшему. 
<P></I></B></TT><U>4.&nbsp;VISC - ИНИЦИАТИВА</U> 
<CENTER>
<H3><A name=tth_sEc0.5>0.5</A>&nbsp;&nbsp;VISC - ИНИЦИАТИВА</H3></CENTER>
<P>С расширением использования суперкомпьютеров заметно обострилась известная и 
ранее проблема - проблема представления результатов в форме удобной для 
воспринятия и анализа ее человеком. Здесь сложилась ситуация, когда, по 
образному выражению Апсона, "исследователь может вычислить больше, чем 
запомнить, а запомнить - больше чем понять". Поэтому чрезвычайно важна 
разработка средств, непосредственно ведущих от вычислений к пониманию. 
<P>Следует отличать визуализацию (visualization) от представления данных 
(prezentation) и отображения (rendering). Под визуализацией следует понимать 
средство, "делающее видимым невидимое", т.е. средство выражения мысли в 
графической форме [<A href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#mbib82" 
name=CITEmbib82>82</A>]. Под представлением данных следует понимать ту или иную 
графическую интерпретацию необязательно графических данных. Под отображением 
следует понимать представление данных графического или геометрического характера 
на те или иные устройства вывода. 
<P>Повышение интереса к визуализации породило в США инициативу ViSC 
(Visualization in Scientific Computing) - "Визуализация в научных исследованиях" 
[<A href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#mbib55" 
name=CITEmbib55>55</A>]. На ViSC - инициативу предполагается финансирование в 
объеме 1% от всех затрат на машинную графику (в 1990 г. это составило около 170 
млн. долларов). 
<P>ViSC - инициатива охватывает (интегрирует) машинную графику, обработку 
изображений, компьютерное зрение, САПР (дизайн), обработку сигналов, 
пользовательский интерфейс. 
<P>Серьезной проблемой при построении системы интерактивной визуализации 
является совмещение графики с многооконным интерфейсом [<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#mbib58" name=CITEmbib58>58</A>]. 
Важным моментом является использование современных стандартов машинной графики 
[<A href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#mbib80" 
name=CITEmbib80>80</A>] и построение эталонной модели для системы визуализации 
[<A href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#mbib62" 
name=CITEmbib62>62</A>]. 
<P>Технической базой для разработки систем визуализации являются суперстанции, 
конкретный пример такой системы рассмотрен ниже. 
<P>
<CENTER>
<H3><A name=tth_sEc0.5.1>0.5.1</A>&nbsp;&nbsp;AVS - Прикладная система научной 
визуализации</H3></CENTER>
<P>Одна из лучших систем по научной визуализации сделана на фирме STELLAR 
Computer при участии Крейга Апсона и Эндриса ван Дама [<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#mbib121" 
name=CITEmbib121>121</A>]. 
<P>Эта система получила название AVS - Application Visualization System - и была 
задумана как инструмент для быстрой и эффективной визуализации данных при 
минимальных затрат на программирование для ученых и инженеров. Цель системы - 
объединить интерактивную графику и мощные вычислительные средства, которые легко 
можно было бы использовать непрограммистами, а с другой стороны, программистам 
эта бы система обеспечивала мощный и гибкий инструмент для развития. Система 
построена по модульному принципу и предоставляет пользователю интерфейс прямого 
манипулирования для каждого модуля. Система ориентирована для применения на 
супер графических станциях с мощным вычислителем и аппаратной поддержкой 
3D-графики. 
<P>В проект системы были заложены следующие цели:<BR><FONT 
face=symbol>·</FONT>&nbsp;простота в использовании;<BR><FONT 
face=symbol>·</FONT>&nbsp;низкая стоимость;<BR><FONT 
face=symbol>·</FONT>&nbsp;завершенность для применения;<BR><FONT 
face=symbol>·</FONT>&nbsp;расширяемость функций;<BR><FONT 
face=symbol>·</FONT>&nbsp;мобильность. 
<P>По мнению авторов системы такие стандарты, как PHIGS+ [<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#mbib106" 
name=CITEmbib106>106</A>], GL, GKS [<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#mbib75" name=CITEmbib75>75</A>], 
Core System [<A href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#mbib119" 
name=CITEmbib119>119</A>] и др. имеют очень низкий уровень применения и не могут 
удовлетворить пользователя, занимающегося визуализацией. Аналогичное мнение было 
высказано В.Н.Кочиным [<A href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#mbib98" 
name=CITEmbib98>98</A>]. С другой стороны, такие коммерческие системы, как 
MOVIE.BYU и продукция Wavefront и Alias, являются слишком замкнутыми, и их 
трудно интегрировать с прикладными задачами пользователей. Они больше 
используются как графические постпроцессоры после получения пользователем файла 
с данными. Типичный недостаток таких систем - хвост априорной ориентации на 
конкретную прикладную область (вычислительная химия, гидродинамика и др.) с 
вытекающими последствиями на привычные формы данных, используемые графические 
примитивы и алгоритмы. Такие системы трудно интегрировать с другими 
приложениями. Авторы AVS, используя новейшие достижения в области информационных 
технологий, такие как объектно-ориентированный подход, визуальное 
программирование и распределенные вычисления, смогли построить унифицированную 
систему, которую легко интегрировать с прикладной программой произвольной 
предметной области. Успех AVS во многом определился тем, что она разработана 
построена на общих принципах построения модели вычислений и анализа данных [<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#mbib77" name=CITEmbib77>77</A>,] 
(рис.&nbsp;<A href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#r5_1">0.5.28</A> и 
<A href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#r5_2">0.5.29</A>). 
<P>
<P><A name=tth_fIg0.28></A><A name=r5_1>
<CENTER><BR><IMG alt="Рисунок 28" 
src="Учебное пособие Архитектуры графических систем_files/kg0328.gif">
<P></CENTER>
<CENTER>Рис. 0.5.28: Цикл вычислений</CENTER></A>
<P>
<P>
<P><A name=tth_fIg0.29></A><A name=r5_2>
<CENTER><BR><IMG alt="Рисунок 29" 
src="Учебное пособие Архитектуры графических систем_files/kg0329.gif">
<P></CENTER>
<CENTER>Рис. 0.5.29: Цикл анализа</CENTER></A>
<P>
<P>Основные процедуры переработки данных можно определить следующим образом: 
<P><FONT face=symbol>·</FONT> фильтрация данных - из одной формы в другую, 
возможно более информативную и менее объемную (фильтрация данных в данные),<BR>
<P><FONT face=symbol>·</FONT> мэппинг (моделирование) - преобразование данных в 
геометрические примитивы (сопоставление чисел и геометрии),<BR>
<P><FONT face=symbol>·</FONT> отображение геометрических данных в картинки 
(отображение геометрии в образы).<BR>
<P>Процедура фильтрации включает в себя вычисление производных величин, таких 
как градиенты скалярных полей, огибающих поле скоростей и т.п. Эти новые, 
производные данные исследователь может связать с широким набором геометрических 
примитивов, традиционно используемых в машинной графике: точки, линии, сплайны, 
полигоны, поверхности, сферы и т.п. Один набор данных, таких как, например, 
трехмерное скалярное поле, может быть преобразован в геометрические примитивы 
многими способами, как показано на рис.&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#r5_3">0.5.30</A>. 
<P>
<P><A name=tth_fIg0.30></A><A name=r5_3>
<CENTER><BR><IMG alt="Рисунок 30" 
src="Учебное пособие Архитектуры графических систем_files/kg0330.gif">
<P></CENTER>
<CENTER>Рис. 0.5.30: Возможности моделирования трехмерного скалярного 
поля</CENTER></A>
<P>
<P>При разработке AVS основным принципом было удовлетворение сформулированных 
выше требований. 
<P>Отдавая должное специфике научных исследований основное внимание уделялось 
расширяемости системы самими пользователями. При этом принималось во внимание 
наличие трех категорий разработчиков новых модулей. 
<P>В первую категорию входят пользователи, которые хотят создать новые модули 
для своих конкретных специфических приложений. 
<P>Вторую категорию составляют разработчики модулей, в некотором смысле 
универсальных для целой научной дисциплины, такой как газовая динамика или 
молекулярное моделирование. 
<P>Третью категорию составляют разработчики коммерческого прикладного 
программного обеспечения. Это программное обеспечение наиболее трудно 
интегрируется с другими платформами приложений. 
<P>Таким образом, AVS обеспечивает обобщенную функциональную применимость 
визуализации и специфицирует интерфейс между компонентами программного 
обеспечения для различных потребителей - пользователей и разработчиков, 
предоставляя им за небольшую стоимость больше гибкости и легкости к интеграции. 
<P>
<CENTER>
<H4><A name=tth_sEc0.5.1.1>Архитектура системы прикладной 
визуализации</A></H4></CENTER>
<P>Основная идея архитектуры заключается в объединении усилий исследователей 
(пользователей) и разработчиков (программистов) для создания визуализации, 
независимо от конкретных приложений. 
<P>Архитектура построения на элементах более высокого уровня абстракции, чем 
процедуры, но ниже, чем прикладные программы. 
<P>Основная концепция образована из объектно-ориентированного подхода [<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#mbib67" name=CITEmbib67>67</A>] и 
заказного (customised) программного обеспечения. Обработка данных построена на 
основе конвейера с возможностью параллельной и распределенной реализации. Модули 
конвейера могут быть определены следующим образом: 
<P><FONT face=symbol>·</FONT> Исходные модули - генераторы данных (не имеющие 
исходных данных), вырабатывающие несколько потоков данных, в зависимости от 
параметров генерации.<BR>
<P><FONT face=symbol>·</FONT> Модули преобразователи (или фильтры в терминологии 
АТОМ) - процедуры, выполняющие фильтрацию данных, моделирование геометрических 
характеристик и отображение геометрии в изображение.<BR>
<P><FONT face=symbol>·</FONT> Терминальные (оконечные) модули - осуществляющие 
вывод на конкретные устройства: дисплеи, принтеры, видеозапись.<BR>
<P>Структура модулей (рис.&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#r5_4">0.5.31</A>) очень похожа на 
конвейерный подход, реализованный в графическом пакете АТОМ [<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#mbib98" name=CITEmbib98>98</A>]. 
При реализации программного обеспечения активно использовалась методика 
измерения программных алгоритмов и модулей и улучшение их характеристик на 
основе измеренных данных. 
<P>
<P><A name=tth_fIg0.31></A><A name=r5_4>
<CENTER><BR><IMG alt="Рисунок 31" 
src="Учебное пособие Архитектуры графических систем_files/kg0331.gif">
<P></CENTER>
<CENTER>Рис. 0.5.31: Концептуальная модель модуля</CENTER></A>
<P>
<P>При проектировании пользовательского интерфейса основное внимание уделялось 
характеристике приспособляемости к различным группам пользователей, таких как 
"новички" и "эксперты". За основу при реализации здесь брали методику 
визуального программирования [<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#mbib113" 
name=CITEmbib113>113</A>]. 
<P>В результате были созданы два интерфейса - пользовательский (для 
непрограммиста) и программистский (для профессионала-программиста). Эти 
интерфейсы существенно различаются как по использованию аппаратуры ввода 
(манипулирования), так и по программированию процедур заказчика. 
<P>В системе визуализации используются следующие методики [<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#mbib111" 
name=CITEmbib111>111</A>]: 
<OL type=1>
  <P>
  <LI>Отображение объемов, основанное на технике вокселей. 
  <LI>Отображение объемов построенное на технике реалистичности и технике 
  текстур. 
  <LI>Мозаичное построение (закрашивание) изоповерхностей. 
  <LI>Техника направленных частиц. </LI></OL>
<P>Схема вычислительного конвейера показана на рис.&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#r5_5">0.5.32</A>. Причем, 
пользователь может управлять конкретной цепочкой вычислений из этого конвейера 
(как выбор пути на сетевом графике). 
<P>
<P><A name=tth_fIg0.32></A><A name=r5_5>
<CENTER><BR><IMG alt="Рисунок 32" 
src="Учебное пособие Архитектуры графических систем_files/kg0332.gif">
<P></CENTER>
<CENTER>Рис. 0.5.32: Пример потока обработки</CENTER></A>
<P>
<P>В заключение можно утверждать, что пользователи AVS получили в свое 
расположение систему нового типа для проведения исследований и разработок (R 
&amp; D) в своих конкретных предметных областях с помощью методов визуализации. 
AVS дает возможность пользователям интегрировать свои прикладные программы с 
самыми современными алгоритмами и методами визуализации. 
<P>Другой целью создания AVS было построение такой законченной системы 
визуализации, которая походила бы к большинству прикладных вычислительных наук. 
<P>AVS по своему принципу построения не является застывшей системой, а способна 
к развитию и совершенствованию как самими пользователями, так и на основе 
обратной связи с ними. 
<P></I></B></TT><U>5.&nbsp;ОЦЕНКА ПРОИЗВОДИТЕЛЬНОСТИ</U> 
<CENTER>
<H3><A name=tth_sEc0.6>0.6</A>&nbsp;&nbsp;ОЦЕНКА 
ПРОИЗВОДИТЕЛЬНОСТИ</H3></CENTER>
<P>В данном разделе: 
<P><FONT face=symbol>·</FONT> формулируются подходы к оценке производительности 
рабочих станций;<BR>
<P><FONT face=symbol>·</FONT> кратко описываются популярные тестовые программы; 
<P><FONT face=symbol>·</FONT> приводятся результаты тестирования некоторых 
(более 20) рабочих станций. 
<P>Факторами, определяющие производительность рабочей станции, приведены на 
рис.&nbsp;<A href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#r6_1">0.6.33</A>. 
<P>
<P><A name=tth_fIg0.33></A><A name=r6_1>
<CENTER><BR><IMG alt="Рисунок 33" 
src="Учебное пособие Архитектуры графических систем_files/kg0333.gif">
<P></CENTER>
<CENTER>Рис. 0.6.33: Факторы, определяющие производительность рабочей 
станции</CENTER></A>
<P>
<P>Для оценки производительности компьютеров могут быть предложены несколько 
подходов: 
<P><FONT face=symbol>·</FONT> функциональный: вычисления, работа с файлами <FONT 
face=symbol>ј</FONT>; используется на стадии проектирования "железа" (логическое 
моделирование);<BR>
<P><FONT face=symbol>·</FONT> операционный: поведение системы в реальных 
ситуациях; используется при реализации "железа";<BR>
<P><FONT face=symbol>·</FONT> языковой: качество компиляторов, оптимизация, 
библиотеки; используется при реализации компиляторов (программы на C, F77, ADA 
<FONT face=symbol>ј</FONT>);<BR>
<P><FONT face=symbol>·</FONT> ОС: управление виртуальной памятью, обращения к 
системе, организация файловой системы; используется при реализации ОС.<BR>
<P><FONT face=symbol>·</FONT> прикладной: автоматизация офисов, DBMS, CAD <FONT 
face=symbol>ј</FONT>; используется при реализации прикладного программного 
обеспечения.<BR>
<P>Оценки производительности, основанные на сложных математических расчетах, 
например теории очередей, подходят разработчикам компьютеров и их 
производителям. Конечного же пользователя интересует в первую очередь 
производительность его собственного труда. 
<P>
<CENTER>
<H3><A name=tth_sEc0.6.1>0.6.1</A>&nbsp;&nbsp;Тестовые программы 
(Benchmarks)</H3></CENTER>
<P>Решение, полностью устраивающее конечного пользователя, состоит в 
использовании его прикладной задачи в качестве теста на интересующем его ряде 
компьютеров. К сожалению, это очень часто оказывается невозможным. 
<P>Тестовая программа - это стандартная программа, используемая для сравнения 
производительности компьютеров. Тестовые программы создаются как для оценки 
общих характеристик: управление файлами, класс математических вычислений, так и 
для оценки более специфических возможностей данного компьютера. В результате 
появляется возможность сравнить производительность различных компьютерных систем 
в интересующей Вас области. Кроме того, наличие нескольких тестовых программ 
(или одной, измеряющей несколько параметров) позволяет рассматривать компьютер 
"объемно", а не сводить эту сложную систему к одной характеристике, например, 
количеству mips. 
<P>В настоящее время на западе существует около 200 признанных тестов, которые 
могут быть разбиты на три группы: 
<P><FONT face=symbol>·</FONT> т.н. "стандартные" тесты: Dhrystone, Whetstone, 
Linpack, Doduc, Byte, Spice, Euug, Stanford, Musbus, Livermore, Los Alamos, и 
др., - опубликованные в журналах или распространяемые основными пользователями. 
Коды этих программ, часто измененные предыдущими пользователями, широко 
разошлись и теперь имеется значительное количество различных вариантов, что 
затрудняет их интерпретацию и использование;<BR>
<P><FONT face=symbol>·</FONT> т.н. "коммерческие" тесты: AIM, Neal Nelson, 
Uniprobe, Workstation Laboratories, ... - хорошо документированные, предлагающие 
хороший сервис, но достаточно дорогие и предоставляющие ту же информацию, что и 
предыдущая группа тестов;<BR>
<P><FONT face=symbol>·</FONT> т.н. "внутренние" тесты, используемые основными 
производителями (IBM, DEC, HP, ATT, Olivetty, NCR, Texas) для моделирования 
загрузки и калибровки своих компьютерных систем.<BR>
<P>
<CENTER>
<H3><A name=tth_sEc0.6.2>0.6.2</A>&nbsp;&nbsp;Результаты тестов</H3></CENTER>
<P>Для сравнения суперстанций в [<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#mbib63" name=CITEmbib63>63</A>] в 
первую очередь используется группа тестов SSBA (The Synthetic Suite of 
Benchmarks from the French Association of Unix Users), предлагаемая Французской 
Ассоциацией Пользователей Unix'a и позволяющая оценить общие возможности 
компьютера. Результаты тестов, где это возможно, даны для вычислений с двойной 
точностью и с использованием возможностей оптимизации. В табл.&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#t6_3">*</A> приведены результаты 
следующих тестов: 
<P><FONT face=symbol>·</FONT> Mips/Joy: измеряет скорость ЦПУ. Количество MIPS, 
даваемое тестом, близко к коммерческому (или VAX 11/780). Использовано 
сокращение M/J;<BR>
<P><FONT face=symbol>·</FONT> Dhrystone (Dhry/s): оценивает эффективность 
разработки ПО, особенно на С в среде Unix. Использовано сокращение Dhrys;<BR>
<P><FONT face=symbol>·</FONT> Whetstone (KWhet/s): оценивает скорость работы для 
прикладных научных и инженерных задач. Использовано обозначение Whet;<BR>
<P><FONT face=symbol>·</FONT> Linpack (Kflops): как и предыдущий, только для 
задач допускающих векторизацию вычислений (решает большую систему линейных 
уравнений). Использовано сокращение Lin;<BR>
<P><FONT face=symbol>·</FONT> Saxer (Ko/s): измеряет скорость работы файловой 
системы; 
<P><FONT face=symbol>·</FONT> Test C (sec): измеряет скорость компиляции для 
языка С (пользователь + система). Использовано сокращение TC.<BR>
<P>Графические возможности машин можно сравнить, опираясь на данные теста XBENCH 
- одного из наиболее популярных тестов для X Window серверов. Тест легко 
переносится, запускается и интерпретируется. Он был разработан фирмой Simens и 
оценивает эффективность в единицах - xstone, получаемых в результате взвешенного 
учета более элементарных измерений. Тест включает в себя измерения в 7 основных 
областях:<BR><FONT face=symbol>·</FONT>&nbsp;Линии: solid, dashed, 
wide;<BR><FONT face=symbol>·</FONT>&nbsp;Многоугольники: unfilled, filled, 
tiled, stippled, invertined;<BR><FONT face=symbol>·</FONT>&nbsp;Окружности: 
unfilled, filled;<BR><FONT face=symbol>·</FONT>&nbsp;Полигоны: filled;<BR><FONT 
face=symbol>·</FONT>&nbsp;Битовые операции: screencopy, scroll, 
bitmapcopy;<BR><FONT face=symbol>·</FONT>&nbsp;Текст: fixed fonts;<BR><FONT 
face=symbol>·</FONT>&nbsp;Сложные операции (с окнами): create, draw, destroy. 
<P>Результаты теста приведены в табл.&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm#t6_4">*</A> с использованием 
следующих сокращений: 
<DL compact>
  <P>
  <DT><B>П</B> 
  <DD>- количество процессоров, 
  <DT><B>Ком</B> 
  <DD>- комментарий, 
  <DT><B>Лин</B> 
  <DD>- линия, 
  <DT><B>Зап</B> 
  <DD>- заполненная область, 
  <DT><B>Бит</B> 
  <DD>- битовые операции, 
  <DT><B>Тек</B> 
  <DD>- текст, 
  <DT><B>Окр</B> 
  <DD>- окружность, 
  <DT><B>Слж</B> 
  <DD>- сложные операции, 
  <DT><B>XST</B> 
  <DD>- xstone. </DD></DL>
<P>
<P><A name=tth_tAb0.1></A><A name=t6_1>
<CENTER>
<TABLE border=1>
  <TBODY>
  <TR>
    <TD align=middle colSpan=5>Основные типы и параметры суперстанций. Таблица 
      6.1</TD>
  <TR>
    <TD width=200>Рабочая станция </TD>
    <TD width=200>Процессор </TD>
    <TD width=200>Частота</TD>
    <TD width=200>Диск </TD>
    <TD width=200>Шина </TD>
  <TR>
    <TD>
  <TR>
    <TD width=200>DN100X0 VS </TD>
    <TD width=200>от 1 до 4 </TD>
    <TD width=200>18 Mhz</TD>
    <TD width=200>ESDI </TD>
    <TD width=200>X-bus </TD>
  <TR>
    <TD width=200>(APOLLO) </TD>
    <TD width=200>RISC PRISM </TD>
    <TD width=200></TD>
    <TD width=200>striped</TD>
    <TD width=200>150 Mb/c </TD>
  <TR>
    <TD width=200>Decstation 5000-200</TD>
    <TD width=200>RISC MIPS </TD>
    <TD width=200>25 Mhz</TD>
    <TD width=200>SCSI </TD>
    <TD width=200>turbochannel</TD>
  <TR>
    <TD width=200>PGX Turbo (DEC) </TD>
    <TD width=200>R3000+R3010 </TD>
    <TD width=200></TD>
    <TD width=200></TD>
    <TD width=200>100 Mb/c </TD>
  <TR>
    <TD width=200>ESV 50 </TD>
    <TD width=200>RISC MIPS </TD>
    <TD width=200>25 Mhz</TD>
    <TD width=200>SCSI </TD>
    <TD width=200></TD>
  <TR>
    <TD width=200>(Evans&amp;Sutherland) </TD>
    <TD width=200>R3000+R3010 </TD>
    <TD width=200></TD>
    <TD width=200></TD>
    <TD width=200></TD>
  <TR>
    <TD width=200>HP 9000/433s Turbo </TD>
    <TD width=200>CISC </TD>
    <TD width=200>33 Mhz</TD>
    <TD width=200>SCSI </TD>
    <TD width=200>EISA </TD>
  <TR>
    <TD width=200>VRX T3 (HP) </TD>
    <TD width=200>Motorola 68040 </TD>
    <TD width=200></TD>
    <TD width=200></TD>
    <TD width=200></TD>
  <TR>
    <TD width=200>RS 6000 Powersta- </TD>
    <TD width=200>RISC POWER </TD>
    <TD width=200>25 Mhz</TD>
    <TD width=200>SCSI </TD>
    <TD width=200>MCA </TD>
  <TR>
    <TD width=200>tion 730 (IBM) </TD>
    <TD width=200></TD>
    <TD width=200></TD>
    <TD width=200></TD>
    <TD width=200>40 Mb/c </TD>
  <TR>
    <TD width=200>Interpro 6280 </TD>
    <TD width=200>RISC </TD>
    <TD width=200>50 Mhz</TD>
    <TD width=200>SCSI </TD>
    <TD width=200></TD>
  <TR>
    <TD width=200>(INTERGRAPH) </TD>
    <TD width=200>Clipper C300 </TD>
    <TD width=200></TD>
    <TD width=200></TD>
    <TD width=200></TD>
  <TR>
    <TD width=200>Powerstation </TD>
    <TD width=200>от 1 до 8 </TD>
    <TD width=200>33 Mhz</TD>
    <TD width=200>IPI2X </TD>
    <TD width=200></TD>
  <TR>
    <TD width=200>4D/3X0 VGX </TD>
    <TD width=200>RISC MIPS </TD>
    <TD width=200></TD>
    <TD width=200></TD>
    <TD width=200></TD>
  <TR>
    <TD width=200>(Silicon Graphics) </TD>
    <TD width=200>R3000+R3010 </TD>
    <TD width=200></TD>
    <TD width=200></TD>
    <TD width=200></TD>
  <TR>
    <TD width=200>Stardent 30X0 </TD>
    <TD width=200>от 1 до 8 RISC </TD>
    <TD width=200>33 Mhz</TD>
    <TD width=200>SCSI </TD>
    <TD width=200>256 Mb/c </TD>
  <TR>
    <TD width=200>(STARDENT) </TD>
    <TD width=200>MIPS R3000 + </TD>
    <TD width=200></TD>
    <TD width=200>striped</TD>
    <TD width=200></TD>
  <TR>
    <TD width=200></TD>
    <TD width=200>vector unit </TD>
    <TD width=200></TD>
    <TD width=200></TD>
    <TD width=200></TD>
  <TR>
    <TD width=200>Sparc Station 470 </TD>
    <TD width=200>RISC SPARC </TD>
    <TD width=200>33 Mhz</TD>
    <TD width=200>IPI </TD>
    <TD width=200>Sbus </TD>
  <TR>
    <TD width=200>TAAC-1 (SUN) </TD>
    <TD width=200>Cypress </TD>
    <TD width=200></TD>
    <TD width=200></TD>
    <TD width=200></TD>
  <TR>
    <TD width=200>XD 88/34 </TD>
    <TD width=200>RISC Motorolla </TD>
    <TD width=200>20 Mhz</TD>
    <TD width=200>SCSI </TD>
    <TD width=200>Futurebus</TD>
  <TR>
    <TD width=200>(TEKTRONIX) </TD>
    <TD width=200>88100 + 4 88200</TD>
    <TD width=200></TD>
    <TD width=200></TD>
    <TD width=200>100 Mb/c </TD></TD></TR></TBODY></TABLE></CENTER>
<P></A>
<P>
<P><A name=tth_tAb0.1></A><A name=t6_2>
<CENTER>
<TABLE border=1>
  <TBODY>
  <TR>
    <TD align=middle colSpan=5>Скорости основных построений на суперстанциях. 
      Таблица 6.2</TD>
  <TR>
    <TD width=200>Рабочая станция </TD>
    <TD width=200>ОС </TD>
    <TD width=200>Окна </TD>
    <TD width=200>3D векторов/с</TD>
    <TD width=200>Полигонов/с</TD>
  <TR>
    <TD>
  <TR>
    <TD width=200>DN100X0 VS </TD>
    <TD width=200>Domain/OS </TD>
    <TD width=200>MOTIF</TD>
    <TD width=200>1 100 000</TD>
    <TD width=200>155 000</TD>
  <TR>
    <TD width=200>(APOLLO) </TD>
    <TD width=200>10.2 </TD>
    <TD width=200></TD>
    <TD width=200></TD>
    <TD width=200></TD>
  <TR>
    <TD width=200>Decstation 5000-200</TD>
    <TD width=200>Ultrix 4.0</TD>
    <TD width=200>MOTIF</TD>
    <TD width=200>400 000</TD>
    <TD width=200>100 000</TD>
  <TR>
    <TD width=200>PGX Turbo (DEC) </TD>
    <TD width=200></TD>
    <TD width=200></TD>
    <TD width=200></TD>
    <TD width=200></TD>
  <TR>
    <TD width=200>ESV 50 </TD>
    <TD width=200>Unix ES </TD>
    <TD width=200>MOTIF</TD>
    <TD width=200>1 080 000</TD>
    <TD width=200>100 000</TD>
  <TR>
    <TD width=200>(Evans&amp;Sutherland)</TD>
    <TD width=200></TD>
    <TD width=200>+ PEX</TD>
    <TD width=200></TD>
    <TD width=200></TD>
  <TR>
    <TD width=200>HP 9000/433s Turbo </TD>
    <TD width=200>HP-UX 7.05</TD>
    <TD width=200>MOTIF</TD>
    <TD width=200>1 000 000</TD>
    <TD width=200>300 000</TD>
  <TR>
    <TD width=200>VRX T3 (HP) </TD>
    <TD width=200>или Domain</TD>
    <TD width=200></TD>
    <TD width=200></TD>
    <TD width=200></TD>
  <TR>
    <TD width=200></TD>
    <TD width=200>/OS 10.3</TD>
    <TD width=200></TD>
    <TD width=200></TD>
    <TD width=200></TD>
  <TR>
    <TD width=200>RS 6000 Powersta- </TD>
    <TD width=200>AIX 3.1 </TD>
    <TD width=200>MOTIF</TD>
    <TD width=200>990 000</TD>
    <TD width=200>120 000</TD>
  <TR>
    <TD width=200>tion 730 (IBM) </TD>
    <TD width=200></TD>
    <TD width=200></TD>
    <TD width=200></TD>
    <TD width=200></TD>
  <TR>
    <TD width=200>Interpro 6280 </TD>
    <TD width=200>CLIX </TD>
    <TD width=200>MOTIF</TD>
    <TD width=200>400 000</TD>
    <TD width=200>30 000</TD>
  <TR>
    <TD width=200>(INTERGRAPH) </TD>
    <TD width=200></TD>
    <TD width=200></TD>&lt;td 
width="200</TR></TBODY></TABLE></CENTER></A></BODY></HTML>
