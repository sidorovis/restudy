<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0040)http://ermak.cs.nstu.ru/kg_rivs/kg02.htm -->
<HTML><HEAD><TITLE>Учебное пособие "Основные алгоритмы компьютерной графики"</TITLE>
<META content="text/html; charset=windows-1251" http-equiv=Content-Type>
<META content="MSHTML 5.00.2014.210" name=GENERATOR></HEAD>
<BODY aLink=#ff0000 
background="Учебное пособие Основные алгоритмы компьютерной графики_files/mainback.gif" 
bgColor=#ffffff bgProperties=fixed link=#0000ff text=#000000 vLink=#008000>
<TABLE align=center width="100%">
  <TBODY>
  <TR>
    <TD align=middle vAlign=top><IMG alt="Логотип НГТУ" border=0 height=100 
      hspace=10 
      src="Учебное пособие Основные алгоритмы компьютерной графики_files/logo.gif" 
      title=НГТУ width=135></TD>
    <TD align=left vAlign=center><A name=top title="Ваше учебное заведение">
      <H3>Новосибирский Государственный Технический Университет.<BR>Факультет 
      автоматики и вычислительной техники<BR>Кафедра вычислительной техники 
      (специальность 220100).</H3></A>
      <HR align=center SIZE=5 width="100%">
    </TD></TR></TBODY></TABLE>
<DIV align=center>
<H2><FONT color=#ff0000 face="">Учебное пособие "Основные алгоритмы компьютерной 
графики"</FONT></H2></DIV>
<P align=center title=""><B>МАШИННАЯ ГРАФИКА<BR>(Учебное пособие в 3-х 
книгах)<BR>Книга 2<BR><BR>П.В.Вельтмандер</B> </P>
<P>
<P><BR>Учебное пособие представляет собой семестровый курс лекций. Содержит 
описание основных алгоритмов двух- трехмерной машинной графики, включая 
алгоритмы реалистичного представления сцен. Важную часть пособия составляют 
практические реализации алгоритмов на языке С. Как правило, приводится несколько 
реализаций для каждого алгоритма, отличающихся различным выбором между 
наглядностью и эффективностью. Курс ориентирован на две основные категории 
будущих специалистов: 
<UL type=square>
  <LI>разработчики программно-технических средств машинной графики, 
  <LI>разработчики прикладных пакетов, приближенные к техническим средствам. 
  </LI></UL>
<P><BR>Курс разбит на три части, выпущенные в виде отдельных книг:<BR>
<OL>
  <LI><A href="http://ermak.cs.nstu.ru/kg_rivs/kg01.htm" 
  title='Учебное пособие "Вводный курс".'>Вводный курс.</A> 
  <LI><A href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm" 
  title='Учебное пособие "Алгоритмы компьютерной графики ".'>Алгоритмы 
  компьютерной графики.</A> 
  <LI><A href="http://ermak.cs.nstu.ru/kg_rivs/kg03.htm" 
  title='Учебное пособие "Архитектуры графических систем"'>Архитектуры 
  графических систем.</A> </LI></OL>
<P>
<CENTER>Рецензент<BR>канд. физ.-мат. наук, С.И.&nbsp;Упольников </CENTER>
<P align=right>ISBN&nbsp;&nbsp;ISBN 5-230-13606-5<BR>© Новосибирский 
государственный университет, 1997 
<H3>Оглавление </H3><A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#tth_ved">ВВЕДЕНИЕ</A><BR><A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#tth_sEc0.1">0.1&nbsp; КООРДИНАТЫ 
И ПРЕОБРАЗОВАНИЯ</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#tth_sEc0.1.1">0.1.1&nbsp; 
Двумерные преобразования</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#tth_sEc0.1.2">0.1.2&nbsp; 
Двумерные преобразования в однородных 
координатах</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#tth_sEc0.1.3">0.1.3&nbsp; 
Композиция двумерных преобразований</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#tth_sEc0.1.4">0.1.4&nbsp; 
Эффективность преобразований</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#tth_sEc0.1.5">0.1.5&nbsp; 
Трехмерные координаты</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#tth_sEc0.1.6">0.1.6&nbsp; 
Проекции</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#tth_sEc0.1.7">0.1.7&nbsp; 
Стереоизображения</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#tth_sEc0.1.8">0.1.8&nbsp; 
Геометрические преобразования растровых картин</A><BR><A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#tth_sEc0.2">0.2&nbsp; ГЕНЕРАЦИЯ 
ВЕКТОРОВ</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#tth_sEc0.2.1">0.2.1&nbsp; 
Цифровой дифференциальный анализатор</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#tth_sEc0.2.2">0.2.2&nbsp; 
Алгоритм Брезенхема</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#tth_sEc0.2.3">0.2.3&nbsp; 
Улучшение качества аппроксимации векторов</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#tth_sEc0.2.4">0.2.4&nbsp; 
Улучшение качества изображения фильтрацией</A><BR><A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#tth_sEc0.3">0.3&nbsp; ГЕНЕРАЦИЯ 
ОКРУЖНОСТИ</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#tth_sEc0.3.1">0.3.1&nbsp; 
Алгоритм Брезенхема</A><BR><A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#tth_sEc0.4">0.4&nbsp; ЗАПОЛНЕНИЕ 
МНОГОУГОЛЬНИКА</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#tth_sEc0.4.1">0.4.1&nbsp; 
Построчное заполнение</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#tth_sEc0.4.2">0.4.2&nbsp; 
Сортировка методом распределяющего подсчета</A><BR><A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#tth_sEc0.5">0.5&nbsp; ЗАЛИВКА 
ОБЛАСТИ С ЗАТРАВКОЙ</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#tth_sEc0.5.1">0.5.1&nbsp; Простой 
алгоритм заливки</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#tth_sEc0.5.2">0.5.2&nbsp; 
Построчный алгоритм заливки с затравкой</A><BR><A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#tth_sEc0.6">0.6&nbsp; ОТСЕЧЕНИЕ 
ОТРЕЗКОВ</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#tth_sEc0.6.1">0.6.1&nbsp; 
Двумерный алгоритм Коэна-Сазерленда</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#tth_sEc0.6.2">0.6.2&nbsp; 
Двумерный FC-алгоритм</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#tth_sEc0.6.3">0.6.3&nbsp; 
Двумерный алгоритм Лианга-Барски</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#tth_sEc0.6.4">0.6.4&nbsp; 
Двумерный алгоритм Кируса-Бека</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#tth_sEc0.6.5">0.6.5&nbsp; 
Сравнение алгоритмов двумерного отсечения</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#tth_sEc0.6.6">0.6.6&nbsp; 
Трехмерное отсечение отрезка</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#tth_sEc0.6.7">0.6.7&nbsp; 
Отсечение отрезка в однородных координатах</A><BR><A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#tth_sEc0.7">0.7&nbsp; ОТСЕЧЕНИЕ 
МНОГОУГОЛЬНИКА</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#tth_sEc0.7.1">0.7.1&nbsp; 
Алгоритм Сазерленда-Ходгмана</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#tth_sEc0.7.2">0.7.2&nbsp; Простой 
алгоритм отсечения многоугольника</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#tth_sEc0.7.3">0.7.3&nbsp; 
Алгоритм отсечения многоугольника Вейлера-Азертона</A><BR><A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#tth_sEc0.8">0.8&nbsp; СТРУКТУРЫ 
ДАННЫХ</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#tth_sEc0.8.1">0.8.1&nbsp; 
Последовательный доступ</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#tth_sEc0.8.2">0.8.2&nbsp; 
Непосредственный доступ</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#tth_sEc0.8.3">0.8.3&nbsp; 
Линейные списки</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#tth_sEc0.8.4">0.8.4&nbsp; 
Комбинированные списки</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#tth_sEc0.8.5">0.8.5&nbsp; 
Циклические списки</A><BR><A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#tth_sEc0.9">0.9&nbsp; 
ГЕОМЕТРИЧЕСКОЕ МОДЕЛИРОВАНИЕ</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#tth_sEc0.9.1">0.9.1&nbsp; 
Элементы моделей</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#tth_sEc0.9.2">0.9.2&nbsp; Методы 
построения моделей</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#tth_sEc0.9.3">0.9.3&nbsp; Типы 
моделей</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#tth_sEc0.9.4">0.9.4&nbsp; 
Полигональные сетки</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#tth_sEc0.9.5">0.9.5&nbsp; 
Внутреннее представление моделей</A><BR><A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#tth_sEc0.10">0.10&nbsp; УДАЛЕНИЕ 
СКРЫТЫХ ЛИНИЙ И ПОВЕРХНОСТЕЙ</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#tth_sEc0.10.1">0.10.1&nbsp; 
Классификация методов удаления невидимых 
частей</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#tth_sEc0.10.2">0.10.2&nbsp; 
Алгоритмы удаления линий</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#tth_sEc0.10.3">0.10.3&nbsp; 
Алгоритм удаления поверхностей с Z-буфером</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#tth_sEc0.10.4">0.10.4&nbsp; 
Построчный алгоритм с Z-буфером</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#tth_sEc0.10.5">0.10.5&nbsp; 
Алгоритм разбиения области Варнока</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#tth_sEc0.10.6">0.10.6&nbsp; 
Построчный алгоритм Уоткинса</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#tth_sEc0.10.7">0.10.7&nbsp; 
Алгоритм трассировки лучей</A><BR><A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#tth_sEc0.11">0.11&nbsp; 
РЕАЛИСТИЧНОЕ ПРЕДСТАВЛЕНИЕ СЦЕН</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#tth_sEc0.11.1">0.11.1&nbsp; 
Модели освещения</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#tth_sEc0.11.2">0.11.2&nbsp; 
Модели закраски</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#tth_sEc0.11.3">0.11.3&nbsp; 
Прозрачность</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#tth_sEc0.11.4">0.11.4&nbsp; 
Тени</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#tth_sEc0.11.5">0.11.5&nbsp; 
Фактура</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#tth_sEc0.11.6">0.11.6&nbsp; 
Трассировка лучей</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#tth_sEc0.11.7">0.11.7&nbsp; 
Излучательность</A><BR><A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#tth_bib">СПИСОК 
ЛИТЕРАТУРЫ</A><BR><A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#tth_sEc0.12">0.12&nbsp; 
Приложение 1. Процедуры преобразований</A><BR><A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#tth_sEc0.13">0.13&nbsp; 
Приложение 2. Процедуры генерации отрезков</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#tth_sEc0.13.1">0.13.1&nbsp; V_DDA 
- несимметричный ЦДА</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#tth_sEc0.13.2">0.13.2&nbsp; V_Bre 
- алгоритм Брезенхема</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#tth_sEc0.13.3">0.13.3&nbsp; 
V_BreM - модифицированный алгоритм Брезенхема</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#tth_sEc0.13.4">0.13.4&nbsp; 
T_VECTOR - тестовая программа генерации векторов</A><BR><A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#tth_sEc0.14">0.14&nbsp; 
Приложение 3. Процедуры фильтрации</A><BR><A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#tth_sEc0.15">0.15&nbsp; 
Приложение 4. Процедуры генерации окружности</A><BR><A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#tth_sEc0.16">0.16&nbsp; 
Приложение 5. Процедуры заполнения 
многоугольника</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#tth_sEc0.16.1">0.16.1&nbsp; V_FP0 
- простая процедура заливки многоугольника</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#tth_sEc0.16.2">0.16.2&nbsp; 
Тестовая процедуры V_FP0</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#tth_sEc0.16.3">0.16.3&nbsp; V_FP1 
- эффективная процедура заливки многоугольника</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#tth_sEc0.16.4">0.16.4&nbsp; 
Тестовая процедуры V_FP1</A><BR><A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#tth_sEc0.17">0.17&nbsp; 
Приложение 6. Процедуры заливки области</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#tth_sEc0.17.1">0.17.1&nbsp; 
V_FAB4R - рекурсивная заливка 4-x связной 
области</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#tth_sEc0.17.2">0.17.2&nbsp; Тест 
процедуры V_FAB4R</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#tth_sEc0.17.3">0.17.3&nbsp; 
V_FAB4 - итеративная заливка 4-x связной 
области</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#tth_sEc0.17.4">0.17.4&nbsp; Тест 
процедуры V_FAB4</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#tth_sEc0.17.5">0.17.5&nbsp; 
V_FAST - построчная заливка области</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#tth_sEc0.17.6">0.17.6&nbsp; Тест 
процедуры V_FAST</A><BR><A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#tth_sEc0.18">0.18&nbsp; 
Приложение 7. Процедуры отсечения отрезка</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#tth_sEc0.18.1">0.18.1&nbsp; 
V_SetPclip - установить многоугольник 
отсечения</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#tth_sEc0.18.2">0.18.2&nbsp; 
V_SetRclip - установить прямоугольник 
отсечения</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#tth_sEc0.18.3">0.18.3&nbsp; 
V_GetRclip - опросить прямоугольник отсечения</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#tth_sEc0.18.4">0.18.4&nbsp; 
V_CSclip - отсечение Коэна-Сазерленда</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#tth_sEc0.18.5">0.18.5&nbsp; 
V_FCclip - Fast Clipping-алгоритм</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#tth_sEc0.18.6">0.18.6&nbsp; 
V_LBclip - алгоритм Лианга-Барски</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#tth_sEc0.18.7">0.18.7&nbsp; 
V_CBclip - алгоритм Кируса-Бека</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#tth_sEc0.18.8">0.18.8&nbsp; Тест 
процедур отсечения</A><BR><A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#tth_sEc0.19">0.19&nbsp; 
Приложение 8. Процедуры отсечения 
многоугольника</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#tth_sEc0.19.1">0.19.1&nbsp; 
V_Plclip - простой алгоритм отсечения 
многоугольника</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#tth_sEc0.19.2">0.19.2&nbsp; Тест 
процедуры V_Plclip</A><BR>
<CENTER>
<H3><A name=tth_ved>ВВЕДЕНИЕ</H3></CENTER>
<P>Данная, вторая часть курса лекций посвящена рассмотрению основных алгоритмов 
машинной графики. 
<P>В разделе 1 рассматриваются алгоритмы выполнения преобразований в двумерных, 
трехмерных и однородных координатах; параллельные, перспективные и 
стереопроекции; плоские преобразования растровых картин. 
<P>В разделе 2 рассматриваются три алгоритма генерации векторов - обычного и 
несимметричного ЦДА и Брезенхема. Там же рассмотрены способы борьбы с лестничным 
эффектом, вызванным различимыми размерами пикселов на экране. Один из способов 
основан на модификации алгоритма Брезенхема. Другой, общий способ базируется на 
использовании низкочастотной фильтрации. Этот способ, естественно, применим для 
произвольных изображений. 
<P>В разделе 3 приводится алгоритм генерации окружностей. 
<P>В разделе 4 рассмотрены различные алгоритмы заполнения многоугольника, 
заданного координатами его вершин. Там же рассмотрен наиболее быстрый алгоритм 
сортировки - алгоритм распределяющего подсчета. 
<P>В разделе 5 рассмотрены алгоритмы заливки с затравкой произвольной области, 
заданной либо значением граничных пикселов, либо значением пикселов внутренней 
части области. 
<P>Раздел 6 посвящен различным алгоритмам отсечения отрезка (Коэна-Сазерленда, 
Собкова-Поспишила-Янга, Лианга-Барски и Кируса-Бека) применительно к двух, трех 
и четырехмерным координатам. 
<P>В разделе 7 рассмотрены алгоритмы отсечения многоугольника. 
<P>В разделе 8 рассмотрены различные варианты организации данных. 
<P>В разделе 9 рассматривается геометрическое моделирование объектов и сцен. 
<P>Раздел 10 посвящен рассмотрению алгоритмов удаления скрытых линий и 
поверхностей. 
<P>В разделе 11 рассмотрены методы и алгоритмы реалистичного представления сцен. 

<P>В приложениях помещены процедуры на языке С, реализующие большую часть 
рассмотренные алгоритмы, а также тестовые программы для большинства процедур. 
Основной целью при написании процедур было достижение наглядности, поэтому есть 
возможности их оптимизации. 
<P>
<CENTER>
<H3><A name=tth_sEc0.1>0.1</A>&nbsp;&nbsp;КООРДИНАТЫ И 
ПРЕОБРАЗОВАНИЯ</H3></CENTER>
<P>Описание, конструирование, манипулирование и представление геометрических 
объектов являются центральными работами в графических системах. Их поддержка в 
требуемом объеме за счет соответствующих математических методов, алгоритмов и 
программ оказывают существенное влияние на возможности и эффективность 
графической системы. В данном разделе будут рассмотрены математические методы 
для описания геометрических преобразований координат в двух, трех и 
четырехмерном случае, будут обсуждены некоторые вопросы эффективности, 
рассмотрены геометрические преобразования растровых картин. 
<P>Далее большими буквами X, &nbsp;&nbsp;Y, &nbsp;&nbsp;Z будут обозначаться 
обычные декартовые координаты, а маленькие буквы x, &nbsp;&nbsp;y, &nbsp;&nbsp;z 
будут использоваться для обозначения т.н. однородных координат. 
<P>
<CENTER>
<H3><A name=tth_sEc0.1.1>0.1.1</A>&nbsp;&nbsp;Двумерные 
преобразования</H3></CENTER>
<P><I>Преобразование сдвига</I> в плоском случае имеет вид: <A name=f2_1></A>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>Xn = X + Tx, Yn = Y + 
    Ty,</TD></TR></TBODY></TABLE></TD>
    <TD align=right width=100>(0.1.1)</TD></TR></TBODY></TABLE></CENTER>или в 
векторной форме: <A name=f2_2></A>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap><B>Pn</B> = <B>P</B> + 
        <B>T</B>,</TD></TR></TBODY></TABLE></TD>
    <TD align=right width=100>(0.1.2)</TD></TR></TBODY></TABLE></CENTER>где&nbsp;&macr; 
<B>Pn</B> = [Xn&nbsp;&nbsp;Yn]&nbsp;&macr; - &macr; вектор-строка преобразованных 
координат, где &nbsp;X,Y &nbsp;- &nbsp;исходные координаты точки,<BR>&nbsp;Tx,Ty 
&nbsp;- &nbsp;величина сдвига по осям,<BR>&nbsp;Xn,Yn &nbsp;- 
&nbsp;преобразованные координаты.<BR>&nbsp;<B>P</B> = [X&nbsp;&nbsp;Y] &nbsp;- 
&nbsp;вектор-строка исходных координат,<BR>&nbsp;<B>Pn</B> = [Xn&nbsp;&nbsp;Yn] 
&nbsp;- &nbsp;вектор-строка преобразованных координат,<BR>&nbsp;<B>T</B> = 
[Tx&nbsp;&nbsp;Ty] &nbsp;- &nbsp;вектор-строка сдвига. 
<P><I>Преобразование масштабирования</I> относительно начала координат имеет 
вид: <A name=f2_3></A>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>Xn = X ·Sx, Yn = Y 
    ·Sy,</TD></TR></TBODY></TABLE></TD>
    <TD align=right width=100>(0.1.3)</TD></TR></TBODY></TABLE></CENTER>или в 
матричной форме: <A name=f2_4></A>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>Pn = P ·S,</TD></TR></TBODY></TABLE></TD>
    <TD align=right width=100>(0.1.4)</TD></TR></TBODY></TABLE></CENTER>где Sx, Sy - 
коэффициенты масштабирования по осям, а 
<CENTER>
<P>S = [ </TD><TD nowrap>
<TABLE align=left border=0>
  <TBODY>
  <TR>
    <TD align=middle noWrap>
      <TABLE border=0>
        <TBODY>
        <TR>
          <TD align=middle noWrap>Sx </TD></TR></TBODY></TABLE></TD>
    <TD align=middle noWrap>
      <TABLE border=0>
        <TBODY>
        <TR>
          <TD align=middle noWrap>&nbsp;0</TD></TR></TBODY></TABLE></TD></TR>
  <TR>
    <TD align=middle colSpan=0 noWrap>
      <TABLE border=0>
        <TBODY>
        <TR>
          <TD align=middle noWrap>0&nbsp; </TD></TR></TBODY></TABLE></TD>
    <TD align=middle noWrap>
      <TABLE>
        <TBODY>
        <TR>
          <TD align=middle colSpan=0 
  noWrap>Sy</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></TD><TD nowrap>] - 
матрица&nbsp;&nbsp;масштабирования. </CENTER>
<P><I>Преобразование поворота</I> относительно начала координат имеет вид: <A 
name=f2_5></A>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>Xn = X ·cos<FONT face=symbol>f</FONT>- Y 
            ·sin<FONT face=symbol>f</FONT>, Yn = X ·sin<FONT 
            face=symbol>f</FONT>+ Y ·cos<FONT 
      face=symbol>f</FONT>,</TD></TR></TBODY></TABLE></TD>
    <TD align=right width=100>(0.1.5)</TD></TR></TBODY></TABLE></CENTER>или в 
матричной форме: <A name=f2_6></A>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>Pn = P ·R,</TD></TR></TBODY></TABLE></TD>
    <TD align=right width=100>(0.1.6)</TD></TR></TBODY></TABLE></CENTER>где <FONT 
face=symbol>f</FONT> - угол поворота, а 
<CENTER>
<P>R = [ </TD><TD nowrap>
<TABLE align=left border=0>
  <TBODY>
  <TR>
    <TD align=middle noWrap>
      <TABLE border=0>
        <TBODY>
        <TR>
          <TD align=middle noWrap>&nbsp;cos<FONT 
        face=symbol>f</FONT></TD></TR></TBODY></TABLE></TD>
    <TD align=middle noWrap>
      <TABLE border=0>
        <TBODY>
        <TR>
          <TD align=middle noWrap>sin<FONT 
      face=symbol>f</FONT></TD></TR></TBODY></TABLE></TD></TR>
  <TR>
    <TD align=middle colSpan=0 noWrap>
      <TABLE border=0>
        <TBODY>
        <TR>
          <TD align=middle noWrap>-sin<FONT 
      face=symbol>f</FONT></TD></TR></TBODY></TABLE></TD>
    <TD align=middle noWrap>
      <TABLE>
        <TBODY>
        <TR>
          <TD align=middle colSpan=0 noWrap>cos<FONT 
        face=symbol>f</FONT></TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></TD><TD 
nowrap>] - матрица поворота. </CENTER>
<P>Столбцы и строки матрицы поворота представляют собой взаимно ортогональные 
единичные векторы. В самом деле квадраты длин векторов-строк равны единице: 
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>cos<FONT face=symbol>f</FONT>·cos<FONT 
            face=symbol>f</FONT>+sin<FONT face=symbol>f</FONT>·sin<FONT 
            face=symbol>f</FONT> = 1 
и</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>(-sin<FONT face=symbol>f</FONT>) ·(-sin<FONT 
            face=symbol>f</FONT>)+cos<FONT face=symbol>f</FONT>·cos<FONT 
            face=symbol>f</FONT> = 
1,</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>а скалярное 
произведение векторов-строк есть 
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>cos<FONT face=symbol>f</FONT>·(-sin<FONT 
            face=symbol>f</FONT>) + sin<FONT face=symbol>f</FONT>·cos<FONT 
            face=symbol>f</FONT> = 
0.</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>
<P>Так как скалярное произведение векторов <B>A</B> ·<B>B</B> = <FONT 
face=symbol>|</FONT><B>A</B><FONT face=symbol>|</FONT> ·<FONT 
face=symbol>|</FONT><B>B</B><FONT face=symbol>|</FONT> ·cos<FONT 
face=symbol>y</FONT>, где <FONT face=symbol>|</FONT><B>A</B><FONT 
face=symbol>|</FONT> - длина вектора <B>A</B>, <FONT 
face=symbol>|</FONT><B>B</B><FONT face=symbol>|</FONT> - длина вектора <B>B</B>, 
а <FONT face=symbol>y</FONT> - наименьший положительный угол между ними, то из 
равенства 0 скалярного произведения двух векторов-строк длины 1 следует, что 
угол между ними равен 90<SUP><FONT face=symbol>°</FONT></SUP>. 
<P>Аналогичное можно показать и для векторов-столбцов. Кроме того 
вектора-столбцы представляют собой такие единичные векторы, которые после 
выполнения преобразования, заданного этой матрицей, совпадут с осями. В самом 
деле, произведение первого столбца на матрицу есть <A name=f2_7></A>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap></TD>
          <TD align=left><FONT face=symbol>щ<BR>ы </FONT></TD>
          <TD align=middle></TD>
          <TD noWrap>
            <TABLE align=left border=0>
              <TBODY>
              <TR>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>cos<FONT 
                    face=symbol>f</FONT></TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE>
                    <TBODY>
                    <TR>
                      <TD align=middle colSpan=0 noWrap>-sin<FONT 
                        face=symbol>f</FONT></TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></TD>
          <TD noWrap></TD>
          <TD align=left><FONT face=symbol>щ<BR>ы </FONT></TD>
          <TD align=middle>·</TD>
          <TD align=left><FONT face=symbol>щ<BR>ъ<BR>ы </FONT></TD>
          <TD align=middle></TD>
          <TD noWrap>
            <TABLE align=left border=0>
              <TBODY>
              <TR>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>&nbsp;cos<FONT 
                        face=symbol>f</FONT></TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>sin<FONT 
                    face=symbol>f</FONT></TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=middle colSpan=0 noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>-sin<FONT 
                    face=symbol>f</FONT></TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE>
                    <TBODY>
                    <TR>
                      <TD align=middle colSpan=0 noWrap>cos<FONT 
                        face=symbol>f</FONT></TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></TD>
          <TD noWrap></TD>
          <TD align=left><FONT face=symbol>щ<BR>ъ<BR>ы </FONT></TD>
          <TD align=middle>= </TD>
          <TD align=left><FONT face=symbol>щ<BR>ы </FONT></TD>
          <TD align=middle></TD>
          <TD noWrap>
            <TABLE align=left border=0>
              <TBODY>
              <TR>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>1 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE>
                    <TBODY>
                    <TR>
                      <TD align=middle colSpan=0 
                noWrap>0</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></TD>
          <TD noWrap></TD>
          <TD align=left><FONT face=symbol>щ<BR>ы </FONT></TD>
          <TD align=middle>,</TD></TR></TBODY></TABLE></TD>
    <TD align=right width=100>(0.1.7)</TD></TR></TBODY></TABLE></CENTER>
<P>т.е. это единичный вектор вдоль оси X. Аналогично, произведение второго 
столбца на матрицу даст вектор [&nbsp;0&nbsp;1&nbsp;]. Это позволяет 
сформировать матрицу, если известны результаты преобразования (см. пример в 
п.&nbsp;). 
<P>
<CENTER>
<H3><A name=tth_sEc0.1.2>0.1.2</A>&nbsp;&nbsp;Двумерные преобразования в 
однородных координатах</H3></CENTER>
<P>Как видно из (<A href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#f2_2">2</A>), 
(<A href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#f2_4">4</A>) и (<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#f2_6">6</A>) двумерные 
преобразования имеют различный вид. Сдвиг реализуется сложением, а 
масштабирование и поворот - умножением. Это различие затрудняет формирование 
суммарного преобразования и устраняется использованием двумерных однородных 
координат точки, имеющих вид: 
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle 
      noWrap>[&nbsp;x&nbsp;y&nbsp;w&nbsp;].</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>Здесь 
w - произвольный множитель не равный 0. 
<P>Двумерные декартовые координаты точки получаются из однородных делением на 
множитель w: <A name=f2_8></A>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>X = x / w, Y = y / w.</TD></TR></TBODY></TABLE></TD>
    <TD align=right width=100>(0.1.8)</TD></TR></TBODY></TABLE></CENTER>
<P>Однородные координаты можно представить как промасштабированные с 
коэффициентом w значения двумерных координат, расположенные в плоскости с Z = w. 

<P>В силу произвольности значения w в однородных координатах не существует 
единственного представления точки, заданной в декартовых координатах. 
<P>Преобразования сдвига, масштабирования и поворота в однородных координатах 
относительно центра координат все имеют одинаковую форму произведения вектора 
исходных координат на матрицу преобразования. 
<P>Для сдвига 
<P><A name=f2_9></A>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap></TD>
          <TD align=left><FONT face=symbol>щ<BR>ы </FONT></TD>
          <TD align=middle></TD>
          <TD noWrap>
            <TABLE align=left border=0>
              <TBODY>
              <TR>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>xn </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>yn </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE>
                    <TBODY>
                    <TR>
                      <TD align=middle colSpan=0 
                noWrap>wn</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></TD>
          <TD noWrap></TD>
          <TD align=left><FONT face=symbol>щ<BR>ы </FONT></TD>
          <TD align=middle>= </TD>
          <TD align=left><FONT face=symbol>щ<BR>ы </FONT></TD>
          <TD align=middle></TD>
          <TD noWrap>
            <TABLE align=left border=0>
              <TBODY>
              <TR>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>x </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>y </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE>
                    <TBODY>
                    <TR>
                      <TD align=middle colSpan=0 
                noWrap>w</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></TD>
          <TD noWrap></TD>
          <TD align=left><FONT face=symbol>щ<BR>ы </FONT></TD>
          <TD align=middle>·</TD>
          <TD align=left><FONT face=symbol>щ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ы 
          </FONT></TD>
          <TD align=middle></TD>
          <TD noWrap>
            <TABLE align=left border=0>
              <TBODY>
              <TR>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>1 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0</TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=middle colSpan=0 noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>1 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0</TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=middle colSpan=0 noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>Tx </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>Ty </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE>
                    <TBODY>
                    <TR>
                      <TD align=middle colSpan=0 
                noWrap>1</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></TD>
          <TD noWrap></TD>
          <TD align=left><FONT face=symbol>щ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ы 
          </FONT></TD>
          <TD align=middle>.</TD></TR></TBODY></TABLE></TD>
    <TD align=right width=100>(0.1.9)</TD></TR></TBODY></TABLE></CENTER>
<P>Для масштабирования 
<P><A name=f2_10></A>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap></TD>
          <TD align=left><FONT face=symbol>щ<BR>ы </FONT></TD>
          <TD align=middle></TD>
          <TD noWrap>
            <TABLE align=left border=0>
              <TBODY>
              <TR>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>xn </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>yn </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE>
                    <TBODY>
                    <TR>
                      <TD align=middle colSpan=0 
                noWrap>wn</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></TD>
          <TD noWrap></TD>
          <TD align=left><FONT face=symbol>щ<BR>ы </FONT></TD>
          <TD align=middle>= </TD>
          <TD align=left><FONT face=symbol>щ<BR>ы </FONT></TD>
          <TD align=middle></TD>
          <TD noWrap>
            <TABLE align=left border=0>
              <TBODY>
              <TR>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>x </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>y </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE>
                    <TBODY>
                    <TR>
                      <TD align=middle colSpan=0 
                noWrap>w</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></TD>
          <TD noWrap></TD>
          <TD align=left><FONT face=symbol>щ<BR>ы </FONT></TD>
          <TD align=middle>·</TD>
          <TD align=left><FONT face=symbol>щ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ы 
          </FONT></TD>
          <TD align=middle></TD>
          <TD noWrap>
            <TABLE align=left border=0>
              <TBODY>
              <TR>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>Sx </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0</TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=middle colSpan=0 noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>Sy </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0</TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=middle colSpan=0 noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE>
                    <TBODY>
                    <TR>
                      <TD align=middle colSpan=0 
                noWrap>1</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></TD>
          <TD noWrap></TD>
          <TD align=left><FONT face=symbol>щ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ы 
          </FONT></TD>
          <TD align=middle>.</TD></TR></TBODY></TABLE></TD>
    <TD align=right width=100>(0.1.10)</TD></TR></TBODY></TABLE></CENTER>
<P>Для поворота 
<P><A name=f2_11></A>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap></TD>
          <TD align=left><FONT face=symbol>щ<BR>ы </FONT></TD>
          <TD align=middle></TD>
          <TD noWrap>
            <TABLE align=left border=0>
              <TBODY>
              <TR>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>xn </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>yn </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE>
                    <TBODY>
                    <TR>
                      <TD align=middle colSpan=0 
                noWrap>wn</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></TD>
          <TD noWrap></TD>
          <TD align=left><FONT face=symbol>щ<BR>ы </FONT></TD>
          <TD align=middle>= </TD>
          <TD align=left><FONT face=symbol>щ<BR>ы </FONT></TD>
          <TD align=middle></TD>
          <TD noWrap>
            <TABLE align=left border=0>
              <TBODY>
              <TR>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>x </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>y </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE>
                    <TBODY>
                    <TR>
                      <TD align=middle colSpan=0 
                noWrap>w</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></TD>
          <TD noWrap></TD>
          <TD align=left><FONT face=symbol>щ<BR>ы </FONT></TD>
          <TD align=middle>·</TD>
          <TD align=left><FONT face=symbol>щ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ы 
          </FONT></TD>
          <TD align=middle></TD>
          <TD noWrap>
            <TABLE align=left border=0>
              <TBODY>
              <TR>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>cos<FONT 
                    face=symbol>f</FONT></TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>sin<FONT 
                    face=symbol>f</FONT></TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0</TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=middle colSpan=0 noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>-sin<FONT 
                    face=symbol>f</FONT></TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>cos<FONT 
                    face=symbol>f</FONT></TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0</TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=middle colSpan=0 noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE>
                    <TBODY>
                    <TR>
                      <TD align=middle colSpan=0 
                noWrap>1</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></TD>
          <TD noWrap></TD>
          <TD align=left><FONT face=symbol>щ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ы 
          </FONT></TD>
          <TD align=middle>.</TD></TR></TBODY></TABLE></TD>
    <TD align=right width=100>(0.1.11)</TD></TR></TBODY></TABLE></CENTER>
<P>Как видно из (<A href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#f2_9">9</A>) 
- (<A href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#f2_11">11</A>), wn = w, а 
матрица преобразования для двумерных однородных координат в общем случае имеет 
вид: <A name=f2_12></A>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap></TD>
          <TD align=left><FONT 
            face=symbol>щ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ы </FONT></TD>
          <TD align=middle></TD>
          <TD noWrap>
            <TABLE align=left border=0>
              <TBODY>
              <TR>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap></TD>
                      <TD noWrap>
                        <TABLE align=left border=0>
                          <TBODY>
                          <TR>
                            <TD align=middle noWrap>
                              <TABLE border=0>
                                <TBODY>
                                <TR>
                                <TD align=middle noWrap>A 
                              </TD></TR></TBODY></TABLE></TD>
                            <TD align=middle noWrap>
                              <TABLE border=0>
                                <TBODY>
                                <TR>
                                <TD align=middle 
                            noWrap>B</TD></TR></TBODY></TABLE></TD></TR>
                          <TR>
                            <TD align=middle colSpan=0 noWrap>
                              <TABLE border=0>
                                <TBODY>
                                <TR>
                                <TD align=middle noWrap>D 
                              </TD></TR></TBODY></TABLE></TD>
                            <TD align=middle noWrap>
                              <TABLE>
                                <TBODY>
                                <TR>
                                <TD align=middle colSpan=0 
                                noWrap>E</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></TD>
                      <TD noWrap></TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap></TD>
                      <TD noWrap>
                        <TABLE align=left border=0>
                          <TBODY>
                          <TR>
                            <TD align=middle noWrap>
                              <TABLE border=0>
                                <TBODY>
                                <TR>
                                <TD align=middle 
                            noWrap>P</TD></TR></TBODY></TABLE></TD></TR>
                          <TR>
                            <TD align=middle colSpan=0 noWrap>
                              <TABLE>
                                <TBODY>
                                <TR>
                                <TD align=middle colSpan=0 
                                noWrap>Q</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></TD>
                      <TD noWrap></TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=middle colSpan=0 noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap></TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap></TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=middle colSpan=0 noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap></TD>
                      <TD noWrap>
                        <TABLE align=left border=0>
                          <TBODY>
                          <TR>
                            <TD align=middle noWrap>
                              <TABLE border=0>
                                <TBODY>
                                <TR>
                                <TD align=middle noWrap>L 
                              </TD></TR></TBODY></TABLE></TD>
                            <TD align=middle noWrap>
                              <TABLE>
                                <TBODY>
                                <TR>
                                <TD align=middle colSpan=0 
                                noWrap>M</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></TD>
                      <TD noWrap></TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE>
                    <TBODY>
                    <TR>
                      <TD align=middle colSpan=0 
                noWrap>S</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></TD>
          <TD noWrap></TD>
          <TD align=left><FONT 
            face=symbol>щ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ы </FONT></TD>
          <TD align=middle>,</TD></TR></TBODY></TABLE></TD>
    <TD align=right width=100>(0.1.12)</TD></TR></TBODY></TABLE></CENTER>где 
элементы A, &nbsp;&nbsp;B, &nbsp;&nbsp;D и E определяют изменение масштаба, 
поворот и смещение, а L и M определяют сдвиг. Покажем, что элемент S определяет 
общее изменение масштаба, а элементы P и Q определяют проецирование. 
<P>Рассмотрим вначале для этого преобразование 
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap></TD>
          <TD align=left><FONT face=symbol>щ<BR>ы </FONT></TD>
          <TD align=middle></TD>
          <TD noWrap>
            <TABLE align=left border=0>
              <TBODY>
              <TR>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>xn </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>yn </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE>
                    <TBODY>
                    <TR>
                      <TD align=middle colSpan=0 
                noWrap>h</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></TD>
          <TD noWrap></TD>
          <TD align=left><FONT face=symbol>щ<BR>ы </FONT></TD>
          <TD align=middle>= </TD>
          <TD align=left><FONT face=symbol>щ<BR>ы </FONT></TD>
          <TD align=middle></TD>
          <TD noWrap>
            <TABLE align=left border=0>
              <TBODY>
              <TR>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>x </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>y </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE>
                    <TBODY>
                    <TR>
                      <TD align=middle colSpan=0 
                noWrap>1</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></TD>
          <TD noWrap></TD>
          <TD align=left><FONT face=symbol>щ<BR>ы </FONT></TD>
          <TD align=middle>·</TD>
          <TD align=left><FONT face=symbol>щ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ы 
          </FONT></TD>
          <TD align=middle></TD>
          <TD noWrap>
            <TABLE align=left border=0>
              <TBODY>
              <TR>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>1 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0</TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=middle colSpan=0 noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>1 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0</TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=middle colSpan=0 noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE>
                    <TBODY>
                    <TR>
                      <TD align=middle colSpan=0 
                noWrap>S</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></TD>
          <TD noWrap></TD>
          <TD align=left><FONT face=symbol>щ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ы 
          </FONT></TD>
          <TD align=middle>.</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>
<P>Легко видеть, что xn = x, &nbsp;&nbsp;yn = y, &nbsp;&nbsp;h = S. Таким 
образом двумерные декартовые координаты преобразованной точки 
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>Xn = xn / h = x / S, Yn = yn / h = y / 
        S,</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>т.е. такое 
преобразование задает изменение масштаба вектора положения точки. При S &lt; 1 
выполняется уменьшение, а при S &gt; 1 - увеличение. 
<P>Для уяснения смысла третьего столбца матрицы преобразований (<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#f2_12">12</A>) выполним 
преобразование 
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap></TD>
          <TD align=left><FONT face=symbol>щ<BR>ы </FONT></TD>
          <TD align=middle></TD>
          <TD noWrap>
            <TABLE align=left border=0>
              <TBODY>
              <TR>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>xn </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>yn </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE>
                    <TBODY>
                    <TR>
                      <TD align=middle colSpan=0 
                noWrap>h</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></TD>
          <TD noWrap></TD>
          <TD align=left><FONT face=symbol>щ<BR>ы </FONT></TD>
          <TD align=middle>= </TD>
          <TD align=left><FONT face=symbol>щ<BR>ы </FONT></TD>
          <TD align=middle></TD>
          <TD noWrap>
            <TABLE align=left border=0>
              <TBODY>
              <TR>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>x </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>y </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE>
                    <TBODY>
                    <TR>
                      <TD align=middle colSpan=0 
                noWrap>1</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></TD>
          <TD noWrap></TD>
          <TD align=left><FONT face=symbol>щ<BR>ы </FONT></TD>
          <TD align=middle>·</TD>
          <TD align=left><FONT face=symbol>щ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ы 
          </FONT></TD>
          <TD align=middle></TD>
          <TD noWrap>
            <TABLE align=left border=0>
              <TBODY>
              <TR>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>1 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>P</TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=middle colSpan=0 noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>1 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>Q</TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=middle colSpan=0 noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE>
                    <TBODY>
                    <TR>
                      <TD align=middle colSpan=0 
                noWrap>1</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></TD>
          <TD noWrap></TD>
          <TD align=left><FONT face=symbol>щ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ы 
          </FONT></TD>
          <TD align=middle>= </TD>
          <TD align=left><FONT face=symbol>щ<BR>ы </FONT></TD>
          <TD align=middle></TD>
          <TD noWrap>
            <TABLE align=left border=0>
              <TBODY>
              <TR>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>x </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>y </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE>
                    <TBODY>
                    <TR>
                      <TD align=middle colSpan=0 
                  noWrap>(Px+Qy+1)</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></TD>
          <TD noWrap></TD>
          <TD align=left><FONT face=symbol>щ<BR>ы </FONT></TD>
          <TD 
align=middle>.</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>Здесь 
xn = x, &nbsp;&nbsp;yn = y, &nbsp;&nbsp;h = Px + Qy + 1, т.е. переменная h, 
которая определяет плоскость, содержащую преобразованные точки, представленные в 
однородных координатах, образует теперь уравнение плоскости в трехмерном 
пространстве: <A name=f2_13></A>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>h = Px + Qy + 1.</TD></TR></TBODY></TABLE></TD>
    <TD align=right width=100>(0.1.13)</TD></TR></TBODY></TABLE></CENTER>
<P>Получим результирующие двумерные декартовые координаты Xn, Yn для 
преобразованной точки 
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>Xn = </TD>
          <TD align=middle noWrap>x
            <HR noShade>
             Px + Qy + 1<BR></TD>
          <TD align=middle noWrap>, Yn = </TD>
          <TD align=middle noWrap>y
            <HR noShade>
             Px + Qy + 1<BR></TD>
          <TD align=middle 
noWrap>.</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>Это 
соответствует вычислению их в плоскости Z = 1, т.е. проецированию из плоскости 
(<A href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#f2_13">13</A>) в плоскость Z 
= 1. Легко показать, что центр проецирования находится в начале координат. 
Рассмотрим для этого параметрические уравнения прямой, проходящей через точки 
(X<SUB>0</SUB>,&nbsp;Y<SUB>0</SUB>,&nbsp;1) и (X,&nbsp;Y,&nbsp;(MX+NY+1)&nbsp;): 
<A name=f2_14></A>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap></TD>
          <TD noWrap>
            <TABLE align=left border=0>
              <TBODY>
              <TR>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>X(t) = </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>X<SUB>0</SUB> 
                  </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>+ </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>(X-X<SUB>0</SUB>) &times;t 
                    </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>= </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>x/h </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>+ </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>(x - x/h) 
                &times;t</TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=middle colSpan=0 noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>Y(t) = </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>Y<SUB>0</SUB> 
                  </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>+ </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>(Y-Y<SUB>0</SUB>) &times;t 
                    </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>= </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>y/h </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>+ </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>(y - y/h) 
                &times;t</TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=middle colSpan=0 noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>Z(t) = </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>1 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>+ </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>(MX+NY) &times;t 
                </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>= </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>1 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>+ </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE>
                    <TBODY>
                    <TR>
                      <TD align=middle colSpan=0 noWrap>(h - 1) 
                    &times;t</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></TD>
          <TD noWrap>.</TD></TR></TBODY></TABLE></TD>
    <TD align=right width=100>(0.1.14)</TD></TR></TBODY></TABLE></CENTER>Из условия 
X(t) = X<SUB>0</SUB> = 0 находим t = 1/(1 - h), подставляя это значение t в 
выражения для Y(t) и Z(t), получим: 
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>Y<SUB>0</SUB> = y/h + (y - y/h)/(1-h) = y/h 
            - y/h = 0.</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>Z<SUB>0</SUB> = 1 + (h-1)/(1-h) = 
        0.</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>Итак, показано, 
что элементы P и Q матрицы (<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#f2_12">12</A>) определяют 
проецирование с центром проекции в начале координат. 
<P>Кроме удобств, связанных с единообразным представлением преобразований, и, 
следовательно, с упрощением композиции преобразований, рассматриваемой в 
следующем пункте, однородные координаты дают возможность простого представления 
точек, имеющих в декартовой системе значение координаты, равное бесконечности. 
<P>
<CENTER>
<H4>Декартовые точки с бесконечными координатами</H4></CENTER>
<P>Рассмотрим в декартовой системе линию, проходящую через начало координат и 
точку (X,Y). Однородные координаты этой точки - (x,y,h) = (hX, hY, h), где h 
имеет произвольное значение. Предел отношения x/y при h стремящимся к 0 равен 
X/Y, но при этом декартовые координаты стремятся к бесконечности. Таким образом, 
точка с однородными координатами <A name=f2_15></A>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>(x,&nbsp;y,&nbsp;0)</TD></TR></TBODY></TABLE></TD>
    <TD align=right width=100>(0.1.15)</TD></TR></TBODY></TABLE></CENTER>задает в 
декартовой системе точку на бесконечности для рассмотренной прямой. В частности, 
точка с однородными координатами (1, 0, 0) задает бесконечную точку на 
декартовой оси X, а точка с однородными координатами (0, 1, 0) задает 
бесконечную точку на декартовой оси Y. 
<P>
<CENTER>
<H4>Параллельные прямые</H4></CENTER>
<P>Покажем, что прямые, параллельные в декартовой системе координат, в 
однородных координатах имеют точку пересечения. Эта особенность далее будет 
использована при анализе перспективных преобразований. 
<P>Пусть две пересекающиеся прямые в декартовой системе координат заданы 
системой уравнений: 
<P><A name=f2_16></A>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap></TD>
          <TD noWrap>
            <TABLE align=left border=0>
              <TBODY>
              <TR>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>A<SUB>1</SUB> ·X + B<SUB>1</SUB> 
                        ·Y + C<SUB>1</SUB> = 0</TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=middle colSpan=0 noWrap>
                  <TABLE>
                    <TBODY>
                    <TR>
                      <TD align=middle colSpan=0 noWrap>A<SUB>2</SUB> ·X + 
                        B<SUB>2</SUB> ·Y + C<SUB>2</SUB> = 
                0.</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></TD>
          <TD noWrap></TD></TR></TBODY></TABLE></TD>
    <TD align=right width=100>(0.1.16)</TD></TR></TBODY></TABLE></CENTER>
<P>Решая эту систему относительно X и Y, найдем координаты точки пересечения 
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>X<SUB>0</SUB> = </TD>
          <TD align=middle noWrap>C<SUB>1</SUB> ·B<SUB>2</SUB>-C<SUB>2</SUB> 
            ·B<SUB>1</SUB>
            <HR noShade>
             A<SUB>1</SUB> ·B<SUB>2</SUB>-A<SUB>2</SUB> ·B<SUB>1</SUB><BR></TD>
          <TD align=middle 
noWrap>.</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>Y<SUB>0</SUB> = </TD>
          <TD align=middle noWrap>A<SUB>1</SUB> ·C<SUB>2</SUB>-A<SUB>2</SUB> 
            ·C<SUB>1</SUB>
            <HR noShade>
             A<SUB>1</SUB> ·B<SUB>2</SUB>-A<SUB>2</SUB> ·B<SUB>1</SUB><BR></TD>
          <TD align=middle 
noWrap>.</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>
<P>Запишем результат в однородных координатах 
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap></TD>
          <TD align=left><FONT face=symbol>ц<BR>ч<BR>ш </FONT></TD>
          <TD align=middle></TD>
          <TD align=middle noWrap>C<SUB>1</SUB> ·B<SUB>2</SUB>-C<SUB>2</SUB> 
            ·B<SUB>1</SUB>
            <HR noShade>
             A<SUB>1</SUB> ·B<SUB>2</SUB>-A<SUB>2</SUB> ·B<SUB>1</SUB><BR></TD>
          <TD align=middle noWrap>,&nbsp; </TD>
          <TD align=middle noWrap>A<SUB>1</SUB> ·C<SUB>2</SUB>-A<SUB>2</SUB> 
            ·C<SUB>1</SUB>
            <HR noShade>
             A<SUB>1</SUB> ·B<SUB>2</SUB>-A<SUB>2</SUB> ·B<SUB>1</SUB><BR></TD>
          <TD align=middle noWrap>, &nbsp;1</TD>
          <TD align=left><FONT face=symbol>ц<BR>ч<BR>ш </FONT></TD>
          <TD align=middle>.</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>
<P>В силу произвольности масштабного множителя, умножим значения координат на 
(A<SUB>1</SUB> ·B<SUB>2</SUB> - A<SUB>2</SUB> ·B<SUB>1</SUB>) 
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>(C<SUB>1</SUB> ·B<SUB>2</SUB>-C<SUB>2</SUB> 
            ·B<SUB>1</SUB>,&nbsp; A<SUB>1</SUB> ·C<SUB>2</SUB>-A<SUB>2</SUB> 
            ·C<SUB>1</SUB>,&nbsp; A<SUB>1</SUB> ·B<SUB>2</SUB>-A<SUB>2</SUB> 
            ·B<SUB>1</SUB>).</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>Если 
прямые параллельны, то определитель системы (<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#f2_16">16</A>) - (A<SUB>1</SUB> 
·B<SUB>2</SUB>-A<SUB>2</SUB> ·B<SUB>1</SUB>) равен нулю. Учитывая это и 
обозначая x<SUB>0</SUB> = (C<SUB>1</SUB> ·B<SUB>2</SUB>-C<SUB>2</SUB> 
·B<SUB>1</SUB>), y<SUB>0</SUB> = (A<SUB>1</SUB> ·C<SUB>2</SUB>-A<SUB>2</SUB> 
·C<SUB>1</SUB>), получим координату пересечения параллельных прямых в однородной 
системе координат 
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle 
            noWrap>(&nbsp;x<SUB>0</SUB>,&nbsp;y<SUB>0</SUB>,&nbsp;0&nbsp;).</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>
<P>При этом точка пересечения лежит на прямой -y<SUB>0</SUB> ·x + x<SUB>0</SUB> 
·y = 0 на бесконечности. 
<P>
<CENTER>
<H3><A name=tth_sEc0.1.3>0.1.3</A>&nbsp;&nbsp;Композиция двумерных 
преобразований</H3></CENTER>
<P>Последовательное выполнение нескольких преобразований можно представить в 
виде единой матрицы суммарного преобразования. Умножение на единственную 
матрицу, естественно, выполняется быстрее, чем последовательное умножение на 
несколько матриц. 
<P>Рассмотрим сдвиг точки P<SUB>0</SUB> на расстояние (Tx<SUB>1</SUB>, 
Ty<SUB>1</SUB>) в точку P<SUB>1</SUB>, а затем сдвинем точку P<SUB>1</SUB> на 
расстояние (Tx<SUB>2</SUB>, Ty<SUB>2</SUB>) в точку P<SUB>2</SUB>. Обозначая 
через T<SUB>1</SUB> и T<SUB>2</SUB> матрицы сдвига, в соответствии с (<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#f2_9">9</A>) получим: 
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>P<SUB>1</SUB> = P<SUB>0</SUB> 
            ·T<SUB>1</SUB>; &nbsp;P<SUB>2</SUB> = P<SUB>1</SUB> ·T<SUB>2</SUB> 
            &nbsp; = &nbsp; (P<SUB>0</SUB> ·T<SUB>1</SUB>) ·T<SUB>2</SUB> &nbsp; 
            = &nbsp; P<SUB>0</SUB> ·(T<SUB>1</SUB> ·T<SUB>2</SUB>) &nbsp; = 
            &nbsp;P<SUB>0</SUB> 
·T.</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>Понятно, что 
сдвиг аддитивен, т.е. последовательное выполнение двух сдвигов должно быть 
эквивалентно одному сдвигу на расстояние (Tx<SUB>1</SUB>+Tx<SUB>2</SUB>, 
Ty<SUB>1</SUB>+Ty<SUB>2</SUB>). Для доказательства этого рассмотрим произведение 
матриц сдвига T<SUB>1</SUB> и T<SUB>2</SUB>, равное 
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>T = </TD>
          <TD align=left><FONT face=symbol>щ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ы 
          </FONT></TD>
          <TD align=middle></TD>
          <TD noWrap>
            <TABLE align=left border=0>
              <TBODY>
              <TR>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>1 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0</TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=middle colSpan=0 noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>1 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0</TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=middle colSpan=0 noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>Tx<SUB>1</SUB> 
                  </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>Ty<SUB>1</SUB> 
                  </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE>
                    <TBODY>
                    <TR>
                      <TD align=middle colSpan=0 
                noWrap>1</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></TD>
          <TD noWrap></TD>
          <TD align=left><FONT face=symbol>щ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ы 
          </FONT></TD>
          <TD align=middle>·</TD>
          <TD align=left><FONT face=symbol>щ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ы 
          </FONT></TD>
          <TD align=middle></TD>
          <TD noWrap>
            <TABLE align=left border=0>
              <TBODY>
              <TR>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>1 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0</TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=middle colSpan=0 noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>1 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0</TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=middle colSpan=0 noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>Tx<SUB>2</SUB> 
                  </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>Ty<SUB>2</SUB> 
                  </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE>
                    <TBODY>
                    <TR>
                      <TD align=middle colSpan=0 
                noWrap>1</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></TD>
          <TD noWrap></TD>
          <TD align=left><FONT face=symbol>щ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ы 
          </FONT></TD>
          <TD align=middle>= </TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap></TD>
          <TD align=left><FONT face=symbol>щ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ы 
          </FONT></TD>
          <TD align=middle></TD>
          <TD noWrap>
            <TABLE align=left border=0>
              <TBODY>
              <TR>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>1 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0</TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=middle colSpan=0 noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>1 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0</TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=middle colSpan=0 noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>Tx<SUB>1</SUB>+Tx<SUB>2</SUB> 
                    </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>Ty<SUB>1</SUB>+Ty<SUB>2</SUB> 
                    </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE>
                    <TBODY>
                    <TR>
                      <TD align=middle colSpan=0 
                noWrap>1</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></TD>
          <TD noWrap></TD>
          <TD align=left><FONT face=symbol>щ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ы 
          </FONT></TD>
          <TD 
align=middle>.</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>Итак, 
получили, что результирующий сдвиг есть 
(Tx<SUB>1</SUB>+Tx<SUB>2</SUB>,&nbsp;Ty<SUB>1</SUB>+Ty<SUB>2</SUB>), т.е. 
суммарный сдвиг, вычисленный как произведение матриц, как и ожидалось, 
аддитивен. 
<P>Рассмотрим теперь последовательное выполнение масштабирований, первое с 
коэффициентами (Sx<SUB>1</SUB>,&nbsp;Sy<SUB>1</SUB>), второе с коэффициентами 
(Sx<SUB>2</SUB>,&nbsp;Sy<SUB>2</SUB>). Следует ожидать, что суммарное 
масштабирование будет мультипликативным. Обозначая через S<SUB>1</SUB> и 
S<SUB>2</SUB> матрицы масштабирования, в соответствии с (<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#f2_10">10</A>) получим 
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>P<SUB>1</SUB> = P<SUB>0</SUB> 
            ·S<SUB>1</SUB>, &nbsp; P<SUB>2</SUB> = P<SUB>1</SUB> ·S<SUB>2</SUB> 
            &nbsp; = &nbsp;(P<SUB>0</SUB> ·S<SUB>1</SUB>) ·S<SUB>2</SUB> &nbsp; 
            = &nbsp; P<SUB>0</SUB> ·(S<SUB>1</SUB> ·S<SUB>2</SUB>) = 
            P<SUB>0</SUB> 
·S.</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>Найдем значения 
элементов матрицы S 
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>S = </TD>
          <TD align=left><FONT face=symbol>щ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ы 
          </FONT></TD>
          <TD align=middle></TD>
          <TD noWrap>
            <TABLE align=left border=0>
              <TBODY>
              <TR>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle 
                  noWrap>Sx<SUB>1</SUB></TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0</TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=middle colSpan=0 noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>Sy<SUB>1</SUB> 
                  </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0</TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=middle colSpan=0 noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE>
                    <TBODY>
                    <TR>
                      <TD align=middle colSpan=0 
                noWrap>1</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></TD>
          <TD noWrap></TD>
          <TD align=left><FONT face=symbol>щ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ы 
          </FONT></TD>
          <TD align=middle>·</TD>
          <TD align=left><FONT face=symbol>щ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ы 
          </FONT></TD>
          <TD align=middle></TD>
          <TD noWrap>
            <TABLE align=left border=0>
              <TBODY>
              <TR>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle 
                  noWrap>Sx<SUB>2</SUB></TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0</TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=middle colSpan=0 noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>Sy<SUB>2</SUB> 
                  </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0</TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=middle colSpan=0 noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE>
                    <TBODY>
                    <TR>
                      <TD align=middle colSpan=0 
                noWrap>1</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></TD>
          <TD noWrap></TD>
          <TD align=left><FONT face=symbol>щ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ы 
          </FONT></TD>
          <TD align=middle>= </TD>
          <TD align=left><FONT face=symbol>щ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ы 
          </FONT></TD>
          <TD align=middle></TD>
          <TD noWrap>
            <TABLE align=left border=0>
              <TBODY>
              <TR>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>Sx<SUB>1</SUB> ·Sx<SUB>2</SUB> 
                      </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0</TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=middle colSpan=0 noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>Sy<SUB>1</SUB> ·Sy<SUB>2</SUB> 
                      </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0</TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=middle colSpan=0 noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE>
                    <TBODY>
                    <TR>
                      <TD align=middle colSpan=0 
                noWrap>1</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></TD>
          <TD noWrap></TD>
          <TD align=left><FONT face=symbol>щ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ы 
          </FONT></TD>
          <TD align=middle>.</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>
<P>Итак, получили, что результирующее масштабирование есть (Sx<SUB>1</SUB> 
·Sx<SUB>2</SUB>, &nbsp;Sy<SUB>1</SUB> ·Sy<SUB>2</SUB>), т.е. суммарное 
масштабирование, вычисленное как произведение матриц, как и ожидалось, 
мультипликативно. 
<P>Аналогичным образом можно показать, что два последовательных поворота 
аддитивны. 
<P>Рассмотрим выполнение часто используемого поворота изображения на угол <FONT 
face=symbol>f</FONT> относительно заданной точки P(X,Y). Это преобразование 
можно представить как перенос начала координат в точку (X,Y), поворот на угол 
<FONT face=symbol>f</FONT> относительно начала координат и обратный перенос 
начала координат: 
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>Pn = P ·T(-X,-Y) ·R(<FONT 
            face=symbol>f</FONT>) ·T(X,Y). 
</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>С использованием 
преобразований в однородных координатах, суммарное преобразование будет иметь 
простой вид: 
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap></TD>
          <TD align=left><FONT face=symbol>щ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ы 
          </FONT></TD>
          <TD align=middle></TD>
          <TD noWrap>
            <TABLE align=left border=0>
              <TBODY>
              <TR>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>1 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0</TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=middle colSpan=0 noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>1 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0</TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=middle colSpan=0 noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>-X </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>-Y </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE>
                    <TBODY>
                    <TR>
                      <TD align=middle colSpan=0 
                noWrap>1</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></TD>
          <TD noWrap></TD>
          <TD align=left><FONT face=symbol>щ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ы 
          </FONT></TD>
          <TD align=middle>·</TD>
          <TD align=left><FONT face=symbol>щ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ы 
          </FONT></TD>
          <TD align=middle></TD>
          <TD noWrap>
            <TABLE align=left border=0>
              <TBODY>
              <TR>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>cos<FONT 
                    face=symbol>f</FONT></TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>sin<FONT 
                    face=symbol>f</FONT></TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0</TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=middle colSpan=0 noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>-sin<FONT 
                    face=symbol>f</FONT></TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>cos<FONT 
                    face=symbol>f</FONT></TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0</TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=middle colSpan=0 noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE>
                    <TBODY>
                    <TR>
                      <TD align=middle colSpan=0 
                noWrap>1</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></TD>
          <TD noWrap></TD>
          <TD align=left><FONT face=symbol>щ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ы 
          </FONT></TD>
          <TD align=middle>·</TD>
          <TD align=left><FONT face=symbol>щ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ы 
          </FONT></TD>
          <TD align=middle></TD>
          <TD noWrap>
            <TABLE align=left border=0>
              <TBODY>
              <TR>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>1 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0</TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=middle colSpan=0 noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>1 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0</TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=middle colSpan=0 noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>X </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>Y </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE>
                    <TBODY>
                    <TR>
                      <TD align=middle colSpan=0 
                noWrap>1</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></TD>
          <TD noWrap></TD>
          <TD align=left><FONT face=symbol>щ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ы 
          </FONT></TD>
          <TD align=middle>.</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>
<P>
<CENTER>
<H3><A name=tth_sEc0.1.4>0.1.4</A>&nbsp;&nbsp;Эффективность 
преобразований</H3></CENTER>
<P>Суммарная матрица двумерных преобразований в однородных координатах имеет 
вид: 
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap></TD>
          <TD align=left><FONT face=symbol>щ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ы 
          </FONT></TD>
          <TD align=middle></TD>
          <TD noWrap>
            <TABLE align=left border=0>
              <TBODY>
              <TR>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>A </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>B </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0</TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=middle colSpan=0 noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>D </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>E </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0</TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=middle colSpan=0 noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>L </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>M </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE>
                    <TBODY>
                    <TR>
                      <TD align=middle colSpan=0 
                noWrap>1</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></TD>
          <TD noWrap></TD>
          <TD align=left><FONT face=symbol>щ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ы 
          </FONT></TD>
          <TD 
align=middle>,</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>где 
элементы A, &nbsp;&nbsp;B, &nbsp;&nbsp;D и E, отвечающие за изменение масштаба, 
поворот и смещение, - объединенная матрица масштабирования и поворота, а L и M 
определяют суммарный сдвиг. 
<P>Вычисление преобразованных однородных координат точки P с непосредственным 
использованием T в выражении P ·T требует 9 операций умножения и 6 операций 
сложения. Но так как третья однородная координата может быть выбрана равной 1, а 
третий столбец T содержит единственный ненулевой элемент, равный 1, то 
преобразование декартовых координат может быть представлено в виде: 
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>Xn = X ·A + Y ·D + L, Yn = X ·B + Y ·E + 
          M,</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>что требует уже 
только 4 операции умножения и 4 операции сложения, что существенно меньше. Таким 
образом, несмотря на то, что матрицы 3&times;3 удобны при вычислении суммарного 
преобразования, выполнение фактического преобразования координат следует 
производить с учетом реальной структуры матрицы преобразования. 
<P>
<CENTER>
<H3><A name=tth_sEc0.1.5>0.1.5</A>&nbsp;&nbsp;Трехмерные координаты</H3><A 
name=p2_5></A></CENTER>
<P>Далее при рассмотрении трехмерных преобразований, в основном, используется 
общепринятая в векторной алгебре правая система координат (рис.&nbsp;а). При 
этом, если смотреть со стороны положительной полуоси в центр координат, то 
поворот на +90<SUP><FONT face=symbol>°</FONT></SUP> (против часовой стрелке) 
переводит одну положительную ось в другую (направление движения расположенного 
вдоль оси и поворачивающегося против часовой стрелки правого винта и 
положительной полуоси совпадают). В некоторых, специально оговариваемых случаях, 
используется левая система координат (см. рис.&nbsp;б). В левой системе 
координат положительными будут повороты по часовой стрелке, если смотреть с 
положительного конца полуоси. В трехмерной машинной графике более удобной 
является левая система координат. Тогда если, например, поверхность экрана 
совмещена с плоскостью XY, то большим удалениям от наблюдателя соответствую 
точки с большим значением Z (см. рис.&nbsp;б). 
<P><A name=tth_fIg0.1></A>
<P><A name=r02_01>
<CENTER><BR><IMG alt="Рисунок 1" 
src="Учебное пособие Основные алгоритмы компьютерной графики_files/kg0201.gif">
<P></CENTER>
<CENTER>Рис. 0.1.1: Правая а) и левая б) системы координат</CENTER></A>
<P>
<P>Работа с однородными трехмерными координатами и матрицами преобразования 
(формирование и композциция) подобна таковой для двумерного случая, поэтому 
здесь будут рассмотрены только матрицы преобразований сдвига, масштабирования и 
поворота и пример конструирования матрицы преобразования по известному его 
результату. 
<P>Подобно тому как в двумерном случае точка в однородных координатах 
представляется трехмерным вектором [&nbsp;x&nbsp;y&nbsp;w&nbsp;], а матрицы 
преобразований имеют размер 3&times;3, для трехмерного случая точка представляется 
четырехмерным вектором [&nbsp;x&nbsp;y&nbsp;z&nbsp;w&nbsp;], где w не равно 0, а 
матрицы преобразований имеют размер 4&times;4. Если w не равно 1, то декартовые 
координаты точки (X,Y,Z) получаются из соотношения: 
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle 
            noWrap>[&nbsp;&nbsp;X&nbsp;&nbsp;Y&nbsp;&nbsp;Z&nbsp;&nbsp;1&nbsp;&nbsp;] 
            = 
            [&nbsp;&nbsp;(x/w)&nbsp;&nbsp;(y/w)&nbsp;&nbsp;(z/w)&nbsp;&nbsp;1&nbsp;&nbsp;].</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>Преобразование 
в однородных координатах описывается соотношением 
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>[&nbsp;xn&nbsp;yn&nbsp;zn&nbsp;wn &nbsp;] = 
            [&nbsp;x&nbsp;y&nbsp;z&nbsp;w&nbsp;] 
  ·T.</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>Матрица 
преобразования T в общем случае имеет вид 
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap></TD>
          <TD align=left><FONT 
            face=symbol>щ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ы 
            </FONT></TD>
          <TD align=middle></TD>
          <TD noWrap>
            <TABLE align=left border=0>
              <TBODY>
              <TR>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap></TD>
                      <TD noWrap>
                        <TABLE align=left border=0>
                          <TBODY>
                          <TR>
                            <TD align=middle noWrap>
                              <TABLE border=0>
                                <TBODY>
                                <TR>
                                <TD align=middle noWrap>A 
                              </TD></TR></TBODY></TABLE></TD>
                            <TD align=middle noWrap>
                              <TABLE border=0>
                                <TBODY>
                                <TR>
                                <TD align=middle noWrap>B 
                              </TD></TR></TBODY></TABLE></TD>
                            <TD align=middle noWrap>
                              <TABLE border=0>
                                <TBODY>
                                <TR>
                                <TD align=middle 
                            noWrap>C</TD></TR></TBODY></TABLE></TD></TR>
                          <TR>
                            <TD align=middle colSpan=0 noWrap>
                              <TABLE border=0>
                                <TBODY>
                                <TR>
                                <TD align=middle noWrap>D 
                              </TD></TR></TBODY></TABLE></TD>
                            <TD align=middle noWrap>
                              <TABLE border=0>
                                <TBODY>
                                <TR>
                                <TD align=middle noWrap>E 
                              </TD></TR></TBODY></TABLE></TD>
                            <TD align=middle noWrap>
                              <TABLE border=0>
                                <TBODY>
                                <TR>
                                <TD align=middle 
                            noWrap>F</TD></TR></TBODY></TABLE></TD></TR>
                          <TR>
                            <TD align=middle colSpan=0 noWrap>
                              <TABLE border=0>
                                <TBODY>
                                <TR>
                                <TD align=middle noWrap>I 
                              </TD></TR></TBODY></TABLE></TD>
                            <TD align=middle noWrap>
                              <TABLE border=0>
                                <TBODY>
                                <TR>
                                <TD align=middle noWrap>J 
                              </TD></TR></TBODY></TABLE></TD>
                            <TD align=middle noWrap>
                              <TABLE>
                                <TBODY>
                                <TR>
                                <TD align=middle colSpan=0 
                                noWrap>K</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></TD>
                      <TD noWrap></TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap></TD>
                      <TD noWrap>
                        <TABLE align=left border=0>
                          <TBODY>
                          <TR>
                            <TD align=middle noWrap>
                              <TABLE border=0>
                                <TBODY>
                                <TR>
                                <TD align=middle 
                            noWrap>P</TD></TR></TBODY></TABLE></TD></TR>
                          <TR>
                            <TD align=middle colSpan=0 noWrap>
                              <TABLE border=0>
                                <TBODY>
                                <TR>
                                <TD align=middle 
                            noWrap>Q</TD></TR></TBODY></TABLE></TD></TR>
                          <TR>
                            <TD align=middle colSpan=0 noWrap>
                              <TABLE>
                                <TBODY>
                                <TR>
                                <TD align=middle colSpan=0 
                                noWrap>R</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></TD>
                      <TD noWrap></TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=middle colSpan=0 noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap></TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap></TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=middle colSpan=0 noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap></TD>
                      <TD noWrap>
                        <TABLE align=left border=0>
                          <TBODY>
                          <TR>
                            <TD align=middle noWrap>
                              <TABLE border=0>
                                <TBODY>
                                <TR>
                                <TD align=middle noWrap>L 
                              </TD></TR></TBODY></TABLE></TD>
                            <TD align=middle noWrap>
                              <TABLE border=0>
                                <TBODY>
                                <TR>
                                <TD align=middle noWrap>M 
                              </TD></TR></TBODY></TABLE></TD>
                            <TD align=middle noWrap>
                              <TABLE>
                                <TBODY>
                                <TR>
                                <TD align=middle colSpan=0 
                                noWrap>N</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></TD>
                      <TD noWrap></TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE>
                    <TBODY>
                    <TR>
                      <TD align=middle colSpan=0 
                noWrap>S</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></TD>
          <TD noWrap></TD>
          <TD align=left><FONT 
            face=symbol>щ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ы 
            </FONT></TD>
          <TD 
align=middle>.</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>Подматрица 
3&times;3 определяет суммарные смещение, масштабирование и поворот. Подматрица-строка 
1&times;3 - [&nbsp;L&nbsp;M&nbsp;N&nbsp;] задает сдвиг. Подматрица-столбец 3&times;1 - 
[&nbsp;P&nbsp;Q&nbsp;R&nbsp;] отвечает за преобразование в перспективе. 
Последний скалярный элемент - S определяет общее изменение масштаба. 
<P>В частности, матрица сдвига имеет вид: 
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>T(Tx, Ty, Tz) = </TD>
          <TD align=left><FONT face=symbol>щ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ы 
            </FONT></TD>
          <TD align=middle></TD>
          <TD noWrap>
            <TABLE align=left border=0>
              <TBODY>
              <TR>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>1 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0</TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=middle colSpan=0 noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>1 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0</TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=middle colSpan=0 noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>1 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0</TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=middle colSpan=0 noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>Tx </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>Ty </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>Tz </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE>
                    <TBODY>
                    <TR>
                      <TD align=middle colSpan=0 
                noWrap>1</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></TD>
          <TD noWrap></TD>
          <TD align=left><FONT face=symbol>щ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ы 
            </FONT></TD>
          <TD 
align=middle>.</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>Матрица 
обратного преобразования для сдвига получается путем смены знака у Tx, Ty и Tz. 
<P>Матрица масштабирования относительно центра координат имеет вид: 
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>S(Sx, Sy, Sz) = </TD>
          <TD align=left><FONT face=symbol>щ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ы 
            </FONT></TD>
          <TD align=middle></TD>
          <TD noWrap>
            <TABLE align=left border=0>
              <TBODY>
              <TR>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>Sx </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0</TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=middle colSpan=0 noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>Sy </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0</TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=middle colSpan=0 noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>Sz </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0</TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=middle colSpan=0 noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE>
                    <TBODY>
                    <TR>
                      <TD align=middle colSpan=0 
                noWrap>1</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></TD>
          <TD noWrap></TD>
          <TD align=left><FONT face=symbol>щ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ы 
            </FONT></TD>
          <TD 
align=middle>.</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>Матрица 
обратного преобразования для масштабирования формируется при замене Sx, 
&nbsp;&nbsp;Sy и Sz на величины, обратные к ним. 
<P>Ранее рассмотренная для двумерного случая матрица поворота (<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#f2_11">11</A>) является в то же 
время трехмерным поворотом вокруг оси Z. Так как при трехмерном повороте вокруг 
оси Z (поворот в плоскости XY) размеры вдоль оси Z неизменны, то все элементы 
третьей строки и третьего столбца равны 0, кроме диагонального, равного 1: 
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>Rz(<FONT face=symbol>f</FONT><SUB>z</SUB>) = 
          </TD>
          <TD align=left><FONT face=symbol>щ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ы 
            </FONT></TD>
          <TD align=middle></TD>
          <TD noWrap>
            <TABLE align=left border=0>
              <TBODY>
              <TR>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>cos<FONT 
                        face=symbol>f</FONT><SUB>z</SUB> </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>sin<FONT 
                        face=symbol>f</FONT><SUB>z</SUB> </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0</TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=middle colSpan=0 noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>-sin<FONT 
                        face=symbol>f</FONT><SUB>z</SUB> </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>cos<FONT 
                        face=symbol>f</FONT><SUB>z</SUB> </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0</TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=middle colSpan=0 noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>1 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0</TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=middle colSpan=0 noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE>
                    <TBODY>
                    <TR>
                      <TD align=middle colSpan=0 
                noWrap>1</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></TD>
          <TD noWrap></TD>
          <TD align=left><FONT face=symbol>щ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ы 
            </FONT></TD>
          <TD align=middle>.</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>
<P>При повороте вокруг оси X (в плоскости YZ) размеры вдоль оси X не меняются, 
поэтому все элементы первой строки и первого столбца равны 0, за исключением 
диагонального, равного 1: 
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>Rx(<FONT face=symbol>f</FONT><SUB>x</SUB>) = 
          </TD>
          <TD align=left><FONT face=symbol>щ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ы 
            </FONT></TD>
          <TD align=middle></TD>
          <TD noWrap>
            <TABLE align=left border=0>
              <TBODY>
              <TR>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>1 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0</TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=middle colSpan=0 noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>cos<FONT 
                        face=symbol>f</FONT><SUB>x</SUB> </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>sin<FONT 
                        face=symbol>f</FONT><SUB>x</SUB> </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0</TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=middle colSpan=0 noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>-sin<FONT 
                        face=symbol>f</FONT><SUB>x</SUB> </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>cos<FONT 
                        face=symbol>f</FONT><SUB>x</SUB> </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0</TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=middle colSpan=0 noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE>
                    <TBODY>
                    <TR>
                      <TD align=middle colSpan=0 
                noWrap>1</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></TD>
          <TD noWrap></TD>
          <TD align=left><FONT face=symbol>щ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ы 
            </FONT></TD>
          <TD align=middle>.</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>
<P>При повороте вокруг оси Y (в плоскости XZ) размеры вдоль оси Y не меняются, 
поэтому все элементы второй строки и второго столбца равны 0, за исключением 
диагонального, равного 1: 
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>Ry(<FONT face=symbol>f</FONT><SUB>y</SUB>) = 
          </TD>
          <TD align=left><FONT face=symbol>щ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ы 
            </FONT></TD>
          <TD align=middle></TD>
          <TD noWrap>
            <TABLE align=left border=0>
              <TBODY>
              <TR>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>cos<FONT 
                        face=symbol>f</FONT><SUB>y</SUB> </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>-sin<FONT 
                        face=symbol>f</FONT><SUB>y</SUB> </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0</TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=middle colSpan=0 noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>1 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0</TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=middle colSpan=0 noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>sin<FONT 
                        face=symbol>f</FONT><SUB>y</SUB> </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>cos<FONT 
                        face=symbol>f</FONT><SUB>y</SUB> </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0</TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=middle colSpan=0 noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE>
                    <TBODY>
                    <TR>
                      <TD align=middle colSpan=0 
                noWrap>1</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></TD>
          <TD noWrap></TD>
          <TD align=left><FONT face=symbol>щ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ы 
            </FONT></TD>
          <TD align=middle>.</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>
<P>Столбцы и строки подматриц 3&times;3 матриц поворота Rx, &nbsp;&nbsp;Ry, 
&nbsp;&nbsp;Rz, аналогично двумерному случаю, представляют собой взаимно 
ортогональные единичные векторы. Легко убедиться, что суммарная матрица 
преобразования для произвольной последовательности поворотов вокруг осей X, 
&nbsp;&nbsp;Y и Z имеет вид: 
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>R = </TD>
          <TD align=left><FONT face=symbol>щ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ы 
            </FONT></TD>
          <TD align=middle></TD>
          <TD noWrap>
            <TABLE align=left border=0>
              <TBODY>
              <TR>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>r1<SUB>x</SUB> 
                  </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>r1<SUB>y</SUB> 
                  </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>r1<SUB>z</SUB> 
                  </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0</TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=middle colSpan=0 noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>r2<SUB>x</SUB> 
                  </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>r2<SUB>y</SUB> 
                  </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>r2<SUB>z</SUB> 
                  </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0</TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=middle colSpan=0 noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>r3<SUB>x</SUB> 
                  </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>r3<SUB>y</SUB> 
                  </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>r3<SUB>z</SUB> 
                  </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0</TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=middle colSpan=0 noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE>
                    <TBODY>
                    <TR>
                      <TD align=middle colSpan=0 
                noWrap>1</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></TD>
          <TD noWrap></TD>
          <TD align=left><FONT face=symbol>щ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ы 
            </FONT></TD>
          <TD 
align=middle></TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>причем 
столбцы (и строки) представляют собой взаимно ортогональные единичные векторы. 
Более того, векторы-столбцы при повороте, задаваемом матрицей, совмещаются с 
соответствующими осями координат. Матрица, столбцы (или строки) которой 
представляют собой взаимно ортогональные векторы, называется ортогональной. Для 
любой ортогональной матрицы М обратная матрица совпадает с транспонированной. 
Это обеспечивает простоту вычисления обратного преобразования для поворота. 
Причем не надо фактически выполнять транспонирование, а достаточно просто 
поменять местами индексы строк и столбцов. 
<P>Взаимная ортогональность столбцов матрицы поворота и их совмещение с осями 
координат при преобразовании, задаваемом матрицей, позволяет легко 
сконструировать матрицу преобразования, если известны его результаты. 
<P><B>Пример</B> формирования матрицы преобразования (из []) 
<P>Пусть заданы три точки P<SUB>1</SUB>, &nbsp;&nbsp;P<SUB>2</SUB>, 
&nbsp;&nbsp;P<SUB>3</SUB>. Найти матрицу преобразования такого, что после 
преобразования вектор <B>P</B><SUB>1</SUB><B>P</B><SUB>2</SUB> будет направлен 
вдоль оси Z, а вектор <B>P</B><SUB>1</SUB><B>P</B><SUB>3</SUB> будет лежать в 
плоскости YZ. 
<OL type=1>
  <P>
  <LI>Вначале надо сместить начало координат в точку P<SUB>1</SUB> с помощью 
  преобразования 
  <CENTER>
  <TABLE align=center border=0>
    <TBODY>
    <TR>
      <TD>
        <TABLE align=left>
          <TBODY>
          <TR>
            <TD align=middle noWrap>T(-x<SUB>1</SUB>, -y<SUB>1</SUB>, 
              -z<SUB>1</SUB>).</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>
  <LI>Единичный вектор, который должен лечь вдоль оси Z 
  <CENTER>
  <TABLE align=center border=0>
    <TBODY>
    <TR>
      <TD>
        <TABLE align=left>
          <TBODY>
          <TR>
            <TD align=middle noWrap><B>R</B><SUB>z</SUB> = 
              [r1<SUB>z</SUB>&nbsp;&nbsp;r2<SUB>z</SUB>&nbsp;&nbsp;r3<SUB>z</SUB>] 
              = <B>P</B><SUB>1</SUB><B>P</B><SUB>2</SUB> / <FONT 
              face=symbol>|</FONT><B>P</B><SUB>1</SUB><B>P</B><SUB>2</SUB><FONT 
              face=symbol>|</FONT>.</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>Здесь 
  <FONT face=symbol>|</FONT><B>P</B><SUB>1</SUB><B>P</B><SUB>2</SUB><FONT 
  face=symbol>|</FONT> - длина вектора <B>P</B><SUB>1</SUB><B>P</B><SUB>2</SUB>. 

  <LI>Вектор, перпендикулярный плоскости, построенной на векторах 
  <B>P</B><SUB>1</SUB><B>P</B><SUB>2</SUB> и 
  <B>P</B><SUB>1</SUB><B>P</B><SUB>3</SUB>, должен быть направлен вдоль оси X, 
  так как вектор <B>P</B><SUB>1</SUB><B>P</B><SUB>2</SUB> лежит вдоль оси Z, а 
  вектор <B>P</B><SUB>1</SUB><B>P</B><SUB>3</SUB> лежит в плоскости YZ. Этот 
  вектор задается векторным произведением 
  <CENTER>
  <TABLE align=center border=0>
    <TBODY>
    <TR>
      <TD>
        <TABLE align=left>
          <TBODY>
          <TR>
            <TD align=middle noWrap><B>R</B><SUB>x</SUB> = 
              [r1<SUB>x</SUB>&nbsp;&nbsp;r2<SUB>x</SUB>&nbsp;&nbsp;r3<SUB>x</SUB>] 
              = </TD>
            <TD align=middle noWrap><B>P</B><SUB>1</SUB><B>P</B><SUB>2</SUB> 
              &times;<B>P</B><SUB>1</SUB><B>P</B><SUB>3</SUB>
              <HR noShade>
               <FONT 
              face=symbol>|</FONT><B>P</B><SUB>1</SUB><B>P</B><SUB>2</SUB><FONT 
              face=symbol>|</FONT> ·<FONT 
              face=symbol>|</FONT><B>P</B><SUB>1</SUB><B>P</B><SUB>3</SUB><FONT 
              face=symbol>|</FONT><BR></TD>
            <TD align=middle 
  noWrap>.</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>
  <LI>Наконец, вдоль оси Y должен быть направлен вектор, перпендикулярный к 
  векторам <B>R</B><SUB>x</SUB> и <B>R</B><SUB>z</SUB>: 
  <CENTER>
  <TABLE align=center border=0>
    <TBODY>
    <TR>
      <TD>
        <TABLE align=left>
          <TBODY>
          <TR>
            <TD align=middle noWrap><B>R</B><SUB>y</SUB> = 
              [&nbsp;r1<SUB>y</SUB>&nbsp;r2<SUB>y</SUB>&nbsp;r3<SUB>y</SUB> 
              &nbsp;] = <B>R</B><SUB>z</SUB> 
        &times;<B>R</B><SUB>x</SUB>.</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>
  <LI>Искомая матрица есть 
  <CENTER>
  <TABLE align=center border=0>
    <TBODY>
    <TR>
      <TD>
        <TABLE align=left>
          <TBODY>
          <TR>
            <TD align=middle noWrap>M = 
              T(-x<SUB>1</SUB>,-y<SUB>1</SUB>,-z<SUB>1</SUB>) ·</TD>
            <TD align=left><FONT face=symbol>щ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ы 
              </FONT></TD>
            <TD align=middle></TD>
            <TD noWrap>
              <TABLE align=left border=0>
                <TBODY>
                <TR>
                  <TD align=middle noWrap>
                    <TABLE border=0>
                      <TBODY>
                      <TR>
                        <TD align=middle noWrap>r1<SUB>x</SUB> 
                    </TD></TR></TBODY></TABLE></TD>
                  <TD align=middle noWrap>
                    <TABLE border=0>
                      <TBODY>
                      <TR>
                        <TD align=middle noWrap>r1<SUB>y</SUB> 
                    </TD></TR></TBODY></TABLE></TD>
                  <TD align=middle noWrap>
                    <TABLE border=0>
                      <TBODY>
                      <TR>
                        <TD align=middle noWrap>r1<SUB>z</SUB> 
                    </TD></TR></TBODY></TABLE></TD>
                  <TD align=middle noWrap>
                    <TABLE border=0>
                      <TBODY>
                      <TR>
                        <TD align=middle noWrap>0</TD></TR></TBODY></TABLE></TD></TR>
                <TR>
                  <TD align=middle colSpan=0 noWrap>
                    <TABLE border=0>
                      <TBODY>
                      <TR>
                        <TD align=middle noWrap>r2<SUB>x</SUB> 
                    </TD></TR></TBODY></TABLE></TD>
                  <TD align=middle noWrap>
                    <TABLE border=0>
                      <TBODY>
                      <TR>
                        <TD align=middle noWrap>r2<SUB>y</SUB> 
                    </TD></TR></TBODY></TABLE></TD>
                  <TD align=middle noWrap>
                    <TABLE border=0>
                      <TBODY>
                      <TR>
                        <TD align=middle noWrap>r2<SUB>z</SUB> 
                    </TD></TR></TBODY></TABLE></TD>
                  <TD align=middle noWrap>
                    <TABLE border=0>
                      <TBODY>
                      <TR>
                        <TD align=middle noWrap>0</TD></TR></TBODY></TABLE></TD></TR>
                <TR>
                  <TD align=middle colSpan=0 noWrap>
                    <TABLE border=0>
                      <TBODY>
                      <TR>
                        <TD align=middle noWrap>r3<SUB>x</SUB> 
                    </TD></TR></TBODY></TABLE></TD>
                  <TD align=middle noWrap>
                    <TABLE border=0>
                      <TBODY>
                      <TR>
                        <TD align=middle noWrap>r3<SUB>y</SUB> 
                    </TD></TR></TBODY></TABLE></TD>
                  <TD align=middle noWrap>
                    <TABLE border=0>
                      <TBODY>
                      <TR>
                        <TD align=middle noWrap>r3<SUB>z</SUB> 
                    </TD></TR></TBODY></TABLE></TD>
                  <TD align=middle noWrap>
                    <TABLE border=0>
                      <TBODY>
                      <TR>
                        <TD align=middle noWrap>0</TD></TR></TBODY></TABLE></TD></TR>
                <TR>
                  <TD align=middle colSpan=0 noWrap>
                    <TABLE border=0>
                      <TBODY>
                      <TR>
                        <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                  <TD align=middle noWrap>
                    <TABLE border=0>
                      <TBODY>
                      <TR>
                        <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                  <TD align=middle noWrap>
                    <TABLE border=0>
                      <TBODY>
                      <TR>
                        <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                  <TD align=middle noWrap>
                    <TABLE>
                      <TBODY>
                      <TR>
                        <TD align=middle colSpan=0 
                  noWrap>1</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></TD>
            <TD noWrap></TD>
            <TD align=left><FONT face=symbol>щ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ы 
              </FONT></TD>
            <TD 
  align=middle>.</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER></LI></OL>
<P>
<CENTER>
<H3><A name=tth_sEc0.1.6>0.1.6</A>&nbsp;&nbsp;Проекции</H3></CENTER>
<P>При визуализации двумерных изображений достаточно задать окно видимости в 
системе координат пользователя и порт отображения на экране дисплея, в котором 
будет выдаваться изображение из окна. В этом случае достаточно провести 
отсечение изображения по окну и выполнить двумерные преобразования окно-порт. На 
рис.&nbsp; показан простой пример двумерных преобразований. Окном отсекается 
часть изображения домика и один улей (см. рис.&nbsp; слева). Отсеченное 
изображение передается в порт отображения дисплея с выполнением преобразований 
окно-порт (см. рис.&nbsp; справа). В данном (простом) случае выполняется только 
преобразование сдвига. 
<P>
<P><A name=tth_fIg0.2></A><A name=r02_02>
<CENTER><BR><IMG alt="Рисунок 2" 
src="Учебное пособие Основные алгоритмы компьютерной графики_files/kg0202.gif">
<P></CENTER>
<CENTER>Рис. 0.1.2: Пример визуализации для двумерных изображений</CENTER></A>
<P>
<P>В случае же трехмерных изображений отсечение выполняется уже не по окну, а по 
объему видимости и затем выполняется проецирование в порт отображения, который в 
свою очередь может быть проекцией объема видимости. Модель процесса визуализации 
трехмерных изображений приведена на рис.&nbsp;. 
<P>
<P><A name=tth_fIg0.3></A><A name=r02_03>
<CENTER><BR><IMG alt="Рисунок 3" 
src="Учебное пособие Основные алгоритмы компьютерной графики_files/kg0203.gif">
<P></CENTER>
<CENTER>Рис. 0.1.3: Модель процесса визуализации трехмерных 
изображений</CENTER></A>
<P>
<P>Как уже отмечалось, проецирование в общем случае - отображение точек, 
заданных в системе координат размерностью N, в точки в системе с меньшей 
размерностью. При отображении трехмерных изображений на дисплей три измерения 
отображаются в два. 
<P>Проецирование выполняется с помощью прямолинейных проекторов (проецирующих 
лучей), идущих из центра проекции через каждую точку объекта до пересечения с 
картинной поверхностью (поверхностью проекции). Далее рассматриваются только 
плоские проекции, при которых поверхность проекции - плоскость в трехмерном 
пространстве. 
<P>По расположению центра проекции относительно плоскости проекции различаются 
центральная и параллельные проекции. 
<P>При <B>параллельной проекции</B> центр проекции находится на бесконечном 
расстоянии от плоскости проекции. Проекторы представляют собой пучок 
параллельных лучей. В этом случае необходимо задавать направление проецирования 
и расположение плоскости проекции. По взаимному расположению проекторов, 
плоскости проекции и главных осей координат различаются <I>ортогональные, 
прямоугольные аксонометрические</I> и <I>косоугольные аксонометрические</I> 
проекции. 
<P>При <I>ортогональной проекции</I> проекторы перпендикулярны плоскости 
проекции, а плоскость проекции перпендикулярна главной оси. Т.е. проекторы 
параллельны главной оси. 
<P><I>При аксонометрической проекции</I> имеется одна из двух 
перпендикулярностей: 
<UL>
  <P>
  <LI><I>при прямоугольной аксонометрической проекции</I> проекторы 
  перпендикулярны плоскости проекции, которая расположена под углом к главной 
  оси; 
  <LI><I>при косоугольной аксонометрической проекции</I> проекторы не 
  перпендикулярны плоскости проекции, но плоскость проекции перпендикулярна к 
  главной оси. </LI></UL>
<P>Изображение, полученное при параллельном проецировании, не достаточно 
реалистично, но передаются точные форма и размеры, хотя и возможно различное 
укорачивание для различных осей. 
<P>При <B>центральной проекции</B> расстояние от центра проекции до плоскости 
проецирования конечно, поэтому проекторы представляют собой пучок лучей, 
исходящих из центра проекции. В этом случае надо задавать расположение и центра 
проекции и плоскости проекции. Изображения на плоскости проекции имеют т.н. 
перспективные искажения, когда размер видимого изображения зависит от взаимного 
расположения центра проекции, объекта и плоскости проекции. Из-за перспективных 
искажений изображения, полученные центральной проекцией, более реалистичны, но 
нельзя точно передать форму и размеры. Различаются одно, двух и трехточечные 
центральные проекции в зависимости от того по скольким осям выполняется 
перспективное искажение. Иллюстрация центральной проекции приведена на 
рис.&nbsp;. 
<P>На рис.&nbsp; приведена классификация описанных выше плоских проекций. 
<P>
<P><A name=tth_fIg0.4></A><A name=r02_04>
<CENTER><BR><IMG alt="Рисунок 4" 
src="Учебное пособие Основные алгоритмы компьютерной графики_files/kg0204.gif">
<P></CENTER>
<CENTER>Рис. 0.1.4: Классификация плоских проекций</CENTER></A>
<P>
<P>
<CENTER>
<H4>Параллельные проекции</H4></CENTER>
<P>Вначале мы рассмотрим ортогональные проекции, используемые в техническом 
черчении, в регламентированной для него правосторонней системе координат, когда 
ось Z изображается вертикальной. Затем будут проиллюстрированы аксонометрические 
проекции также в правосторонней системе координат, но уже более близкой к 
машинной графике (ось Y вертикальна, ось X направлена горизонтально вправо, а 
ось Z - от экрана к наблюдателю). Наконец выведем матрицы преобразования в 
левосторонней системе координат, часто используемой в машинной графике, с 
вертикальной осью Y, осью X, направленной вправо и осью Z, направленной от 
наблюдателя. 
<P>Использование проекций в техническом черчении регламентируется стандартом 
ГОСТ&nbsp;2.317-69. Наиболее широко, особенно, в САПР используются ортогональные 
проекции (виды). Вид - ортогональная проекция обращенной к наблюдателю видимой 
части поверхности предмета, расположенного между наблюдателем и плоскостью 
чертежа. 
<P>В техническом черчении за основные плоскости проекций принимают шесть граней 
куба (рис.&nbsp;). 
<P>
<P><A name=tth_fIg0.5></A><A name=r02_05>
<CENTER><BR><IMG alt="Рисунок 5" 
src="Учебное пособие Основные алгоритмы компьютерной графики_files/kg0205.gif">
<P></CENTER>
<OL type=1>
  <LI>Вид спереди, главный вид, фронтальная проекция, (на заднюю грань V), 
  <LI>Вид сверху, план, горизонтальная проекция, (на нижнюю грань H), 
  <LI>Вид слева, профильная проекция, (на правую грань W), 
  <LI>Вид справа (на левую грань), 
  <LI>Вид снизу (на верхнюю грань), 
  <LI>Вид сзади (на переднюю грань). </LI></OL>
<P>
<CENTER>Рис. 0.1.5: Ортогональные проекции (основные виды) и их расположение на 
листе чертежа</CENTER></A>
<P>
<P>Очевидно, что при ортогональной проекции не происходит изменения ни углов, ни 
масштабов. 
<P>При аксонометрическом проецировании (см. рис.&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#r02_04">0.4</A>) сохраняется 
параллельность прямых, а углы изменяются; измерение же расстояний вдоль каждой 
из координатных осей в общем случае должно выполняться со своим масштабным 
коэффициентом. 
<P>При изометрических проекциях укорачивания вдоль всех координатных осей 
одинаковы, поэтому можно производить измерения вдоль направлений осей с одним и 
тем же масштабом (отсюда и название изометрия). На рис.&nbsp; приведена 
(аксонометрическая прямоугольная) изометрическая проекция куба со стороной A. 
При этой проекции плоскость проецирования наклонена ко всем главным координатным 
осям под одинаковым углом. Стандартом регламентируется коэффициент сжатия, 
равный 0.82, а также расположение и взаимные углы главных координатных осей, 
равные 120<SUP><FONT face=symbol>°</FONT></SUP> как это показано в левом верхнем 
углу рис.&nbsp;. Обычно сжатие не делается. 
<P>
<P><A name=tth_fIg0.6></A><A name=r02_06>
<CENTER><BR><IMG alt="Рисунок 6" 
src="Учебное пособие Основные алгоритмы компьютерной графики_files/kg0206.gif">
<P></CENTER>
<CENTER>Рис. 0.1.6: Аксонометрическая прямоугольная изометрическая проекция куба 
со стороной A</CENTER></A>
<P>
<P>При диметрической проекции две из трех осей сокращены одинаково, т.е. из трех 
углов между нормалью к плоскости проекции и главными координатными осями два 
угла одинаковы. На рис.&nbsp; приведена (аксонометрическая прямоугольная) 
диметрическая проекция куба со стороной A. Там же показаны регламентируемые 
расположение осей и коэффициенты сжатия. Обычно вместо коэффициента сжатия 0.94 
используется 1, а вместо 0.47 - 0.5. 
<P>
<P><A name=tth_fIg0.7></A><A name=r02_07>
<CENTER><BR><IMG alt="Рисунок 7" 
src="Учебное пособие Основные алгоритмы компьютерной графики_files/kg0207.gif">
<P></CENTER>
<CENTER>Рис. 0.1.7: Аксонометрическая прямоугольная диметрическая проекция куба 
со стороной A</CENTER></A>
<P>
<P><B>В косоугольных проекциях</B> плоскость проекции перпендикулярна главной 
координатной оси, а проекторы расположены под углом к ней. Таким образом, 
аксонометрические косоугольные проекции сочетают в себе свойства ортогональных и 
аксонометрических прямоугольных проекций. 
<P>Наиболее употребимы два вида косоугольной проекции - фронтальная 
(косоугольная) диметрия (проекция Kabinett - кабине) и горизонтальная 
(косоугольная) изометрия (проекция Kavalier - кавалье) или военная перспектива. 
<P>В случае фронтальной (косоугольной) диметрии при использовании правосторонней 
системы координат экрана плоскость проецирования перпендикулярна оси Z. Ось X 
направлена горизонтально вправо. Ось Z изображается по углом в 45<SUP><FONT 
face=symbol>°</FONT></SUP> относительно горизонтального направления. Допускается 
угол наклона в 30 и 60<SUP><FONT face=symbol>°</FONT></SUP>. При этом отрезки, 
перпендикулярные плоскости проекции, при проецирования сокращаются до 1/2 их 
истинной длины. На рис.&nbsp; приведена (аксонометрическая косоугольная) 
фронтальная диметрическая проекция куба со стороной A, там же показаны 
регламентируемые коэффициент сжатия, равный 0.5 и расположение осей. 
<P>
<P><A name=tth_fIg0.8></A><A name=r02_08>
<CENTER><BR><IMG alt="Рисунок 8" 
src="Учебное пособие Основные алгоритмы компьютерной графики_files/kg0208.gif">
<P></CENTER>
<CENTER>Рис. 0.1.8: Аксонометрическая косоугольная фронтальная диметрическая 
проекция куба со стороной A</CENTER></A>
<P>
<P>В случае же (аксонометрической косоугольной) горизонтальной изометрии, как 
следует из названия, плоскость проецирования перпендикулярна оси Y а 
укорачивания по всем осям одинаковы и равны 1. Угол поворота изображения оси X 
относительно горизонтального направления составляет 30<SUP><FONT 
face=symbol>°</FONT></SUP>. Допускается 45 и 60<SUP><FONT 
face=symbol>°</FONT></SUP> при сохранении угла 90<SUP><FONT 
face=symbol>°</FONT></SUP> между изображениями осей X и Z. Иллюстрация этого 
приведена на рис.&nbsp;. 
<P>
<P><A name=tth_fIg0.9></A><A name=r02_09>
<CENTER><BR><IMG alt="Рисунок 9" 
src="Учебное пособие Основные алгоритмы компьютерной графики_files/kg0209.gif">
<P></CENTER>
<CENTER>Рис. 0.1.9: Аксонометрическая косоугольная горизонтальная изометрическая 
проекция куба со стороной A</CENTER></A>
<P>
<P>Выведем выражения для матриц преобразования, используя теперь левостороннюю 
систему координат более естественную для машинной графики. 
<P>Простейшее параллельное проецирование - ортогональное выполняется на 
плоскость, перпендикулярную какой-либо оси, т.е. при направлении проецирования 
вдоль этой оси. В частности, проецирование в XY-плоскость, заданную соотношением 
Z = Z<SUB>0</SUB>, выполняется следующим образом: 
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap></TD>
          <TD align=left><FONT face=symbol>щ<BR>ы </FONT></TD>
          <TD align=middle></TD>
          <TD noWrap>
            <TABLE align=left border=0>
              <TBODY>
              <TR>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>xn </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>yn </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>zn </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE>
                    <TBODY>
                    <TR>
                      <TD align=middle colSpan=0 
                noWrap>wn</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></TD>
          <TD noWrap></TD>
          <TD align=left><FONT face=symbol>щ<BR>ы </FONT></TD>
          <TD align=middle>= </TD>
          <TD align=left><FONT face=symbol>щ<BR>ы </FONT></TD>
          <TD align=middle></TD>
          <TD noWrap>
            <TABLE align=left border=0>
              <TBODY>
              <TR>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>x </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>y </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>z </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE>
                    <TBODY>
                    <TR>
                      <TD align=middle colSpan=0 
                noWrap>1</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></TD>
          <TD noWrap></TD>
          <TD align=left><FONT face=symbol>щ<BR>ы </FONT></TD>
          <TD align=middle>·</TD>
          <TD align=left><FONT face=symbol>щ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ы 
            </FONT></TD>
          <TD align=middle></TD>
          <TD noWrap>
            <TABLE align=left border=0>
              <TBODY>
              <TR>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>1 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0</TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=middle colSpan=0 noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>1 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0</TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=middle colSpan=0 noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0</TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=middle colSpan=0 noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>Z<SUB>0</SUB> 
                  </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE>
                    <TBODY>
                    <TR>
                      <TD align=middle colSpan=0 
                noWrap>1</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></TD>
          <TD noWrap></TD>
          <TD align=left><FONT face=symbol>щ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ы 
            </FONT></TD>
          <TD align=middle>.</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>
<P>Рассмотрим теперь косоугольное проецирование, при котором плоскость 
проецирования перпендикулярна главной оси, а проекторы составляют с плоскостью 
проецирования угол не равный 90<SUP><FONT face=symbol>°</FONT></SUP>. Матрица 
для этого преобразования может быть найдена исходя из значений угла 
проецирования и координат преобразованной точки. На рис.&nbsp; показана 
косоугольная параллельная проекция единичного куба. 
<P><A name=tth_fIg0.10></A>
<P>
<CENTER><BR><IMG alt="Рисунок 10" 
src="Учебное пособие Основные алгоритмы компьютерной графики_files/kg0210.gif">
<P><A name=r02_10></CENTER>
<CENTER>Рис. 0.1.10: Косоугольная параллельная проекция P<SUB>1</SUB>(L·cos<FONT 
face=symbol>a</FONT>, L·sin<FONT face=symbol>a</FONT>, 0) точки 
P<SUB>0</SUB>(0,0,1)</CENTER></A>
<P>
<P>Из рисунка видно, что проектором, идущим из точки P<SUB>0</SUB> в 
P<SUB>1</SUB>, точка P<SUB>0</SUB>(0,0,1) проецируется в 
P<SUB>1</SUB>(L·cos<FONT face=symbol>a</FONT>, L·sin<FONT face=symbol>a</FONT>, 
0). 
<P>Теперь проектором, параллельным рассмотренному (рис.&nbsp;), спроецируем 
некоторую точку (X,Y,Z) в точку (X<SUB>p</SUB>,Y<SUB>p</SUB>,Z<SUB>p</SUB>). 
<P><A name=tth_fIg0.11></A>
<P><A name=r02_11>
<CENTER><BR><IMG alt="Рисунок 11" 
src="Учебное пособие Основные алгоритмы компьютерной графики_files/kg0211.gif">
<P></CENTER>
<CENTER>Рис. 0.1.11: Косоугольная параллельная проекция 
(X<SUB>p</SUB>,Y<SUB>p</SUB>,0) точки (X,Y,Z)</CENTER></A>
<P>
<P>Из подобия треугольников получаем: 
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>(X<SUB>p</SUB>-X)/Z = L·cos<FONT 
            face=symbol>a</FONT>&nbsp;&nbsp;&nbsp;&nbsp;<FONT 
            face=symbol>Ю</FONT>&nbsp;&nbsp;&nbsp;&nbsp; Xp = X + Z·L·cos<FONT 
            face=symbol>a</FONT></TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>(Y<SUB>p</SUB>-Y)/Z = L·sin<FONT 
            face=symbol>a</FONT>&nbsp;&nbsp;&nbsp;&nbsp;<FONT 
            face=symbol>Ю</FONT>&nbsp;&nbsp;&nbsp;&nbsp; Y<SUB>p</SUB> = Y + 
            Z·L·sin<FONT 
face=symbol>a</FONT></TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>Это 
соответствует следующему матричному выражению: 
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap></TD>
          <TD align=left><FONT face=symbol>щ<BR>ы </FONT></TD>
          <TD align=middle></TD>
          <TD noWrap>
            <TABLE align=left border=0>
              <TBODY>
              <TR>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>xp </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>yp </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>zp </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE>
                    <TBODY>
                    <TR>
                      <TD align=middle colSpan=0 
                noWrap>1</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></TD>
          <TD noWrap></TD>
          <TD align=left><FONT face=symbol>щ<BR>ы </FONT></TD>
          <TD align=middle>= </TD>
          <TD align=left><FONT face=symbol>щ<BR>ы </FONT></TD>
          <TD align=middle></TD>
          <TD noWrap>
            <TABLE align=left border=0>
              <TBODY>
              <TR>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>x </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>y </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>z </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE>
                    <TBODY>
                    <TR>
                      <TD align=middle colSpan=0 
                noWrap>1</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></TD>
          <TD noWrap></TD>
          <TD align=left><FONT face=symbol>щ<BR>ы </FONT></TD>
          <TD align=middle>·</TD>
          <TD align=left><FONT face=symbol>щ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ы 
            </FONT></TD>
          <TD align=middle></TD>
          <TD noWrap>
            <TABLE align=left border=0>
              <TBODY>
              <TR>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>1 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>1 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0</TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=middle colSpan=0 noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0</TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=middle colSpan=0 noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>L·cos<FONT 
                      face=symbol>a</FONT></TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>L·sin<FONT 
                      face=symbol>a</FONT></TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>1 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0</TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=middle colSpan=0 noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE>
                    <TBODY>
                    <TR>
                      <TD align=middle colSpan=0 
                noWrap>1</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></TD>
          <TD noWrap></TD>
          <TD align=left><FONT face=symbol>щ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ы 
            </FONT></TD>
          <TD 
align=middle>.</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>Таким 
образом, матрица аксонометрической косоугольной проекции для случая 
проецирования в плоскость Z = 0, выполняет следующее: 
<UL>
  <P>
  <LI>вначале плоскости с заданной координатой Z<SUB>0</SUB> переносятся вдоль 
  оси X на Z<SUB>0</SUB>·L·cos<FONT face=symbol>a</FONT> и вдоль оси Y на 
  Z<SUB>0</SUB>·L·sin<FONT face=symbol>a</FONT>, 
  <LI>затем производится проецирование в плоскость Z = 0. </LI></UL>
<P>Различные варианты параллельных проекций формируются из полученной 
подстановкой значений L и углов <FONT face=symbol>a</FONT> и <FONT 
face=symbol>b</FONT> (см. рис.&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#r02_10">0.10</A>). В частности, 
для фронтальной косоугольной диметрии L = 1/2, следовательно, угол <FONT 
face=symbol>b</FONT> между проекторами и плоскостью проецирования равен arctan2 
= 63.4<SUP><FONT face=symbol>°</FONT></SUP>. Угол же <FONT face=symbol>a</FONT>, 
равен 45<SUP><FONT face=symbol>°</FONT></SUP> и допускается 30 и 60<SUP><FONT 
face=symbol>°</FONT></SUP>, как это сказано выше. (Обратите внимание, что в этой 
системе координат плоскость фронтальной проекции - плоскость XY, в отличие от 
системы координат технического черчения, где фронтальная проекция, как это 
показано на рис.&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#r02_05">0.5</A>, формируется в 
плоскости XZ). 
<P>
<CENTER>
<H4>Центральная проекция</H4></CENTER>
<P>Наиболее реалистично трехмерные объекты выглядят в центральной проекции из-за 
перспективных искажений сцены. Центральные проекции параллельных прямых, не 
параллельных плоскости проекции будут сходиться в <I>точке схода</I>. В 
зависимости от числа точек схода, т.е. от числа координатных осей, которые 
пересекает плоскость проекции, различаются одно, двух и трехточечные центральные 
проекции. Иллюстрация одно-, двух- и трехточечной центральных проекций куба 
приведена на рис.&nbsp;. 
<P>
<P><A name=tth_fIg0.12></A><A name=r02_12>
<CENTER><BR><IMG alt="Рисунок 12" 
src="Учебное пособие Основные алгоритмы компьютерной графики_files/kg0212.gif">
<P></CENTER>
<CENTER>Рис. 0.1.12: Одно-, двух- и трехточечная центральные проекции 
куба</CENTER></A>
<P>
<P>Наиболее широко используется двухточечная центральная проекция. 
<P>Выведем матрицу, определяющую центральное проецирование для простого случая 
одноточечной проекции (рис.&nbsp;), когда плоскость проекции перпендикулярна оси 
Z и расположена на расстоянии d от начала координат. (Здесь используется удобная 
для машинной графики левосторонняя система координат). 
<P>
<P><A name=tth_fIg0.13></A><A name=r02_13>
<CENTER><BR><IMG alt="Рисунок 13" 
src="Учебное пособие Основные алгоритмы компьютерной графики_files/kg0213.gif">
<P></CENTER>
<CENTER>Рис. 0.1.13: Центральная проекция точки P<SUB>0</SUB> в плоскость Z = 
d</CENTER></A>
<P>
<P>Начало отсчета находится в точке просмотра. Ясно, что изображения объектов, 
находящиеся между началом координат и плоскостью проекции увеличиваются, а 
изображения объектов, расположенных дальше от начала координат, чем плоскость 
проекции уменьшаются. 
<P>Из рис.&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#r02_13">0.13</A> видно, что для 
координат (X1,Y1) точки P<SUB>1</SUB>, полученной проецированием точки 
P<SUB>0</SUB>(X,Y,Z) в плоскость Z = d (плоскость экрана) выполняются следующие 
соотношения: 
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap></TD>
          <TD align=middle noWrap>X<SUB>1</SUB>
            <HR noShade>
             d<BR></TD>
          <TD align=middle noWrap>= </TD>
          <TD align=middle noWrap>X
            <HR noShade>
             Z<BR></TD>
          <TD align=middle noWrap>, </TD>
          <TD align=middle noWrap>X<SUB>1</SUB>
            <HR noShade>
             d<BR></TD>
          <TD align=middle noWrap>= </TD>
          <TD align=middle noWrap>X
            <HR noShade>
             Z<BR></TD>
          <TD align=middle noWrap>, X<SUB>1</SUB> = </TD>
          <TD align=middle noWrap>X
            <HR noShade>
             Z/d<BR></TD>
          <TD align=middle noWrap>, Y<SUB>1</SUB> = </TD>
          <TD align=middle noWrap>Y
            <HR noShade>
             Z/d<BR></TD>
          <TD align=middle 
noWrap>.</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>Такое 
преобразование может быть представлено матрицей 4&times;4 
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap></TD>
          <TD align=left><FONT face=symbol>щ<BR>ы </FONT></TD>
          <TD align=middle></TD>
          <TD noWrap>
            <TABLE align=left border=0>
              <TBODY>
              <TR>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>x<SUB>1</SUB> 
                  </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>y<SUB>1</SUB> 
                  </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>z<SUB>1</SUB> 
                  </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE>
                    <TBODY>
                    <TR>
                      <TD align=middle colSpan=0 
                    noWrap>w<SUB>1</SUB></TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></TD>
          <TD noWrap></TD>
          <TD align=left><FONT face=symbol>щ<BR>ы </FONT></TD>
          <TD align=middle>= </TD>
          <TD align=left><FONT face=symbol>щ<BR>ы </FONT></TD>
          <TD align=middle></TD>
          <TD noWrap>
            <TABLE align=left border=0>
              <TBODY>
              <TR>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>x </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>y </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>z </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE>
                    <TBODY>
                    <TR>
                      <TD align=middle colSpan=0 
                noWrap>1</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></TD>
          <TD noWrap></TD>
          <TD align=left><FONT face=symbol>щ<BR>ы </FONT></TD>
          <TD align=middle>·</TD>
          <TD align=left><FONT face=symbol>щ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ы 
            </FONT></TD>
          <TD align=middle></TD>
          <TD noWrap>
            <TABLE align=left border=0>
              <TBODY>
              <TR>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>1 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>1 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0</TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=middle colSpan=0 noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0</TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=middle colSpan=0 noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>1 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>1/d</TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=middle colSpan=0 noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE>
                    <TBODY>
                    <TR>
                      <TD align=middle colSpan=0 
                noWrap>0</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></TD>
          <TD noWrap></TD>
          <TD align=left><FONT face=symbol>щ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ы 
            </FONT></TD>
          <TD align=middle>= </TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap></TD>
          <TD align=left><FONT face=symbol>щ<BR>ы </FONT></TD>
          <TD align=middle></TD>
          <TD noWrap>
            <TABLE align=left border=0>
              <TBODY>
              <TR>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>x </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>y </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>z </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE>
                    <TBODY>
                    <TR>
                      <TD align=middle colSpan=0 
                noWrap>1</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></TD>
          <TD noWrap></TD>
          <TD align=left><FONT face=symbol>щ<BR>ы </FONT></TD>
          <TD align=middle>·M<SUB>ц</SUB> = </TD>
          <TD align=left><FONT face=symbol>щ<BR>ы </FONT></TD>
          <TD align=middle></TD>
          <TD noWrap>
            <TABLE align=left border=0>
              <TBODY>
              <TR>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>x </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>y </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>z </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE>
                    <TBODY>
                    <TR>
                      <TD align=middle colSpan=0 
                noWrap>z/d</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></TD>
          <TD noWrap></TD>
          <TD align=left><FONT face=symbol>щ<BR>ы </FONT></TD>
          <TD align=middle>.</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>
<P>Для перехода к декартовым координатам делим все на z/d и получаем: 
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>[&nbsp;&nbsp;&nbsp;&nbsp;X/(Z/d) 
            &nbsp;&nbsp;&nbsp;&nbsp;Y/(Z/d) &nbsp;&nbsp;&nbsp;&nbsp;d 
            &nbsp;&nbsp;&nbsp;&nbsp;1 
      &nbsp;&nbsp;&nbsp;&nbsp;].</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>Если 
же точка просмотра расположена в плоскости проекции, тогда центр проекции 
расположен в точке 
(&nbsp;&nbsp;&nbsp;&nbsp;0,&nbsp;&nbsp;&nbsp;&nbsp;0,&nbsp;&nbsp;&nbsp;&nbsp;-d&nbsp;&nbsp;&nbsp;&nbsp;). 
Рассматривая подобные треугольники, аналогично вышеописанному, можем получить: 
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>X<SUB>1</SUB> = </TD>
          <TD align=middle noWrap>X
            <HR noShade>
             Z/d + 1<BR></TD>
          <TD align=middle noWrap>; Y1 = </TD>
          <TD align=middle noWrap>Y
            <HR noShade>
             Z/d + 1<BR></TD>
          <TD align=middle 
noWrap>.</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>Матрица 
преобразования в этом случае имеет вид: 
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>M<SUB>0</SUB> = </TD>
          <TD align=left><FONT face=symbol>щ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ы 
            </FONT></TD>
          <TD align=middle></TD>
          <TD noWrap>
            <TABLE align=left border=0>
              <TBODY>
              <TR>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>1 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0</TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=middle colSpan=0 noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>1 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0</TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=middle colSpan=0 noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>1/d</TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=middle colSpan=0 noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE>
                    <TBODY>
                    <TR>
                      <TD align=middle colSpan=0 
                noWrap>1</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></TD>
          <TD noWrap></TD>
          <TD align=left><FONT face=symbol>щ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ы 
            </FONT></TD>
          <TD 
align=middle>.</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>Матрица 
M<SUB>0</SUB> может быть представлена в виде: 
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>M<SUB>0</SUB> &nbsp;&nbsp;&nbsp;&nbsp; = 
            &nbsp;&nbsp;&nbsp;&nbsp;T(0, 0, d) ·M<SUB>ц</SUB> ·T (0, 0, 
        -d),</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>т.е. 
преобразование проецирования выполняется для этого случая путем переноса начала 
координат в центр проецирования, собственно проецирования и обратного сдвига 
начала координат. 
<P>
<CENTER>
<H3><A name=tth_sEc0.1.7>0.1.7</A>&nbsp;&nbsp;Стереоизображения</H3></CENTER>
<P>Существенное повышение наглядности изображения достигается использованием 
псевдостереоизображений. В этом случае каждым глазом надо рассматривать 
отдельный перспективный вид. Оба таких вида отображаются на экран дисплея. Для 
их разделения могут использоваться: 
<P><FONT face=symbol>·</FONT> цветовое разделение, когда, например, изображение 
для левого глаза строится красным цветом, а для правого - синим и для просмотра 
используются цветные очки; недостаток этого способа состоит в том, что по сути 
дела можно формировать только простые каркасные изображения, но зато реализация 
проста и полностью используется пространственное разрешение дисплея;<BR>
<P><FONT face=symbol>·</FONT> пространственное-временное разделение, когда, 
например, изображение для левого глаза строится в четных строках, а для правого 
- в нечетных и для просмотра используются электронные или электромеханические 
очки, перекрывающие или левый или правый глаз на время прорисовки нечетных, 
четных строк, соответственно; этот подход может быть реализован на дисплеях с 
чересстрочной разверткой, позволяет выводить достаточно динамические цветные 
полутоновые изображения, но с уменьшением вдвое разрешения по вертикали;<BR>
<P><FONT face=symbol>·</FONT> временное разделение, когда для левого глаза 
используется одна страница видеопамяти, а для правого - вторая и происходит их 
переключение с достаточно большой частотой кадровой развертки; для перекрытия 
глаз также должны использоваться электронные или электромеханические очки; 
пространственное разрешение по строкам здесь не теряется.<BR>
<P>Кроме этого, статические цветные псевдостереоизображения могут быть получены 
последовательным фотографированием изображений для левого и правого глаз с 
последующим просмотром через стереоскоп. 
<P>Используя результаты, полученные в предыдущем пункте, легко сконструировать 
матрицы преобразований для получения стереопроекций для левого и правого глаз. 
<P>
<CENTER>
<H3><A name=tth_sEc0.1.8>0.1.8</A>&nbsp;&nbsp;Геометрические преобразования 
растровых картин</H3></CENTER>
<P>Также как и для векторных изображений в двумерном случае, для растровых 
картин могут в общем случае требоваться преобразования сдвига, масштабирования и 
поворота. В связи с существенно дискретным характером изображения при выполнении 
этих преобразований имеется ряд особенностей. 
<P>Преобразование сдвига реализуется наиболее просто и заключается в 
переписывании части изображения (bitblt - операции Bit Block Transfer). При этом 
возможно исполнение некоторых операций над старым и новым пикселами с 
одинаковыми координатами. 
<P>Наиболее употребимыми являются: 
<P><FONT face=symbol>·</FONT> замена - новый пиксел просто заменяет старый, 
<P><FONT face=symbol>·</FONT> исключающее ИЛИ - в видеопамять заносится 
результат операции XOR над старым и новым кодами пикселов. Эта операция обычно 
используется дважды - вначале для занесения некоторого изображения, например, 
перекрестия и повторного его занесения для восстановления исходной картины.<BR>
<P>Кроме этого, для реализации техники "акварель", т.е. техники работы с 
прозрачными цветами, в видеопамять заносится результат цветовой интерполяции 
между старым и новым оттенками пикселов. Эта операция всегда точно реализуема в 
полноцветных дисплеях, хранящих значения R, G и B в каждом пикселе. В дисплеях с 
таблицей цветности возможно получение не совсем правильных результатов. 
<P>
<CENTER>
<H4>Преобразование масштабирования</H4></CENTER>
<P>Принято различать два типа масштабирования:<BR><FONT 
face=symbol>·</FONT>&nbsp;целочисленное - zoom, 
<P><FONT face=symbol>·</FONT> произвольное, когда коэффициент масштабирования не 
обязательно целое число, - transfocation. 
<P>Наиболее просто реализуется целочисленное масштабирование. При увеличении в K 
раз каждый пиксел в строке дублируется К раз и полученная строка дублируется К 
раз. При уменьшении в K раз из каждой группы в K строк выбирается одна строка и 
в ней из каждой группы в K пикселов берется один пиксел в качестве результата. 
Не целочисленное масштабирование требует нерегулярного дублирования при 
увеличении и выбрасывания при уменьшении. Для отсутствия "дырок" в 
результирующем изображении при любых преобразованиях растровых картин следует 
для очередного пиксела результирующего изображения определить соответствующий 
(соответствующие) пикселы исходного изображения, вычислить значение пиксела и 
занести его. 
<P>Рассмотрим нецелочисленное уменьшение, т.е. перепись из большего массива в 
меньший (увеличение строится похожим образом). 
<P>Алгоритм ясен из следующей программы: 
<P><PRE>#define Max 13  // размер исходного массива
#define Min 7   // размер результирующего массива

int   ist;      // целая часть приращения индекса большего
                // массива при смещении на 1 по меньшему
float rst;      // дробная часть приращения индекса большего
                // массива при смещении на 1 по меньшему
int   iwr;      // индекс записи
int   ird;      // целая часть индекса чтения
float rrd;      // дробная часть индекса чтения
char  isx[Max]; // исходный массив пикселов
char  rez[Min]; // результирующий массив пикселов

void main (void) {
   ist= (int)(Max / Min);
   rst= (float)(Max - ist*Min)/(float)Min;
   ird= 0;  rrd= 0.0;
   for (iwr=0; iwr &lt; Min; iwr++) {
      ird= ird + ist;   // накопление целой части индекса;
      rrd= rrd + rst;   // накопление дробной части индекса;
      if (rrd &gt;= 1.0) {rrd= rrd - 1.0;  ird= ird + 1; }
      rez[iwr]= rez[ird-1];
   }
}
</PRE>
<P>Понятно, что такой алгоритм требует точной вещественной арифметики, версия 
алгоритма с целочисленной арифметикой имеет вид: 
<P><PRE>#define Max 13  // размер исходного массива
#define Min 7   // размер результирующего массива

int   ist;      // целая часть приращения индекса большего
                // массива при смещении на 1 по меньшему
int   rst;      // остаток от приращения индекса
                // меньшего массива
int   iwr;      // индекс записи
int   ird;      // целая часть индекса чтения
int   rrd;      // остаток индекса чтения
char  isx[Max]; // исходный массив пикселов
char  rez[Min]; // результирующий массив пикселов

void main (void) {
   ist= (int)(Max / Min);
   rst= Max - ist*Min;
   ird= 0;  rrd= 0.0;
   for (iwr=0; iwr &lt; Min; iwr++) {
      ird= ird + ist;   // накопление целой части индекса;
      rrd= rrd + rst;   // накопление дробной части индекса;
      if (rrd &gt;= Min) {rrd= rrd - Min;  ird= ird + 1; }
      rez[iwr]= rez[ird-1];
   }
}
</PRE>
<P>Внутренняя часть цикла при записи на ассемблере существенно упрощается, если 
использовать то, что для обычных 16-ти разрядных ЭВМ при переполнении происходит 
смена знака. 
<P>
<CENTER>
<H4>Преобразование поворота</H4></CENTER>
<P>Определенные проблемы, связанные с дискретных характером изображения, 
возникают и при повороте растровой картины на угол не кратный 90<SUP><FONT 
face=symbol>°</FONT></SUP>. Здесь возможны два подхода: 
<OL type=1>
  <P>
  <LI>Сканируются строки исходной картины при этом вычисляются новые значения 
  координат пикселов для результирующей картины. Ясно что отсутствие дырок на 
  результирующем изображении может быть обеспечено только при использовании 
  вещественной арифметики, кроме этого возможно повторное занесение пикселов. 
  <LI>Сканируются строки результирующей картины и по координатам очередного 
  пиксела определяются координаты пиксела из исходного изображения. Этот подход 
  гарантирует отсутствие дырок, кроме того исключает повторное занесение 
  пикселов. </LI></OL>
<P>
<CENTER>
<H3><A name=tth_sEc0.2>0.2</A>&nbsp;&nbsp;ГЕНЕРАЦИЯ ВЕКТОРОВ</H3></CENTER>
<P>Назначение генератора векторов - соединение двух точек изображения отрезком 
прямой. 
<P>Далее будут рассмотрены четыре алгоритма: 
<P><FONT face=symbol>·</FONT> два алгоритма ЦДА - цифрового дифференциального 
анализатора (DDA - Digital Differential Analyzer) для генерации векторов - 
обычный и несимметричный;<BR>
<P><FONT face=symbol>·</FONT> алгоритм Брезенхема для генерации векторов[]; 
<P><FONT face=symbol>·</FONT> алгоритм Брезенхема для генерации ребер 
заполненного многоугольника с уменьшением ступенчатости. 
<P>Перед рассмотрением конкретных алгоритмов сформулируем общие требования к 
изображению отрезка: 
<P><FONT face=symbol>·</FONT> концы отрезка должны находиться в заданных точках; 

<P><FONT face=symbol>·</FONT> отрезки должны выглядеть прямыми, 
<P><FONT face=symbol>·</FONT> яркость вдоль отрезка должна быть постоянной и не 
зависеть от длины и наклона.<BR>
<P>Ни одно из этих условий не может быть точно выполнено на растровом дисплее в 
силу того, что изображение строится из пикселов конечных размеров, а именно: 
<P><FONT face=symbol>·</FONT> концы отрезка в общем случае располагаются на 
пикселах, лишь наиболее близких к требуемым позициям и только в частных случаях 
координаты концов отрезка точно совпадают с координатами пикселов;<BR>
<P><FONT face=symbol>·</FONT> отрезок аппроксимируется набором пикселов и лишь в 
частных случаях вертикальных, горизонтальных и отрезков под 45<SUP><FONT 
face=symbol>°</FONT></SUP> они будут выглядеть прямыми, причем гладкими прямыми, 
без ступенек только для вертикальных и горизонтальных отрезков (рис.&nbsp;);<BR>
<P><FONT face=symbol>·</FONT> яркость для различных отрезков и даже вдоль 
отрезка в общем случае различна, так как, например, расстояние между центрами 
пикселов для вертикального отрезка и отрезка под 45<SUP><FONT 
face=symbol>°</FONT></SUP> различно (см. рис.&nbsp;). 
<P>
<P><A name=tth_fIg0.1></A><A name=r03_01>
<CENTER><BR><IMG alt="Рисунок 14" 
src="Учебное пособие Основные алгоритмы компьютерной графики_files/kg0214.gif">
<P></CENTER>
<CENTER>Рис. 0.2.1: Растровое представление различных векторов</CENTER></A>
<P>
<P>Объективное улучшение аппроксимации достигается увеличением разрешения 
дисплея, но в силу существенных технологических проблем разрешение для растровых 
систем приемлемой скорости разрешение составляет порядка 1280&times;1024. 
<P>Субъективное улучшение аппроксимации основано на психофизиологических 
особенностях зрения и, в частности, может достигаться просто уменьшением 
размеров экрана. Другие способы субъективного улучшения качества аппроксимации 
основаны на различных программных ухищрениях по "размыванию" резких границ 
изображения. 
<P>Далее в этом разделе рассмотрены три алгоритма генерации отрезка. 
<P>
<CENTER>
<H3><A name=tth_sEc0.2.1>0.2.1</A>&nbsp;&nbsp;Цифровой дифференциальный 
анализатор</H3></CENTER>
<P>С помощью ЦДА решается дифференциальное уравнение отрезка, имеющее вид: 
<P>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap></TD>
          <TD align=middle noWrap>dY
            <HR noShade>
             dX<BR></TD>
          <TD align=middle noWrap>= </TD>
          <TD align=middle noWrap>Py
            <HR noShade>
             Px<BR></TD>
          <TD align=middle noWrap>, 
</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>
<P>где Py = Yk - Yn - приращение координат отрезка по оси Y, а Px = Xk - Xn - 
приращение координат отрезка по оси X. 
<P>При этом ЦДА формирует дискретную аппроксимацию непрерывного решения этого 
дифференциального уравнения. 
<P>В обычном ЦДА, используемом, как правило, в векторных устройствах, тем или 
иным образом определяется количество узлов N, используемых для аппроксимации 
отрезка. Затем за N циклов вычисляются координаты очередных узлов: 
<P>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>X<SUB>0</SUB> = &nbsp;&nbsp;Xn; 
            &nbsp;&nbsp;&nbsp;&nbsp;X<SUB>i+1</SUB> = X<SUB>i</SUB> + Px/N. 
        </TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>
<P>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>Y<SUB>0</SUB> = &nbsp;&nbsp;Yn; 
            &nbsp;&nbsp;&nbsp;&nbsp;Y<SUB>i+1</SUB> = Y<SUB>i</SUB> + Py/N. 
        </TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>
<P>Получаемые значения X<SUB>i</SUB>, Y<SUB>i</SUB> преобразуются в 
целочисленные значения координаты очередного подсвечиваемого пиксела либо 
округлением, либо отбрасыванием дробной части. 
<P>Генератор векторов, использующий этот алгоритм, имеет тот недостаток, что 
точки могут прописываться дважды, что увеличивает время построения. 
<P>Кроме того из-за независимого вычисления обеих координат нет предпочтительных 
направлений и построенные отрезки кажутся не очень красивыми. 
<P>Аппаратная реализация этого алгоритма изложена в пункте 8.1 первой части 
курса. 
<P>Субъективно лучше смотрятся вектора с единичным шагом по большей 
относительной координате (несимметричный ЦДА). Для Px &gt; Py (при Px, Py &gt; 
0) это означает, что координата по X направлению должна увеличиться на 1 Px раз, 
а координата по Y-направлению должна также Px раз увеличиться, но на Py/Px. 
<P>Т.е. количество узлов аппроксимации берется равным числу пикселов вдоль 
наибольшего приращения. 
<P>Для генерации отрезка из точки (x1,y1) в точку (x2,y2) в первом октанте (Px 
<FONT face=symbol>і</FONT> Py <FONT face=symbol>і</FONT> 0) алгоритм 
несимметричного ЦДА имеет вид: 
<OL type=1>
  <P>
  <LI>Вычислить приращения координат:<BR>Px= x2 - x1;<BR>Py= y2 - y1; 
  <LI>Занести начальную точку отрезка<BR>PutPixel (x1, y1); 
  <LI>Сгенерировать отрезок<BR>while (x1 &lt; x2) {<BR>x1:= x1 + 1.0;<BR>y1:= y1 
  + Py/Px;<BR>PutPixel (x1, y1);<BR>} </LI></OL>
<P>Пример генерации отрезка по алгоритму несимметричного ЦДА приведен на 
рис.&nbsp;. 
<P>В Приложении 2 приведена программа V_DDA, реализующая данный алгоритм. 
<P>
<P><A name=tth_fIg0.2></A><A name=r03_02>
<CENTER><BR><IMG alt="Рисунок 15" 
src="Учебное пособие Основные алгоритмы компьютерной графики_files/kg0215.gif">
<P></CENTER>
<CENTER>Рис. 0.2.2: Генерация отрезка несимметричным ЦДА</CENTER></A>
<P>
<P>
<CENTER>
<H3><A name=tth_sEc0.2.2>0.2.2</A>&nbsp;&nbsp;Алгоритм Брезенхема</H3><A 
name=AlgBre></A></CENTER>
<P>Так как приращения координат, как правило, не являются целой степенью двойки, 
то в ЦДА-алгоритме (см. предыдущий пункт) требуется выполнение деления, что не 
всегда желательно, особенно при аппаратной реализации. 
<P>Брезенхем в работе [] предложил алгоритм, не требующий деления, как и в 
алгоритме несимметричного ЦДА, но обеспечивающий минимизацию отклонения 
сгенерированного образа от истинного отрезка, как в алгоритме обычного ЦДА. 
Основная идея алгоритма состоит в том, что если угловой коэффициент прямой &lt; 
1/2, то естественно точку, следующую за точкой (0,0), поставить в позицию (1,0) 
(рис.&nbsp;а), а если угловой коэффициент &gt; 1/2, то - в позицию (1,1) 
(рис.&nbsp;б). Для принятия решения куда заносить очередной пиксел вводится 
величина отклонения Е точной позиции от середины между двумя возможными 
растровыми точками в направлении наименьшей относительной координаты. Знак Е 
используется как критерий для выбора ближайшей растровой точки. 
<P>
<P><A name=tth_fIg0.3></A><A name=r03_03>
<CENTER><BR><IMG alt="Рисунок 16" 
src="Учебное пособие Основные алгоритмы компьютерной графики_files/kg0216.gif">
<P>
<P></CENTER>
<CENTER>Рис. 0.2.3: Алгоритм Брезенхема генерации отрезков</CENTER></A>
<P>
<P>Если Е &lt; 0, то точное Y-значение округляется до последнего меньшего 
целочисленного значения Y, т.е. Y-координата не меняется по сравнению с 
предыдущей точкой. В противном случае Y увеличивается на 1. 
<P>Для вычисления Е без ограничения общности упрощающе положим, что 
рассматриваемый вектор начинается в точке (0,0) и проходит через точку 
(4,&nbsp;1.5) (см. рис.&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#r03_03">0.3</A>в), т.е. имеет 
положительный наклон меньший 1. 
<P>Из рис.&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#r03_03">0.3</A>в видно, 
отклонение для первого шага: 
<P>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>Е<SUB>1</SUB> = Py/Px - 1/2 &lt; 
        0,</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>
<P>поэтому для занесения пиксела выбирается точка (1,0). 
<P>Отклонение для второго шага вычисляется добавлением приращения Y-координаты 
для следующей X-позиции (см. рис.&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#r03_03">0.3</A>в): 
<P>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>Е<SUB>2</SUB> = Е<SUB>1</SUB> + Py/Px &gt; 
          0,</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>
<P>поэтому для занесения пиксела выбирается точка (2,1). Так как отклонение 
считается от Y-координаты, которая теперь увеличилась на 1, то из накопленного 
отклонения для вычисления последующих отклонений надо вычесть 1: 
<P>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>Е<SUB>2</SUB> = Е<SUB>2</SUB> - 
        1.</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>
<P>Отклонение для третьего шага: 
<P>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>Е<SUB>3</SUB> = Е<SUB>2</SUB> + Py/Px &lt; 
          0,</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>
<P>поэтому для занесения пиксела выбирается точка (3,1). 
<P>Суммируя и обозначая большими буквами растровые точки, а маленькими - точки 
вектора, получаем: 
<P>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>Е<SUB>1</SUB> = y<SUB>1</SUB> - 1/2 = dY/dX 
            - 1/2.</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>
<P>Возможны случаи: 
<P>
<TABLE>
  <TBODY>
  <TR>
    <TD align=middle>Е<SUB>1</SUB> &gt; 0 </TD>
    <TD align=middle>E<SUB>1</SUB> <FONT face=symbol>Ј</FONT> 0</TD>
  <TR>
    <TD align=middle colSpan=2>ближайшая точка есть:</TD>
  <TR>
    <TD>X<SUB>1</SUB> = X<SUB>0</SUB> + 
      1;&nbsp;&nbsp;&nbsp;&nbsp;Y<SUB>1</SUB> = Y<SUB>0</SUB> + 1; </TD>
    <TD>X<SUB>1</SUB> = X<SUB>0</SUB> + 1; 
      &nbsp;&nbsp;&nbsp;&nbsp;Y<SUB>1</SUB> = Y<SUB>0</SUB>;</TD>
  <TR>
    <TD>E<SUB>2</SUB> = Е<SUB>1</SUB> + Py/Px - 1; </TD>
    <TD>E<SUB>2</SUB> = E<SUB>1</SUB> + Py/Px.</TD></TD></TR></TBODY></TABLE>
<P>Так как интересует только знак Е, то можно избавиться от неудобные частных 
умножением E на 2&times;Px: 
<P>
<TABLE>
  <TBODY>
  <TR>
    <TD></TD>
    <TD>E<SUB>1</SUB> = 2&times;Py - Px</TD>
  <TR>
    <TD>E<SUB>1</SUB> &gt; 0: </TD>
    <TD>E<SUB>2</SUB> = E<SUB>1</SUB> + 2&times;(Py - Px)</TD>
  <TR>
    <TD>E<SUB>1</SUB> <FONT face=symbol>Ј</FONT> 0: </TD>
    <TD>E<SUB>2</SUB> = E<SUB>1</SUB> + 2&times;Py</TD></TD></TR></TBODY></TABLE>
<P>
<P><BR>Таким образом получается алгоритм, в котором используются только целые 
числа, сложение, вычитание и сдвиг:<BR>X= x1;<BR>Y= y1;<BR>Px= x2 - x1;<BR>Py= 
y2 - y1;<BR>E= 2<FONT face=symbol>*</FONT>Py - Px;<BR>i= Px;<BR>PutPixel(X, Y); 
/* Первая точка вектора */<BR>while (i= i- 1 <FONT face=symbol>і</FONT> 0) 
{<BR>if (E <FONT face=symbol>і</FONT> 0) {<BR>X= X + 1;<BR>Y= Y + 1;<BR>E= E + 
2<FONT face=symbol>*</FONT>(Py - Px);<BR>} else<BR>X= X + 1;<BR>E= E + 2<FONT 
face=symbol>*</FONT>Py;<BR>PutPixel(X, Y); /* Очередная точка вектора */<BR>} 
<P>Этот алгоритм пригоден для случая 0 &nbsp;&nbsp; <FONT face=symbol>Ј</FONT> 
&nbsp;&nbsp;dY &nbsp;&nbsp; <FONT face=symbol>Ј</FONT> &nbsp;&nbsp;dX. Для 
других случаев алгоритм строится аналогичным образом. 
<P>На рис.&nbsp; приведен пример генерации по алгоритму Брезенхема того же 
самого отрезка, что и показанного на рис.&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#r03_02">0.2</A> для генерации по 
алгоритму несимметричного ЦДА. Из сравнения рисунков видно, что результаты 
различны. 
<P>
<P><A name=tth_fIg0.4></A><A name=r03_04>
<CENTER><BR><IMG alt="Рисунок 17" 
src="Учебное пособие Основные алгоритмы компьютерной графики_files/kg0217.gif">
<P></CENTER>
<CENTER>Рис. 0.2.4: Генерация отрезка по алгоритму Брезенхема</CENTER></A>
<P>
<P>В Приложении 2 приведена программа V_BRE, реализующая описанный выше 
алгоритм. 
<P>Разработаны алгоритмы цифрового генератора для окружностей и других 
конических сечений. 
<P>
<CENTER>
<H3><A name=tth_sEc0.2.3>0.2.3</A>&nbsp;&nbsp;Улучшение качества аппроксимации 
векторов</H3></CENTER>
<P>Выше было отмечено, что растровая генерация отрезков имеет следующие 
недостатки:<BR><FONT face=symbol>·</FONT>&nbsp;неточное расположение начала и 
конца,<BR><FONT face=symbol>·</FONT>&nbsp;ступенчатый вид отрезка,<BR><FONT 
face=symbol>·</FONT>&nbsp;яркость зависит от наклона и длины. 
<P>Ясно, что первый недостаток не может быть устранен программным путем. 
Неравномерность яркости обычно не слишком заметна и может быть скомпенсирована 
очевидным образом, требующим, в общем случае, вещественной арифметики, но в 
связи с реально небольшим количеством различимых уровней яркости достаточно 
обойтись целочисленным приближением, причем очень грубым. 
<P>Наиболее заметно ухудшает качество изображения ступенчатость. Имеется 
следующие способы борьбы со ступенчатостью : 
<P><FONT face=symbol>·</FONT> увеличение пространственного разрешения за счет 
усовершенствования аппаратуры,<BR>
<P><FONT face=symbol>·</FONT> трактовка пиксела не как точки, а как площадки 
конечного размера, яркость которой зависит от размера площади пиксела, занятой 
изображением отрезка,<BR>
<P><FONT face=symbol>·</FONT> "размывание" резкой границы, за счет частичной 
подсветки пикселов, примыкающих к формируемому отрезку. Понятно, что при этом 
ухудшается пространственное разрешение изображения.<BR>
<P>В данном пункте мы рассмотрим модифицированный алгоритм Брезенхема, 
трактующий пиксел как конечную площадку. В следующем пункте будет рассмотрен 
общий подход, использующий низкочастотную фильтрацию для "размывания" границ 
изображения. 
<CENTER>
<P>
<H4>Модифицированный алгоритм Брезенхема</H4></CENTER>
<P>Основная идея алгоритма состоит в том, чтобы для ребер многоугольника 
устанавливать яркость пиксела пропорционально площади пиксела, попавшей внутрь 
многоугольника. 
<P>На рис.&nbsp; приведена иллюстрация построения ребра многоугольника с 
тангенсом угла наклона 11/21. 
<P>На рис.&nbsp;а) показан результат генерации многоугольника с использованием 
ранее рассмотренного алгоритма Брезенхема при двухуровневом изображении (пиксел 
или закрашен или не закрашен). 
<P>На рис.&nbsp;б) показан результат генерации многоугольника с вычислением 
интесивности пикселов, через которые проходит ребро многоугольника. 
Интенсивность вычисляется пропорциональной площади части пиксела, попавшей 
внутрь многоугольника. 
<P>На рис.&nbsp;в) показан результат генерации многоугольника с вычислением 
интесивности пиксела, через который проходит ребро многоугольника в соответствии 
с модифицированным алгоритмом Брезенхема. 
<P>Как видно из рис.&nbsp; при построении ребра многоугольника с тангенсом угла 
наклона t&nbsp;&nbsp;(0 <FONT face=symbol>Ј</FONT> t <FONT face=symbol>Ј</FONT> 
1) могут захватываться либо один пиксел (пикселы (0,0), (2,1), (4,2), (6,8)) 
либо два пиксела (пикселы (1,0) и (1,1), (3,1) и (3,2), (5,2) и (5,3)). Если 
захватывается один пиксел, то часть его площади, попавшая внутрь многоугольника, 
равна dy + t/2 (рис.&nbsp;a). 
<P>Если же захватывается два пиксела, то часть площади нижнего пиксела, попавшая 
внутрь многоугольника равна 1 - [((1 - dy)<SUP>2</SUP>)/ 2t], а верхнего - [((dy 
- 1 + 2)<SUP>2</SUP>)/ 2t] (см. рис.&nbsp;б). Суммарная площадь частей для двух 
пикселов, попавшая внутрь многоугольника, равна dy + t/2. 
<P>Если теперь в исходном алгоритме Брезенхема (см. <A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#AlgBre">0.2.2</A>) заменить 
отклонение E на E<FONT size=+0>'</FONT> = E + (1-t), то 0 <FONT 
face=symbol>Ј</FONT> E<FONT size=+0>'</FONT> <FONT face=symbol>Ј</FONT> 1) и 
значение E<FONT size=+0>'</FONT> будет давать значение той части площади 
пиксела, которая находится внутри многоугольника. 
<P>Выполняя преобразование над значением отклонения для первого шага (см. <A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#AlgBre">0.2.2</A>) получим, что 
начальное значение станет равным 1/2. Максимальное значение отклонения E<FONT 
size=+0>'</FONT><SUB>max</SUB>, при превышении которого производится увеличение 
Y-координаты занесения пикселов, станет равным (1 - t). 
<P><A name=tth_fIg0.5></A>
<P><A name=r03_05>
<CENTER><BR><IMG alt="Рисунок 18" 
src="Учебное пособие Основные алгоритмы компьютерной графики_files/kg0218.gif">
<P></CENTER>
<CENTER>Рис. 0.2.5: Устранение ступенчатости ребер многоугольника: а) генерация 
ребер без устранения ступенчатости; б) точное вычисление интенсивности пикселов 
границы; в) формирование пикселов границы по модифицированному методу 
Брезенхема.</CENTER></A>
<P>
<P>
<P><A name=tth_fIg0.6></A><A name=r03_06>
<CENTER><BR><IMG alt="Рисунок 19" 
src="Учебное пособие Основные алгоритмы компьютерной графики_files/kg0219.gif">
<P></CENTER>
<CENTER>Рис. 0.2.6: Устранение ступенчатости за счет учета площади пикселов, 
пересекаемых ребром многоугольника.</CENTER></A>
<P>
<P>Для того, чтобы оперировать не дробной частью максимальной интенсивности, а 
непосредственно ее значениями достаточно домножить на полное число уровней 
интенсивности I тангенс угла наклона (t), начальное (E<FONT size=+0>'</FONT>) и 
максимальное (E<FONT size=+0>'</FONT><SUB>max</SUB>) значения отклонения. 
<P>В результате получается следующий алгоритм, пригодный для случая 0 
&nbsp;&nbsp; <FONT face=symbol>Ј</FONT> &nbsp;&nbsp;dY &nbsp;&nbsp; <FONT 
face=symbol>Ј</FONT> &nbsp;&nbsp;dX:<BR>X= x1;<BR>Y= y1;<BR>Px= x2 - x1;<BR>Py= 
y2 - y1;<BR>t= I<FONT face=symbol>*</FONT>Py / Px;<BR>E<FONT size=+0>'</FONT>= 
I/2;<BR>E<FONT size=+0>'</FONT><SUB>max</SUB>= I - I<FONT face=symbol>*</FONT>Py 
/ Px;<BR>i= Px;<BR>PutPixel(X, Y, t/2); /* Первая точка вектора */<BR>while (i = 
i - 1 <FONT face=symbol>і</FONT> 0) {<BR>if (E<FONT size=+0>'</FONT> <FONT 
face=symbol>і</FONT> E<FONT size=+0>'</FONT><SUB>max</SUB>) {<BR>X= X + 1;<BR>Y= 
Y + 1;<BR>E<FONT size=+0>'</FONT> = E<FONT size=+0>'</FONT>- E<FONT 
size=+0>'</FONT><SUB>max</SUB>;<BR>} else<BR>X= X + 1;<BR>E<FONT 
size=+0>'</FONT> = E<FONT size=+0>'</FONT>+ t;<BR>PutPixel(X, Y, E<FONT 
size=+0>'</FONT>); /* Очередная точка вектора */<BR>} 
<P>Для избавления от вещественной арифметики при манипулировании с E<FONT 
size=+0>'</FONT> можно домножить уже упомянутые величины на 2<FONT 
face=symbol>*</FONT>Px. Но в этом случае при занесении пикселов потребуется 
деление E<FONT size=+0>'</FONT> на 2<FONT face=symbol>*</FONT>Px. 
<P>В Приложении 2 приведена процедура V_BreM, реализующая модифицированный 
алгоритм Брезенхема для генерации ребра заполненного многоугольника и пригодная 
для любого октанта. 
<P>
<CENTER>
<H3><A name=tth_sEc0.2.4>0.2.4</A>&nbsp;&nbsp;Улучшение качества изображения 
фильтрацией</H3></CENTER>
<P>Мы здесь рассмотрим методы, основанные на "размывании" границы. 
<P>Один из них заключается в том, что изображение строится с большим 
пространственным разрешением, чем позволяет дисплей. При выводе на экран 
атрибуты пиксела экрана вычисляются усреднением по группе пикселов изображения, 
построенного с большим разрешением. Т.е. пикселы изображения рассматриваются как 
подпикселы соответствующих пикселов экрана. Усредняющая маска перемещается по 
изображению с шагами, равными ее размеру. 
<P>Другой метод заключается в усреднении изображения без изменения его 
разрешения. В этом случае усредняющая маска перемещается по изображению с 
единичными шагами. 
<P>Очевидно, что первый метод должен давать более качественное изображение, но 
при больших затратах ресурсов. Для усреднения предложены различные маски ([,]). 
<P>Простейшее усреднение - равномерное (рис.&nbsp;). Улучшить усреднение можно 
за счет использования весов, задающих влияние отдельных подпикселов на атрибут 
пиксела экрана (см. рис.&nbsp;). 
<P>
<P><A name=tth_fIg0.7></A><A name=r03_07>
<CENTER><BR><IMG alt="Рисунок 20" 
src="Учебное пособие Основные алгоритмы компьютерной графики_files/kg0220.gif">
<P></CENTER>
<CENTER>Рис. 0.2.7: Маски для равномерного усреднения изображения</CENTER></A>
<P>
<P>
<P><A name=tth_fIg0.8></A><A name=r03_08>
<CENTER><BR><IMG alt="Рисунок 21" 
src="Учебное пособие Основные алгоритмы компьютерной графики_files/kg0221.gif">
<P></CENTER>
<CENTER>Рис. 0.2.8: Маски для взвешенного усреднения изображения</CENTER></A>
<P>
<P>Эти массивы должны быть пронормированы для получения единичного коэффициента 
передачи, чтобы не вызывать неправильного смещения средней яркости изображения. 
Нормирующий коэффициент равен 1 / (сумму членов массива). 
<P>Ясно, что эти преобразования, примененные изображению зашумленному случайными 
импульсными помехами, будут подавлять шум. Это так называемые низкочастотные 
фильтры. 
<P>В Приложении 3 приведено несколько процедур фильтрации, реализующих оба 
рассмотренных метода - с понижением и без понижения разрешения. 
<P>
<CENTER>
<H3><A name=tth_sEc0.3>0.3</A>&nbsp;&nbsp;ГЕНЕРАЦИЯ ОКРУЖНОСТИ</H3></CENTER>
<P>Во многих областях приложений, таких как, например, системы 
автоматизированного проектирования машиностроительного направления, 
естественными графическими примитивами, кроме отрезков прямых и строк текстов, 
являются и конические сечения, т.е. окружности, эллипсы, параболы и гиперболы. 
Наиболее употребительным примитивом, естественно, является окружность. Один из 
наиболее простых и эффективных алгоритмов генерации окружности разработан 
Брезенхемом []. В переводной литературе он изложен, в частности, в [,]. 
<P>
<CENTER>
<H3><A name=tth_sEc0.3.1>0.3.1</A>&nbsp;&nbsp;Алгоритм Брезенхема</H3></CENTER>
<P>Для простоты и без ограничения общности рассмотрим генерацию 1/8 окружности, 
центр которой лежит в начале координат. Остальные части окружности могут быть 
получены последовательными отражениями (использованием симметрии точек на 
окружности относительно центра и осей координат). 
<P>Окружность с центром в начале координат описывается уравнением: 
<P>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>X<SUP>2</SUP> + Y<SUP>2</SUP> = 
            R<SUP>2</SUP> </TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>
<P>Алгоритм Брезенхема пошагово генерирует очередные точки окружности, выбирая 
на каждом шаге для занесения пиксела точку растра 
P<SUB>i</SUB>(X<SUB>i</SUB>,&nbsp;&nbsp;Y<SUB>i</SUB>), ближайшую к истинной 
окружности, так чтобы ошибка: 
<P>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>E<SUB>i</SUB>(P<SUB>i</SUB>) &nbsp;&nbsp; = 
            &nbsp;&nbsp;(X<SUB>i</SUB><SUP>2</SUP> &nbsp;&nbsp;+ 
            &nbsp;&nbsp;Y<SUB>i</SUB><SUP>2</SUP>) &nbsp;&nbsp;- 
            &nbsp;&nbsp;R<SUP>2</SUP> 
</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>
<P>была минимальной. Причем, как и в алгоритме Брезенхема для генерации 
отрезков, выбор ближайшей точки выполняется с помощью анализа значений 
управляющих переменных, для вычисления которых не требуется вещественной 
арифметики. Для выбора очередной точки достаточно проанализировать знаки. 
<P>Рассмотрим генерацию 1/8 окружности по часовой стрелке, начиная от точки X=0, 
Y=R. 
<P>Проанализируем возможные варианты занесения i+1-й точки, после занесения i-й. 

<P>
<P><A name=tth_fIg0.1></A><A name=r04_01>
<CENTER><BR><IMG alt="Рисунок 22" 
src="Учебное пособие Основные алгоритмы компьютерной графики_files/kg0222.gif">
<P></CENTER>
<CENTER>Рис. 0.3.1: Варианты расположения очередного пиксела 
окружности</CENTER></A>
<P>
<P>При генерации окружности по часовой стрелке после занесения точки 
(X<SUB>i</SUB>, Y<SUB>i</SUB>) следующая точка может быть (см. рис.&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#r04_01">0.1</A>а) либо Pg = 
(X<SUB>i+1</SUB>, Y<SUB>i</SUB>) - перемещение по горизонтали, либо Pd = 
(X<SUB>i+1</SUB>, Y<SUB>i-1</SUB>) - перемещение по диагонали, либо Pv = 
(X<SUB>i</SUB>, Y<SUB>i-1</SUB>) - перемещение по вертикали. 
<P>Для этих возможных точек вычислим и сравним абсолютные значения разностей 
квадратов расстояний от центра окружности до точки и окружности: 
<P>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap></TD>
          <TD noWrap>
            <TABLE align=left border=0>
              <TBODY>
              <TR>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap><FONT 
                        face=symbol>|</FONT>Dg<FONT face=symbol>|</FONT> 
                    </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>= </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap><FONT face=symbol>|</FONT> 
                        (X+1)<SUP>2</SUP> </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>+ </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>Y<SUP>2</SUP> 
                  </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>- </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>R<SUP>2</SUP> <FONT 
                        face=symbol>|</FONT></TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=middle colSpan=0 noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap><FONT 
                        face=symbol>|</FONT>Dd<FONT face=symbol>|</FONT> 
                    </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>= </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap><FONT face=symbol>|</FONT> 
                        (X+1)<SUP>2</SUP> </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>+ </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>(Y-1)<SUP>2</SUP> 
                  </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>- </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>R<SUP>2</SUP> <FONT 
                        face=symbol>|</FONT></TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=middle colSpan=0 noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap><FONT 
                        face=symbol>|</FONT>Dv<FONT face=symbol>|</FONT> 
                    </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>= </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap><FONT face=symbol>|</FONT> 
                        X<SUP>2</SUP> </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>+ </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>(Y-1)<SUP>2</SUP> 
                  </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>- </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE>
                    <TBODY>
                    <TR>
                      <TD align=middle colSpan=0 noWrap>R<SUP>2</SUP> <FONT 
                        face=symbol>|</FONT></TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></TD>
          <TD noWrap></TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>
<P>Выбирается и заносится та точка, для которой это значение минимально. 
<P>Выбор способа расчета определяется по значению Dd. Если Dd &lt; 0, то 
диагональная точка внутри окружности. Это варианты 1-3 (см. рис.&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#r04_01">0.1</A>б). Если Dd &gt; 
0, то диагональная точка вне окружности. Это варианты 5-7. И, наконец, если Dd = 
0, то диагональная точка лежит точно на окружности. Это вариант 4. Рассмотрим 
случаи различных значений Dd в только что приведенной последовательности. 
<P>
<CENTER>
<H4>Случай Dd &lt; 0</H4></CENTER>
<P>Здесь в качестве следующего пиксела могут быть выбраны или горизонтальный - 
Pg или диагональный - Pd. 
<P>Для определения того, какой пиксел выбрать Pg или Pd составим разность: 
<P>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap></TD>
          <TD noWrap>
            <TABLE align=left border=0>
              <TBODY>
              <TR>
                <TD align=right noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=left noWrap>di</TD></TR></TBODY></TABLE></TD>
                <TD align=left noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=left noWrap>= </TD></TR></TBODY></TABLE></TD>
                <TD align=left noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=left noWrap><FONT face=symbol>|</FONT>Dg<FONT 
                        face=symbol>|</FONT> - <FONT face=symbol>|</FONT>Dd<FONT 
                        face=symbol>|</FONT> = </TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=right colSpan=0 noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=left noWrap></TD></TR></TBODY></TABLE></TD>
                <TD align=left noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=left noWrap></TD></TR></TBODY></TABLE></TD>
                <TD align=left noWrap>
                  <TABLE>
                    <TBODY>
                    <TR>
                      <TD align=right colSpan=0 noWrap><FONT 
                        face=symbol>|</FONT>(X+1)<SUP>2</SUP> + Y<SUP>2</SUP> - 
                        R<SUP>2</SUP><FONT face=symbol>|</FONT> - <FONT 
                        face=symbol>|</FONT>(X+1)<SUP>2</SUP> + 
                        (Y-1)<SUP>2</SUP> - R<SUP>2</SUP><FONT 
                        face=symbol>|</FONT></TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></TD>
          <TD noWrap></TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>
<P>И будем выбирать точку Pg при di <FONT face=symbol>Ј</FONT> 0, в противном 
случае выберем Pd. 
<P>Рассмотрим вычисление di для разных вариантов. 
<P>
<H4>Для вариантов 2 и 3:</H4>
<P>Dg <FONT face=symbol>і</FONT> 0 и Dd &lt; 0, так как горизонтальный пиксел 
либо вне, либо на окружности, а диагональный внутри. 
<P>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>di = (X+1)<SUP>2</SUP> + Y<SUP>2</SUP> - 
            R<SUP>2</SUP> + (X+1)<SUP>2</SUP> + (Y-1)<SUP>2</SUP> - 
            R<SUP>2</SUP>;</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>
<P>Добавив и вычтя (Y-1)<SUP>2</SUP> получим: 
<P>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>di = 2 ·[(X+1)<SUP>2</SUP> + 
            (Y-1)<SUP>2</SUP> - R<SUP>2</SUP>] + 2·Y - 
  1</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>
<P>В квадратных скобках стоит Dd, так что 
<P>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>di = 2 ·(Dd + Y) - 
  1</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>
<P>
<H4>Для варианта 1:</H4>
<P>Ясно, что должен быть выбран горизонтальный пиксел Pg. Проверка компонент di 
показывает, что Dg &lt; 0 и Dd &lt; 0, причем di &lt; 0, так как диагональная 
точка больше удалена от окружности, т.е. по критерию di &lt; 0 как и в 
предыдущих случаях следует выбрать горизонтальный пиксел Pg, что верно. 
<P>
<CENTER>
<H4>Случай Dd &gt; 0</H4></CENTER>
<P>Здесь в качестве следующего пиксела могут быть выбраны или диагональный - Pd 
или вертикальный Pv. 
<P>Для определения того, какую пиксел выбрать Pd или Pv составим разность: 
<P>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap></TD>
          <TD noWrap>
            <TABLE align=left border=0>
              <TBODY>
              <TR>
                <TD align=right noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=left noWrap>si</TD></TR></TBODY></TABLE></TD>
                <TD align=left noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=left noWrap>= </TD></TR></TBODY></TABLE></TD>
                <TD align=left noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=left noWrap><FONT face=symbol>|</FONT>Dd<FONT 
                        face=symbol>|</FONT> - <FONT face=symbol>|</FONT>Dv<FONT 
                        face=symbol>|</FONT> = </TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=right colSpan=0 noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=left noWrap></TD></TR></TBODY></TABLE></TD>
                <TD align=left noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=left noWrap></TD></TR></TBODY></TABLE></TD>
                <TD align=left noWrap>
                  <TABLE>
                    <TBODY>
                    <TR>
                      <TD align=right colSpan=0 noWrap><FONT 
                        face=symbol>|</FONT>(X+1)<SUP>2</SUP> + 
                        (Y-1)<SUP>2</SUP> - R<SUP>2</SUP><FONT 
                        face=symbol>|</FONT> - <FONT 
                        face=symbol>|</FONT>X<SUP>2</SUP> + (Y-1)<SUP>2</SUP> - 
                        R<SUP>2</SUP><FONT 
                  face=symbol>|</FONT></TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></TD>
          <TD noWrap></TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>
<P>Если si <FONT face=symbol>Ј</FONT> 0, то расстояние до вертикальной точки 
больше и надо выбирать диагональный пиксел Pd, если же si &gt; 0, то выбираем 
вертикальный пиксел Pv. 
<P>Рассмотрим вычисление si для разных вариантов. 
<P>
<H4>Для вариантов 5 и 6:</H4>
<P>Dd &gt; 0 и Dv <FONT face=symbol>Ј</FONT> 0, так как диагональный пиксел вне, 
а вертикальный либо вне либо на окружности. 
<P>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>si = (X+1)<SUP>2</SUP> + (Y-1)<SUP>2</SUP> - 
            R<SUP>2</SUP> + X<SUP>2</SUP> + (Y-1)<SUP>2</SUP> - 
        R<SUP>2</SUP>;</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>
<P>Добавив и вычтя (X+1)<SUP>2</SUP> получим: 
<P>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>si = 2 ·[(X+1)<SUP>2</SUP> + 
            (Y-1)<SUP>2</SUP> - R<SUP>2</SUP>] - 2·X - 
  1</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>
<P>В квадратных скобках стоит Dd, так что 
<P>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>si = 2 ·(Dd - X) - 
  1</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>
<P>
<H4>Для варианта 7:</H4>
<P>Ясно, что должен быть выбран вертикальный пиксел Pv. Проверка компонент si 
показывает, что Dd &gt; 0 и Dv &gt; 0, причем si &gt; 0, так как диагональная 
точка больше удалена от окружности, т.е. по критерию si &gt; 0 как и в 
предыдущих случаях следует выбрать вертикальный пиксел Pv, что соответствует 
выбору для вариантов 5 и 6. 
<P>
<CENTER>
<H4>Случай Dd = 0</H4></CENTER>
<P>Для компонент di имеем: Dg &gt; 0 и Dd = 0, следовательно по критерию di &gt; 
0 выбираем диагональный пиксел. 
<P>С другой стороны, для компонент si имеем: Dd = 0 и Dv &lt; 0, так что по 
критерию si <FONT face=symbol>Ј</FONT> 0 также выбираем диагональный пиксел. 
<P>Итак: 
<P>Dd &lt; 0 
<P>di <FONT face=symbol>Ј</FONT> 0 - выбор горизонтального пиксела Pg 
<P>di &gt; 0 - выбор диагонального пиксела Pd 
<P>Dd &gt; 0 
<P>si <FONT face=symbol>Ј</FONT> 0 - выбор диагонального пиксела Pd 
<P>si &gt; 0 - выбор вертикального пиксела Pv 
<P>Dd = 0 
<P>выбор диагонального пиксела Pd. 
<P>Выведем рекуррентные соотношения для вычисления Dd для (i+1)-го шага, после 
выполнения i-го.<BR>
<P>1. Для горизонтального шага к X<SUB>i+1</SUB>, Y<SUB>i</SUB> 
<P>X<SUB>i+1</SUB> = X<SUB>i</SUB> + 1<BR>Y<SUB>i+1</SUB> = Y<SUB>i</SUB> 
<BR>Dd<SUB>i+1</SUB> = (X<SUB>i+1</SUB>+1)<SUP>2</SUP> + 
(Y<SUB>i+1</SUB>-1)<SUP>2</SUP> - R<SUP>2</SUP> = 
<BR>X<SUB>i+1</SUB><SUP>2</SUP> + 2·X<SUB>i+1</SUB> + 1 + 
(Y<SUB>i+1</SUB>-1)<SUP>2</SUP> - R<SUP>2</SUP> = 
<BR>(X<SUB>i</SUB>+1)<SUP>2</SUP> + (Y<SUB>i</SUB>-1)<SUP>2</SUP> - 
R<SUP>2</SUP> + 2·X<SUB>i+1</SUB> + 1 = <BR>Dd<SUB>i</SUB> + 2·X<SUB>i+1</SUB> + 
1<BR>
<P>2. Для диагонального шага к X<SUB>i+1</SUB>, Y<SUB>i-1</SUB> 
<P>X<SUB>i+1</SUB> = X<SUB>i</SUB> + 1<BR>Y<SUB>i+1</SUB> = Y<SUB>i</SUB> - 
1<BR>Dd<SUB>i+1</SUB> = Dd<SUB>i</SUB> + 2 ·X<SUB>i+1</SUB> - 2 ·Y<SUB>i+1</SUB> 
+ 2<BR>
<P>3. Для вертикального шага к X<SUB>i</SUB>, Y<SUB>i-1</SUB> 
<P>X<SUB>i+1</SUB> = X<SUB>i</SUB><BR>Y<SUB>i+1</SUB> = Y<SUB>i</SUB> - 
1<BR>Dd<SUB>i+1</SUB> = Dd<SUB>i</SUB> - 2 ·Y<SUB>i+1</SUB> + 1<BR>
<P>В Приложении 5 приведена подпрограмма V_circle, реализующая описанный выше 
алгоритм и строящая дугу окружности в первой четверти. Начальная инициализация 
должна быть: 
<P>X= 0 
<P>Y= R 
<P>Dd = (X+1)<SUP>2</SUP> + (Y-1)<SUP>2</SUP> - R<SUP>2</SUP> = 1 + 
(R-1)<SUP>2</SUP> - R<SUP>2</SUP> = 2*(1 - R) 
<P>Пикселы в остальных четвертях можно получить отражением. Кроме того 
достаточно сформировать дугу только во втором октанте, а остальные пикселы 
сформировать из соображений симметрии, например, с помощью подпрограммы 
Pixel_circle, приведенной в Приложении 5 и заносящей симметричные пикселы по 
часовой стрелке от исходного. 
<P>В Приложении 6 приведены подпрограмма V_BRcirc, реализующая описанный выше 
алгоритм и строящая дугу окружности во втором октанте с последующим симметричным 
занесением пикселов. Эта процедура может строить и 1/4 окружности. Подробнее см. 
текст Приложения 6. Там же приведена более короткая подпрограмма, строящая 1/8 
окружности методом Мичнера [], (том 1, стр. 152). Остальная часть окружности 
строится симметрично. 
<P>
<CENTER>
<H3><A name=tth_sEc0.4>0.4</A>&nbsp;&nbsp;ЗАПОЛНЕНИЕ 
МНОГОУГОЛЬНИКА</H3></CENTER>
<P>В большинстве приложений используется одно из существенных достоинств 
растровых устройств - возможность заполнения областей экрана. 
<P>Существует две разновидности заполнения: 
<P><FONT face=symbol>·</FONT> первая, связанная как с интерактивной работой, так 
и с программным синтезом изображения, служит для заполнения внутренней части 
многоугольника, заданного координатами его вершин.<BR>
<P><FONT face=symbol>·</FONT> вторая, связанная в первую очередь с интерактивной 
работой, служит для заливки области, которая либо очерчена границей с кодом 
пиксела, отличающимся от кодов любых пикселов внутри области, либо закрашена 
пикселами с заданным кодом;<BR>
<P>В данном разделе рассмотрим алгоритм заполнения многоугольника. В следующем 
разделе будут рассмотрены алгоритмы заливки области. 
<P>Простейший способ заполнения многоугольника, заданного координатами вершин, 
заключается в определении принадлежит ли текущий пиксел внутренней части 
многоугольника. Если принадлежит, то пиксел заносится. 
<P>Определить принадлежность пиксела многоугольнику можно, например, подсчетом 
суммарного угла с вершиной на пикселе при обходе контура многоугольника. Если 
пиксел внутри, то угол будет равен 360<SUP><FONT face=symbol>°</FONT></SUP>, 
если вне - 0<SUP><FONT face=symbol>°</FONT></SUP> (рис.&nbsp;). 
<P>
<P><A name=tth_fIg0.1></A><A name=r05_01>
<CENTER><BR><IMG alt="Рисунок 23" 
src="Учебное пособие Основные алгоритмы компьютерной графики_files/kg0223.gif">
<P></CENTER>
<CENTER>Рис. 0.4.1: Определение принадлежности пиксела 
многоугольнику</CENTER></A>
<P>
<P>Вычисление принадлежности должно производиться для всех пикселов экрана и так 
как большинство пикселов скорее всего вне многоугольников, то данный способ 
слишком расточителен. Объем лишних вычислений в некоторых случаях можно 
сократить использованием прямоугольной оболочки - минимального прямоугольника, 
объемлющего интересующий объект, но все равно вычислений будет много. Другой 
метод определения принадлежности точки внутренней части многоугольника будет 
рассмотрен ниже при изучении отсечения отрезков по алгоритму Кируса-Бека. 
<P>
<CENTER>
<H3><A name=tth_sEc0.4.1>0.4.1</A>&nbsp;&nbsp;Построчное 
заполнение</H3></CENTER>
<P>Реально используются алгоритмы построчного заполнения, основанные на том, что 
соседние пикселы в строке скорее всего одинаковы и меняются только там где 
строка пересекается с ребром многоугольника. Это называется когерентностью 
растровых строк (строки сканирования Y<SUB>i</SUB>, Y<SUB>i+1</SUB>, 
Y<SUB>i+2</SUB> на рис.&nbsp;). При этом достаточно определить X-координаты 
пересечений строк сканирования с ребрами. Пары отсортированных точек пересечения 
задают интервалы заливки. 
<P>
<P><A name=tth_fIg0.2></A><A name=r05_02_0>
<CENTER><BR><IMG alt="Рисунок 24" 
src="Учебное пособие Основные алгоритмы компьютерной графики_files/kg0224.gif">
<P>
<P></CENTER>
<CENTER>Рис. 0.4.2: Построчная закраска многоугольника</CENTER></A>
<P>
<P>Кроме того, если какие-либо ребра пересекались i-й строкой, то они скорее 
всего будут пересекаться также и строкой i+1. (строки сканирования Y<SUB>i</SUB> 
и Y<SUB>i+1</SUB> на рис.&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#r05_02_0">0.2</A>). Это 
называется когерентностью ребер. При переходе к новой строке легко вычислить 
новую X-координату точки пересечения ребра, используя X-координату старой точки 
пересечения и тангенс угла наклона ребра: 
<P>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>X<SUB>i+1</SUB> = X<SUB>i</SUB> + 
        1/k</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>
<P>(тангенс угла наклона ребра - k = dy/dx, так как dy = 1, то 1/k = dx). 
<P>Смена же количества интервалов заливки происходит только тогда, когда в 
строке сканирования появляется вершина. 
<P>Учет когерентности строк и ребер позволяет построить для заполнения 
многоугольников различные высокоэффективные алгоритмы построчного сканирования. 
Для каждой строки сканирования рассматриваются только те ребра, которые 
пересекают строку. Они задаются списком активных ребер (САР). При переходе к 
следующей строке для пересекаемых ребер перевычисляются X-координаты 
пересечений. При появлении в строке сканирования вершин производится перестройка 
САР. Ребра, которые перестали пересекаться, удаляются из САР, а все новые ребра, 
пересекаемые строкой заносятся в него. 
<P>Общая схема алгоритма, динамически формирующего список активных ребер и 
заполняющего многоугольник снизу-вверх, следующая: 
<OL type=1>
  <P>
  <LI>Подготовить служебные целочисленные массивы Y-координат вершин и номеров 
  вершин. 
  <LI>Совместно отсортировать Y-координаты по возрастанию и массив номеров 
  вершин для того, чтобы можно было определить исходный номер вершины. 
  <LI>Определить пределы заполнения по оси Y - Y_мin и Y_max. Стартуя с текущим 
  значением Y_tek = Y_min, исполнять пункты 4-9 до завершения раскраски. 
  <LI>Определить число вершин, расположенных на строке Y_tek - текущей строке 
  сканирования. 
  <LI>Если вершины есть, то для каждой из вершин дополнить список активных 
  ребер, используя информацию о соседних вершинах.<BR>Для каждого ребра в список 
  активных ребер заносятся: 
  <UL>
    <P>
    <LI>максимальное значение Y-координаты ребра, 
    <LI>приращение X-координаты при увеличении Y на 1, 
    <LI>начальное значение X-координаты. </LI></UL>
  <P>Если обнаруживаются горизонтальные ребра, то они просто закрашиваются и 
  информация о них в список активных ребер не заносится.<BR>Если после этого 
  обнаруживается, что список активных ребер пуст, то заполнение закончено. </P>
  <LI>По списку активных ребер определяется Y_след - Y-координата ближайшей 
  вершины. (Вплоть до Y_след можно не заботиться о модификации САР а только 
  менять X-координаты пересечений строки сканирования с активными ребрами). 
  <LI>В цикле от Y_tek до Y_след: 
  <UL>
    <P>
    <LI>выбрать из списка активных ребер и отсортировать X-координаты 
    пересечений активных ребер со строкой сканирования; 
    <LI>определить интервалы и выполнить закраску; 
    <LI>перевычислить координаты пересечений для следующей строки сканирования. 
    </LI></UL>
  <P></P>
  <LI>Проверить не достигли ли максимальной Y-координаты. Если достигли, то 
  заливка закончена, иначе выполнить пункт . 
  <LI><A name=n5_1></A>Очистить список активных ребер от ребер, закончившихся на 
  строке Y_след и перейти к пункту 4. </LI></OL>
<P>В Приложении 5 приведены две подпрограммы заполнения многоугольника - V_FP0 и 
V_FP1. Первая реализует данный (простейший) алгоритм. Эта программа вполне 
работоспособна, но генерирует двух и трехкратное занесение части пикселов. Это 
мало приемлемо для устройств вывода типа матричных или струйных принтеров. 
<P>В отличие от V_FP0, в программе V_FP1 используется более сложный алгоритм 
формирования списка активных ребер, обеспечивающий практически полное отсутствие 
дублирований (рис.&nbsp;). 
<P>
<P><A name=tth_fIg0.3></A><A name=r05_02_1>
<CENTER><BR><IMG alt="Рисунок 25" 
src="Учебное пособие Основные алгоритмы компьютерной графики_files/kg0225.gif">
<P></CENTER>
<CENTER>Рис. 0.4.3: Сравнение алгоритмов заполнения многоугольника</CENTER></A>
<P>
<P>
<CENTER>
<H3><A name=tth_sEc0.4.2>0.4.2</A>&nbsp;&nbsp;Сортировка методом распределяющего 
подсчета</H3></CENTER>
<P>Понятно, что одна из важнейших работ в алгоритме построчного сканирования - 
сортировка. В связи с заведомо ограниченной разрешающей способностью растровых 
дисплеев (не более 2048) иногда целесообразно использовать чрезвычайно 
эффективный алгоритм сортировки методом распределяющего подсчета. 
<P>Для рассмотрения алгоритма предположим, что надо отсортировать числа, 
заданные в массиве с именем "Исходный_массив"; количество сортируемых чисел 
задается скаляром "Кол-во_чисел"; сортируемые числа J удовлетворяют условию: 
<P>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>0 <FONT face=symbol>Ј</FONT> J &lt; 
            Max_число.</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>
<P>Для сортировки потребуются описания: 
<P><PRE>int  Max_число;        /* Верхняя граница значений */
int  *Повтор;          /* Длина этого массива = Max_число */
int  Кол_чисел;        /* Кол-во сортируемых чисел */
int  *Исходный_массив; /* Длина этого массива &gt;= Кол_чисел */
int  *Результат;       /* Длина этого массива &gt;= Кол_чисел */
int  ii,jj, kk;        /* Рабочие переменные */
</PRE>
<P>
<OL type=1>
  <LI>Обнуляется служебный массив для подсчета числа повторений исходных кодов. 
  <P><PRE>   for (ii=0; ii&lt;Max_число; ++ii) Повтор[ii]= 0;
</PRE>
  <P></P>
  <LI>Сортируемый массив просматривается и вычисляется количество раз повторений 
  каждого числа: 
  <P><PRE>   for (ii= 0; ii &lt; Кол_чисел; ++ii) {
      jj= Исходный_массив[ii];
      Повтор[jj]= Повтор[jj] + 1;
   }
</PRE>
  <P></P>
  <LI>Суммируется количество повторений каждого числа, так что значение 
  Повтор[J] даст начальное расположение группы чисел, равных J, в 
  отсортированном массиве: 
  <P><PRE>   jj= 0;
   for (ii=0; ii&lt;Max_число; ++ii) {
      jj= jj + Повтор[ii];
      Повтор[ii]= jj;
   }
</PRE>
  <P></P>
  <LI>Просматривается исходный массив и числа из него заносятся в массив 
  результатов той же длины. Индекс занесения числа J в массив результатов равен 
  значению J-го элемента массива Повтор. После занесения числа J значение 
  Повтор[J] уменьшается на 1: 
  <P><PRE>   for (ii= 0; ii &lt; Кол_чисел; ++ii) {
      jj= Исходный_массив[ii];
      kk= Повтор[jj];
      Результат[kk]= jj;
      Повтор[jj]= Повтор[jj] - 1;
   }
</PRE></LI></OL>
<P>
<CENTER>
<H3><A name=tth_sEc0.5>0.5</A>&nbsp;&nbsp;ЗАЛИВКА ОБЛАСТИ С 
ЗАТРАВКОЙ</H3></CENTER>
<P>Как уже отмечалось, для приложений, связанных в основном с интерактивной 
работой, используются алгоритмы заполнения области с затравкой. 
<P>При этом тем или иным образом задается заливаемая (перекрашиваемая) область, 
код пиксела, которым будет выполняться заливка и начальная точка в области, 
начиная с которой начнется заливка. 
<P>По способу задания области делятся на два типа: 
<P><FONT face=symbol>·</FONT> гранично-определенные, задаваемые своей 
(замкнутой) границей такой, что коды пикселов границы отличны от кодов 
внутренней, перекрашиваемой части области. На коды пикселы внутренней части 
области налагаются два условия - они должны быть отличны от кода пикселов 
границы и кода пиксела перекраски. Если внутри гранично-определенной области 
имеется еще одна граница, нарисованная пикселами с тем же кодом, что и внешняя 
граница, то соответствующая часть области не должна перекрашиваться;<BR>
<P><FONT face=symbol>·</FONT> внутренне-определенные, нарисованные одним 
определенным кодом пиксела. При заливке этот код заменяется на новый код 
закраски.<BR>
<P>В этом состоит основное отличие заливки области с затравкой от заполнения 
многоугольника. В последнем случае мы сразу имеем всю информацию о предельных 
размерах части экрана, занятой многоугольником. Поэтому определение 
принадлежности пиксела многоугольнику базируется на быстро работающих 
алгоритмах, использующих когерентность строк и ребер (см. предыдущий раздел). В 
алгоритмах же заливки области с затравкой нам вначале надо прочитать пиксел, 
затем определить принадлежит ли он области и если принадлежит, то перекрасить. 
<P>Заливаемая область или ее граница - некоторое связное множество пикселов. По 
способам доступа к соседним пикселам области делятся на 4-х и 8-ми связные. В 
4-х связных областях доступ к соседним пикселам осуществляется по четырем 
направлениям - горизонтально влево и вправо и в вертикально вверх и вниз. В 8-ми 
связных областях к этим направлениям добавляются еще 4 диагональных. Используя 
связность мы может, двигаясь от точки затравки, достичь и закрасить все пикселы 
области. 
<P>Важно отметить, что для 4-х связной прямоугольной области граница 8-ми связна 
(рис.&nbsp;а) и наоборот у 8-ми связной области граница 4-х связна (см. 
рис.&nbsp;б). Поэтому заполнение 4-х связной области 8-ми связным алгоритмом 
может привести к "просачиванию" через границу и заливке пикселов в примыкающей 
области. 
<P>В общем, 4-х связную область мы можем заполнить как 4-х, так и 8-ми связным 
алгоритмом. Обратное же неверно. Так область на рис.&nbsp;а мы можем заполнить 
любым алгоритмом, а область на рис.&nbsp;б, состоящую из двух примыкающих 4-х 
связных областей можно заполнить только 8-ми связным алгоритмом. 
<P>
<P><A name=tth_fIg0.1></A><A name=r06_01>
<CENTER><BR><IMG alt="Рисунок 26" 
src="Учебное пособие Основные алгоритмы компьютерной графики_files/kg0226.gif">
<P>
<P></CENTER>
<CENTER>Рис. 0.5.1: Связность областей и их границ</CENTER></A>
<P>
<P>С использованием связности областей и стека можно построить простые алгоритмы 
закраски как внутренне, так и гранично-определенной области. В [] 
рассматриваются совсем короткие рекурсивные подпрограммы заливки. В [] - 
несколько более длинные итеративные подпрограммы. 
<P>
<CENTER>
<H3><A name=tth_sEc0.5.1>0.5.1</A>&nbsp;&nbsp;Простой алгоритм 
заливки</H3></CENTER>
<P>Рассмотрим простой алгоритм заливки гранично-определенной 4-х связной 
области. В [] приведена рекурсивная реализация подпрограммы заливки 4-х связной 
гранично-определенной области: 
<P>void V_FAB4R (grn_pix, new_pix, x_isx, y_isx) 
<P>int grn_pix, new_pix, x_isx, y_isx; 
<P>{ 
<P>if (getpixel (x_isx, y_isx) <FONT face=symbol>№</FONT> grn_pix &amp;&amp; 
<P>getpixel (x_isx, y_isx) <FONT face=symbol>№</FONT> new_pix) 
<P>{ 
<P>putpixel (x_isx, y_isx, new_pix); 
<P>V_FAB4R (grn_pix, new_pix, x_isx+1, y_isx); 
<P>V_FAB4R (grn_pix, new_pix, x_isx, y_isx+1); 
<P>V_FAB4R (grn_pix, new_pix, x_isx-1, y_isx); 
<P>V_FAB4R (grn_pix, new_pix, x_isx, y_isx-1); 
<P>} 
<P>} /* V_FAB4R */ 
<P>Заливка выполняется следующим образом: 
<P><FONT face=symbol>·</FONT> определяется является ли пиксел граничным или уже 
закрашенным, 
<P><FONT face=symbol>·</FONT> если нет, то пиксел перекрашивается, затем 
проверяются и если надо перекрашиваются 4 соседних пиксела. 
<P>Полный текст тестовой программы V_FAB4R с использованием этой подпрограммы 
приведен в Приложении 6. 
<P>Понятно, что несмотря на простоту и изящество программы, рекурсивная 
реализация проигрывает итеративной в том, что требуется много памяти для 
упрятывания вложенных вызовов. 
<P>В [] приведен итеративный алгоритм закраски 4-х связной гранично-определенной 
области. Логика работы алгоритма следующая: 
<P>Поместить координаты затравки в стек 
<P>Пока стек не пуст 
<P>Извлечь координаты пиксела из стека. 
<P>Перекрасить пиксел. 
<P>Для всех четырех соседних пикселов проверить 
<P>является ли он граничным или уже перекрашен. 
<P>Если нет, то занести его координаты в стек. 
<P>На рис.&nbsp;&nbsp;а) показан выбранный порядок перебора соседних пикселов, а 
на рис.&nbsp;&nbsp;б) соответствующий ему порядок закраски простой 
гранично-определенной области. 
<P>
<P><A name=tth_fIg0.2></A><A name=r06_02>
<TABLE width="100%">
  <TBODY>
  <TR>
    <TD align=middle>
      <CENTER><BR><IMG alt="Рисунок 27" 
      src="Учебное пособие Основные алгоритмы компьютерной графики_files/kg0227.gif">
      <P>a)<BR>Порядок перебора соседних пикселов </CENTER></P></TD>
    <TD align=middle>
      <CENTER><BR><IMG alt="Рисунок 28" 
      src="Учебное пособие Основные алгоритмы компьютерной графики_files/kg0228.gif">
      <P>б)<BR>Порядок заливки области </CENTER></P></TD></TR></TBODY></TABLE>
<CENTER>Рис. 0.5.2: Заливка 4-х связной области итеративным 
алгоритмом</CENTER></A>
<P>
<P>Ясно, что такой алгоритм экономнее, так как в стек надо упрятывать только 
координаты. 
<P>Рассмотренный алгоритм легко модифицировать для работы с 8-ми связными 
гранично-определенными областями или же для работы с внутренне-определенными. 
<P>Программа V_FAB4, реализующая данный алгоритм, приведена в Приложении 6. 
<P>Сравнительные прогоны тестовых программ V_FAB4R и V_FAB4 подтвердили 
соображения о неэкономности рекурсивного алгоритма: при стандартном окне стека в 
64&nbsp;K с помощью рекурсивной программы можно закрасить квадратик не более чем 
57&times;57 пикселов. Итеративная же программа V_FAB4 при тех же условиях позволяет 
закрасить прямоугольник размером 110&times;110 истратив на массив координат 16382 
байта. 
<P>Как уже отмечалось, очевидный недостаток алгоритмов непосредственно 
использующих связность закрашиваемой области - большие затраты памяти на стек, 
так как на каждый закрашенный пиксел в стеке по максимуму будет занесена 
информация о еще трех соседних. Кроме того, информация о некоторых пикселах 
может записываться в стек многократно. Это приведет не только к перерасходу 
памяти, но и потере быстродействия за счет многократной раскраски одного и того 
же пиксела. Значительно более экономен далее рассмотренный построчный алгоритм 
заливки. 
<P>
<CENTER>
<H3><A name=tth_sEc0.5.2>0.5.2</A>&nbsp;&nbsp;Построчный алгоритм заливки с 
затравкой</H3></CENTER>
<P>Использует пространственную когерентность: 
<P><FONT face=symbol>·</FONT> пикселы в строке меняются только на границах; 
<P><FONT face=symbol>·</FONT> при перемещении к следующей строке размер 
заливаемой строки скорее всего или неизменен или меняется на 1 пиксел.<BR>
<P>Таким образом, на каждый закрашиваемый фрагмент строки в стеке хранятся 
координаты только одного начального пиксела [], что приводит к существенному 
уменьшению размера стека. 
<P>Последовательность работы алгоритма для гранично определенной области 
следующая: 
<OL type=1>
  <P>
  <LI>Координата затравки помещается в стек, затем до исчерпания стека 
  выполняются пункты 2-4. 
  <P></P>
  <LI>Координата очередной затравки извлекается из стека и выполняется 
  максимально возможное закрашивание вправо и влево по строке с затравкой, т.е. 
  пока не попадется граничный пиксел. Пусть это Хлев и Хправ, соответственно. 
  <P></P>
  <LI>Анализируется строка ниже закрашиваемой в пределах от Хлев до Хправ и в 
  ней находятся крайние правые пикселы всех незакрашенных фрагментов. Их 
  координаты заносятся в стек. 
  <P></P>
  <LI>То же самое проделывается для строки выше закрашиваемой. </LI></OL>
<P>В Приложении 6 приведена процедура V_FAST, реализующая рассмотренный 
алгоритм. За счет несложной модификации служебных процедур запроса и записи 
строк изображения, данная процедура может заливать изображение, размещенное в 
файле. 
<P>
<CENTER>
<H3><A name=tth_sEc0.6>0.6</A>&nbsp;&nbsp;ОТСЕЧЕНИЕ ОТРЕЗКОВ</H3></CENTER>
<P>Если изображение выходит за пределы экрана, то на части дисплеев 
увеличивается время построения за счет того, что изображение строится в "уме". В 
некоторых дисплеях выход за пределы экрана приводит к искажению картины, так как 
координаты просто ограничиваются при достижении ими граничных значений, а не 
выполняется точный расчет координат пересечения (эффект "стягивания" 
изображения). Некоторые, в основном, простые дисплеи просто не допускают выхода 
за пределы экрана. Все это, особенно в связи с широким использованием технологии 
просмотра окнами, требует выполнения отсечения сцены по границам окна видимости. 

<P>В простых графических системах достаточно двумерного отсечения, в трехмерных 
пакетах используется трех и четырехмерное отсечение. Последнее выполняется в 
ранее рассмотренных однородных координатах, позволяющих единым образом выполнять 
аффинные и перспективные преобразования. 
<P>Программное исполнение отсечения достаточно медленный процесс, поэтому, 
естественно, в мощные дисплеи встраивается соответствующая аппаратура. Первое 
сообщение об аппаратуре отсечения, использующей алгоритм отсечения делением 
отрезка пополам и реализованной в устройстве Clipping Divider, появилось в 
1968&nbsp;г. [<A href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#mbib38" 
name=CITEmbib38>38</A>]. Этот алгоритм был рассмотрен при изучении технических 
средств. Здесь мы рассмотрим программные реализации алгоритма отсечения. 
<P>Отсекаемые отрезки могут быть трех классов - целиком видимые, целиком 
невидимые и пересекающие окно. Очевидно, что целесообразно возможно более рано, 
без выполнения большого объема вычислений принять решение об видимости целиком 
или отбрасывании. По способу выбора простого решения об отбрасывании невидимого 
отрезка целиком или принятия его существует два основных типа алгоритмов 
отсечения - алгоритмы, использующие кодирование концов отрезка или всего отрезка 
и алгоритмы, использующие параметрическое представление отсекаемых отрезков и 
окна отсечения. Представители первого типа алгоритмов - алгоритм 
Коэна-Сазерленда (Cohen-Sutherland, CS-алгоритм) [<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#mbib4" name=CITEmbib4>4</A>] и 
FC-алгоритм (Fast Clipping - алгоритм) [<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#mbib37" name=CITEmbib37>37</A>]. 
Представители алгоритмов второго типа - алгоритм Кируса-Бека (Curus-Beck, CB - 
алгоритм) и более поздний алгоритм Лианга-Барски (Liang-Barsky, LB-алгоритм) [<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#mbib32" name=CITEmbib32>32</A>]. 
<P>Алгоритмы с кодированием применимы для прямоугольного окна, стороны которого 
параллельны осям координат, в то время как алгоритмы с параметрическим 
представлением применимы для произвольного окна. 
<P>Вначале мы рассмотрим алгоритм Коэна-Сазерленда, являющийся стандартом 
де-факто алгоритма отсечения линий и обладающий одним из лучших быстродействий 
при компактной реализации. Затем рассмотрим наиболее быстрый, но и чрезвычайно 
громоздкий FC-алгоритм. Далее рассмотрим алгоритм Лианга-Барски для отсечения 
прямоугольным окном с использованием параметрического представления. 
Быстродействие этого алгоритма сравнимо с быстродействием алгоритма 
Коэна-Сазерленда при большей компактности и наличии 3D и 4D реализаций. 
Последним рассмотрим алгоритм Кируса-Бека, который использует параметрическое 
представление и позволяет отсекать произвольным выпуклым окном. В заключение 
сравним быстродействие различных алгоритмов. 
<P>
<CENTER>
<H3><A name=tth_sEc0.6.1>0.6.1</A>&nbsp;&nbsp;Двумерный алгоритм 
Коэна-Сазерленда</H3></CENTER>
<P>Этот алгоритм позволяет быстро выявить отрезки, которые могут быть или 
приняты или отброшены целиком. Вычисление пересечений требуется когда отрезок не 
попадает ни в один из этих классов. Этот алгоритм особенно эффективен в двух 
крайних случаях: 
<P><FONT face=symbol>·</FONT> большинство примитивов содержится целиком в 
большом окне, 
<P><FONT face=symbol>·</FONT> большинство примитивов лежит целиком вне 
относительно маленького окна.<BR>
<P>Идея алгоритма состоит в следующем: 
<P>Окно отсечения и прилегающие к нему части плоскости вместе образуют 9 
областей (рис.&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#r7_1">0.2.3</A>). Каждой из 
областей присвоен 4-х разрядный код. 
<P>Две конечные точки отрезка получают 4-х разрядные коды, соответствующие 
областям, в которые они попали. Смысл разрядов кода: 
<P>1 рр = 1 - точка над верхним краем окна; 
<P>2 рр = 1 - точка под нижним краем окна; 
<P>3 рр = 1 - точка справа от правого края окна; 
<P>4 рр = 1 - точка слева от левого края окна. 
<P>Определение того лежит ли отрезок целиком внутри окна или целиком вне окна 
выполняется следующим образом: 
<P><FONT face=symbol>·</FONT> если коды обоих концов отрезка равны 0 то отрезок 
целиком внутри окна, отсечение не нужно, отрезок принимается как тривиально 
видимый (отрезок AB на рис.&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#r7_1">0.2.3</A>);<BR>
<P><FONT face=symbol>·</FONT> если логическое &amp; кодов обоих концов отрезка 
не равно нулю, то отрезок целиком вне окна, отсечение не нужно, отрезок 
отбрасывается как тривиально невидимый (отрезок KL на рис.&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#r7_1">0.2.3</A>);<BR>
<P><FONT face=symbol>·</FONT> если логическое &amp; кодов обоих концов отрезка 
равно нулю, то отрезок подозрительный, он может быть частично видимым (отрезки 
CD, EF, GH) или целиком невидимым (отрезок IJ); для него нужно определить 
координаты пересечений со сторонами окна и для каждой полученной части 
определить тривиальную видимость или невидимость. При этом для отрезков CD и IJ 
потребуется вычисление одного пересечения, для остальных (EF и GH) - двух.<BR>
<P>При расчете пересечения используется горизонтальность либо вертикальность 
сторон окна, что позволяет определить координату X или Y точки пересечения без 
вычислений. 
<P>
<P><A name=tth_fIg0.3></A><A name=r7_1>
<CENTER><BR><IMG alt="Рисунок 29" 
src="Учебное пособие Основные алгоритмы компьютерной графики_files/kg0229.gif">
<P></CENTER>
<CENTER>Рис. 0.2.3: Отсечение по методу Коэна-Сазерленда</CENTER></A>
<P>
<P>При непосредственном использовании описанного выше способа отбора целиком 
видимого или целиком невидимого отрезка после расчета пересечения потребовалось 
бы вычисление кода расположения точки пересечения. Для примера рассмотрим 
отрезок CD. Точка пересечения обозначена как P. В силу того, что граница окна 
считается принадлежащей окну, то можно просто принять только часть отрезка PD, 
попавшую в окно. Часть же отрезка CP, на самом деле оказавшаяся вне окна, 
потребует дальнейшего рассмотрения, так как логическое И кодов точек C и P даст 
0, т.е. отрезок CP нельзя просто отбросить. Для решения этой проблемы Коэн и 
Сазерленд предложили заменять конечную точку с ненулевым кодом конца на точку, 
лежащую на стороне окна, либо на ее продолжении. 
<P>В целом схема алгоритма Коэна-Сазерленда следующая: 
<OL type=1>
  <P>
  <LI>Рассчитать коды конечных точек отсекаемого отрезка. 
  <P>В цикле повторять пункты 2-6: 
  <P></P>
  <LI>Если логическое И кодов конечных точек не равно 0, то отрезок целиком вне 
  окна. Он отбрасывается и отсечение закончено. 
  <P></P>
  <LI>Если оба кода равны 0, то отрезок целиком видим. Он принимается и 
  отсечение закончено. 
  <P></P>
  <LI>Если начальная точка внутри окна, то она меняется местами с конечной 
  точкой. 
  <P></P>
  <LI>Анализируется код начальной точки для определения стороны окна с которой 
  есть пересечение и выполняется расчет пересечения. При этом вычисленная точка 
  пересечения заменяет начальную точку. 
  <P></P>
  <LI>Определение нового кода начальной точки. </LI></OL>
<P>Эта схема реализована в процедуре V_CSclip, приведенной в Приложении 7. 
<P>
<CENTER>
<H3><A name=tth_sEc0.6.2>0.6.2</A>&nbsp;&nbsp;Двумерный 
FC-алгоритм</H3></CENTER>
<P>В 1987&nbsp;г. Собков, Поспишил и Янг [<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#mbib37" name=CITEmbib37>37</A>] 
предложили алгоритм, названный ими FC-алгоритмом (Fast Clipping), также 
использующий кодирование, но не конечных точек, а линий целиком. Приведенное 
далее изложение алгоритма следует статье [<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#mbib37" name=CITEmbib37>37</A>]. 
<P>Схема кодирования близка к используемой в алгоритме Коэна-Сазерленда 
(рис.&nbsp;<A href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#r7_2">0.2.4</A>). 
Пространство разбивается на 9 неперекрывающихся областей, пронумерованных 
арабскими цифрами от 1 до 9. Коды, назначаемые концам отрезков, попавших в ту 
или иную область, приведены в двоичном и шестнадцатиричном виде (запись вида 
0xD). 
<P>
<P><A name=tth_fIg0.4></A><A name=r7_2>
<CENTER><BR><IMG alt="Рисунок 30" 
src="Учебное пособие Основные алгоритмы компьютерной графики_files/kg0230.gif">
<P></CENTER>
<CENTER>Рис. 0.2.4: Задание кодов для FC-алгоритма</CENTER></A>
<P>
<P>Отрезок видим только в области 5, т.е. отрезок, координаты которого 
удовлетворяют условиям: 
<P>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>Xлев <FONT face=symbol>Ј</FONT> X <FONT 
            face=symbol>Ј</FONT> Xправ 
            &nbsp;&nbsp;&nbsp;&nbsp;и&nbsp;&nbsp;&nbsp;&nbsp;Yниз <FONT 
            face=symbol>Ј</FONT> Y <FONT face=symbol>Ј</FONT> 
        Yверх.</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>
<P>Каждая конечная точка отрезка V<SUB>0</SUB>V<SUB>1</SUB> окажется с одной из 
этих областей. Комбинация кодов концов отрезка, называемая кодом линии, 
используется для определения возможных вариантов расположения отрезка и, 
следовательно, отсечения. Код линии формируется из кодов концов отрезка 
следующим образом: 
<P>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>LineCode (V<SUB>0</SUB>,V<SUB>1</SUB>) 
            &nbsp;&nbsp; = &nbsp;&nbsp;(Code(V<SUB>0</SUB>) &times;16) + Code 
            (V<SUB>1</SUB>),</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>
<P>здесь Code(V<SUB>1</SUB>) обозначает код конечной точки 
V<SUB>1</SUB>,<BR>Code(V<SUB>0</SUB>) &times; 16 означает сдвиг кода начальной точки 
V<SUB>0</SUB> влево на 4 разряда. 
<P>Так как каждый код может принимать одно из 9 значений, то всего имеется 81 
возможный вариант расположения отрезка. Но, если Code(V<SUB>0</SUB>) равен 
Code(V<SUB>1</SUB>), то LineCode(V<SUB>0</SUB>,V<SUB>1</SUB>) равен 
LineCode(V<SUB>1</SUB>,V<SUB>0</SUB>). Имеется всего 9 таких случаев: 1-1, 2-2, 
<FONT face=symbol>ј</FONT> 9-9. Следовательно, число различных случаев 
уменьшается до 72. 
<P>Каждый LineCode требует своего набора вычислений для определения отсечения 
отрезка за минимальное время. Всего имеется 8 основных случаев отсечения, а 
остальные симметричны к ним. Рассмотрим эти 8 основных случаев. При этом будут 
использоваться следующие обозначения: 
<P><FONT face=symbol>·</FONT>&nbsp;начальная точка отрезка считается точкой 
номер 0 (V<SUB>0</SUB>), 
<P><FONT face=symbol>·</FONT>&nbsp;конечная точка отрезка считается точкой номер 
1 (V<SUB>1</SUB>), 
<P><FONT face=symbol>·</FONT> ClipA_B обозначает алгоритм расчета перемещения 
конечной точки номер А на сторону окна B (расчет пересечения прямой линии, на 
которой расположен отсекаемый отрезок со стороной окна B).<BR>
<P>Иллюстрации к случаям 1-7 приведены на рис.&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#r7_3">0.2.5</A>, для случая 8 - 
на рис.&nbsp;<A href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#r7_4">0.2.6</A>. 
<P>1. Начальная и конечная точки отрезка обе в области 5 (отрезок JK). Это 
простой случай принятия отрезка. 
<P>2. Начальная и конечная точки отрезка обе в области 4 (отрезок LA). Отрезок 
не пересекает видимую область, так что это простой случай отбрасывания. 
<P>3. Начальная точка в области 4, конечная - в области 1 (отрезок LB). Отрезок 
не пересекает видимую область, так что это простой случай отбрасывания. 
<P>4. Начальная точка в области 4, конечная - в области 2 (отрезки LC и LD). 
Отрезки явно пересекает Xлев, так что вначале надо определить соответствующую 
координату, используя алгоритм Clip0_Xleft. Для отрезка LC это дает 
V<SUB>0</SUB>y &gt; Yверх, так что отрезок должен быть отброшен без дальнейших 
вычислений. Отрезок LD входит в окно с левой стороны и может выходить через 
верх. Следовательно, следующее отсечение должно быть Clip1_Top, после которого 
отрезок принимается. 
<P>5. Начальная точка в области 4, конечная - в области 3 (отрезки LE, LF и LG). 
Отрезки явно пересекает Xлев. Так же как и для случая 4 вначале применяется 
Clip0_Xleft и отрезок LE отбрасывается если V<SUB>0</SUB>y &gt; Yверх. Если же 
получаем V<SUB>0</SUB>y <FONT face=symbol>Ј</FONT> Yверх, то отрезок должен 
выйти из области видимости через верхнее или правое ребро. Применяем отсечение 
Clip1_Top и сравниваем новое значение X-координаты конечной точки - 
V<SUB>1</SUB>x c Xправ. Если V<SUB>1</SUB>x <FONT face=symbol>Ј</FONT> Xправ, то 
отрезок (LF) проходит через верхнюю сторону, отрезок принимается и дальнейшие 
вычисления не нужны. Иначе отрезок (LG) проходит через правую сторону и 
требуется отсечение Clip1_Right. Отсечение закончено, отрезок принимается. 
<P>6. Начальная точка в области 4, конечная - в области 6 (отрезок LH). Данный 
отрезок видим. Вначале используем Clip0_Xleft затем Clip1_Right и принимаем 
отрезок. 
<P>7. Начальная точка в области 4, конечная - в области 5 (отрезок LI). Данный 
отрезок видим. Просто используем Clip0_Xleft и принимаем отрезок. 
<P>8. Начальная точка V<SUB>0</SUB> (R, S, T или U) в области 7, конечная точка 
V<SUB>1</SUB> (W, X, Y или Z) - в области 3 (см. рис.<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#r7_4">0.2.6</A>). В этом случае 
могут быть отброшены только два типа отрезков. Для минимизации вычислений 
используем Clip0_Xleft. Если V<SUB>0</SUB>y &gt; Yверх, то это первый случай 
отбрасывания (отрезок RW). Clip1_Xright и проверка V<SUB>1</SUB>y &lt; Yниз 
задают второй случай отбрасывания (отрезок UZ). Все другие отрезки должны быть 
видимы. Если V<SUB>0</SUB>y &lt; Yниз, тогда V<SUB>0</SUB> = T, иначе 
V<SUB>0</SUB> = S. Если V<SUB>0</SUB>y &lt; Yниз, то Clip1_Ybottom даст точку 
V<SUB>0</SUB> на ребре окна. Аналогично, если V<SUB>1</SUB>y &gt; Yверх, то 
V<SUB>1</SUB>=X и здесь требуется Clip1_Ytop перед приемом отрезка. Если 
V<SUB>1</SUB>y &lt; Yверх, тогда V<SUB>1</SUB> = Y. 
<P>
<P><A name=tth_fIg0.5></A><A name=r7_3>
<CENTER><BR><IMG alt="Рисунок 31" 
src="Учебное пособие Основные алгоритмы компьютерной графики_files/kg0231.gif">
<P>
<P></CENTER>
<CENTER>Рис. 0.2.5: Варианты расположения отрезка для неугловых 
областей</CENTER></A>
<P>
<P>
<P><A name=tth_fIg0.6></A><A name=r7_4>
<CENTER><BR><IMG alt="Рисунок 32" 
src="Учебное пособие Основные алгоритмы компьютерной графики_files/kg0232.gif">
<P>
<P></CENTER>
<CENTER>Рис. 0.2.6: Случай угловых областей</CENTER></A>
<P>
<P>Из этих восьми случаев легко симметрично сгенерировать все остальные. 
<P>Главное отличие FC-алгоритма от алгоритма Коэна-Сазерленда состоит в 
упорядочивании действий по отсечению. Эффективность алгоритма Коэна-Сазерленда 
ограничивается последовательным характером и фиксированным порядком действий по 
отсечению. Как пример (см. рис.&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#r7_4">0.2.6</A>) отрезок RW будет 
отсекаться в порядке: сверху, снизу, справа и слева. Число же отсечений для 
определения видимости равно 2 - снизу и слева. В FC-алгоритме, напротив, для 
каждого значения LineCode имеется свой набор действий по отсечению. Для 
приведенного выше примера потребуется только одно отсечение для определения 
невидимости отрезка RW. Кроме этого, повышению эффективности FC-алгоритма по 
сравнению с CS-алгоритмом способствует отсутствие ненужных циклов и, 
следовательно, перевычислений кодов конечных точек. 
<P>В Приложении 7 приведена C-подпрограмма V_FCclip, реализующая FC-алгоритм и 
свободная от ошибок в подпрограмме, приведенной в [<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#mbib37" name=CITEmbib37>37</A>]. 
Можно заметно сократить объем ее программного кода учтя симметрию и использовав 
указатели на данные либо переставляя данные. Например, в подпрограмме V_FCclip 
для отрезка LH (см. рис.&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#r7_3">0.2.5</A>, если он идет 
слева-направо вначале выполняется отсечение для начальной точки по левой стороне 
окна и затем для конечной - по правой. Если же отрезок идет справа-налево, то 
вначале вычисляется отсечение начальной точки по правой стороне и затем конечной 
- по левой. Очевидно, что эти два случая идентичны если поменять местами 
координаты начальной и конечной точек. 
<P>
<CENTER>
<H3><A name=tth_sEc0.6.3>0.6.3</A>&nbsp;&nbsp;Двумерный алгоритм 
Лианга-Барски</H3></CENTER>
<P>В 1982&nbsp;г. Лианг и Барски [<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#mbib32" name=CITEmbib32>32</A>] 
предложили алгоритмы отсечения прямоугольным окном с использованием 
параметрического представления для двух, трех и четырехмерного отсечения. По 
утверждению авторов, данный алгоритм в целом превосходит алгоритм 
Коэна-Сазерленда. Однако в работе [<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#mbib37" name=CITEmbib37>37</A>] 
показывается, что это утверждение справедливо только для случая когда оба конца 
видимого отрезка вне окна и окно небольшое (до 50&times;50 при разрешении 1000&times;1000). 
Приведенное далее изложение двумерного варианта алгоритма следует, основном, 
работе [<A href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#mbib32" 
name=CITEmbib32>32</A>]. 
<P>Как уже говорилось, при 2D отсечении прямые отсекаются по 2D области, 
называемой окном отсечения. В частности, внутренняя часть окна отсечения может 
быть выражена с помощью следующих неравенств (рис.&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#r7_5">0.2.7</A>). 
<P>
<P><A name=tth_fIg0.7></A><A name=f7_1>
<CENTER><BR><IMG alt="Рисунок 33" 
src="Учебное пособие Основные алгоритмы компьютерной графики_files/kg0233.gif">
<P></CENTER>
<P></A>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap></TD>
          <TD noWrap>
            <TABLE align=left border=0>
              <TBODY>
              <TR>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>Xлев </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap><FONT face=symbol>Ј</FONT> 
                    </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>x </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap><FONT face=symbol>Ј</FONT> 
                    </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>Xправ</TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=middle colSpan=0 noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>Yверх </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap><FONT face=symbol>Ј</FONT> 
                    </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>y </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap><FONT face=symbol>Ј</FONT> 
                    </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE>
                    <TBODY>
                    <TR>
                      <TD align=middle colSpan=0 
                  noWrap>Yниз</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></TD>
          <TD noWrap></TD></TR></TBODY></TABLE></TD>
    <TD align=right width=100>(0.2.1)</TD></TR></TBODY></TABLE></CENTER>
<P>#tth_closerowВнутренняя часть окна отсечения <A name=r7_5></A>
<P>
<P>Продолжим каждую из четырех границ окна до бесконечных прямых. Каждая из 
таких прямых делит плоскость на 2 области. Назовем "видимой частью" ту, в 
которой находится окно отсечения, как это показано на рис.&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#r7_6">0.2.8</A>. Видимой части 
соответствует внутренняя сторона линии границы. Невидимой части плоскости 
соответствует внешняя сторона линии границы. 
<P>
<P><A name=tth_fIg0.7></A><A name=r7_6>
<CENTER><BR><IMG alt="Рисунок 34" 
src="Учебное пособие Основные алгоритмы компьютерной графики_files/kg0234.gif">
<P></CENTER>
<CENTER>Рис. 0.2.7: Видимая часть линии границы</CENTER></A>
<P>
<P>Таким образом, окно отсечения может быть определено как область, которая 
находится на внутренней стороне всех линий границ. <A name=f7_2>
<CENTER><BR><IMG alt="Рисунок 35" 
src="Учебное пособие Основные алгоритмы компьютерной графики_files/kg0235.gif">
<P></CENTER>
<CENTER>Рис. 0.2.7: Пример рассчета отсечения</CENTER>
<P>Отсекаемый отрезок прямой может быть преобразован в параметрическое 
представление следующим образом. Пусть конечные точки отрезка есть V<SUB>0</SUB> 
и V<SUB>1</SUB> с координатами (x0,y0) и (x1,y1), соответственно. Тогда 
параметрическое представление линии может быть задано следующим образом: 
<P></A>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>x &nbsp;&nbsp; = &nbsp;&nbsp;x0 
            &nbsp;&nbsp;+&nbsp;&nbsp;dx&nbsp;&nbsp;·&nbsp;&nbsp;t; 
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y &nbsp;&nbsp; = &nbsp;&nbsp;y0 
            &nbsp;&nbsp;+&nbsp;&nbsp;dy&nbsp;&nbsp;·&nbsp;&nbsp;t, 
      </TD></TR></TBODY></TABLE></TD>
    <TD align=right width=100>(0.2.2)</TD></TR></TBODY></TABLE></CENTER>
<P><A name=f7_3></A>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>где &nbsp;&nbsp;&nbsp;&nbsp;dx &nbsp;&nbsp; 
            = &nbsp;&nbsp;x1 &nbsp;&nbsp;-&nbsp;&nbsp;x0; 
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dy &nbsp;&nbsp; = &nbsp;&nbsp;y1 
            &nbsp;&nbsp;-&nbsp;&nbsp;y0. </TD></TR></TBODY></TABLE></TD>
    <TD align=right width=100>(0.2.3)</TD></TR></TBODY></TABLE></CENTER>
<P>Или в общем виде для отрезка, заданного точками V<SUB>0</SUB> и 
V<SUB>1</SUB>: 
<P><A name=f7_4></A>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>V(t) &nbsp;&nbsp; = 
            &nbsp;&nbsp;V<SUB>0</SUB> &nbsp;&nbsp;+&nbsp;&nbsp;(V<SUB>1</SUB> 
            &nbsp;&nbsp;-&nbsp;&nbsp;V<SUB>0</SUB>) &nbsp;&nbsp;·&nbsp;&nbsp;t 
          </TD></TR></TBODY></TABLE></TD>
    <TD align=right width=100>(0.2.4)</TD></TR></TBODY></TABLE></CENTER>
<P>Для точек V<SUB>0</SUB> и V<SUB>1</SUB> параметр t равен 0 и 1, 
соответственно. Меняя t от 0 до 1 перемещаемся по отрезку 
V<SUB>0</SUB>V<SUB>1</SUB> от точки V<SUB>0</SUB> к точке V<SUB>1</SUB>. Изменяя 
t в интервале от -<FONT face=symbol>Ґ</FONT> до +<FONT face=symbol>Ґ</FONT>, 
получаем бесконечную (далее удлиненную) прямую, ориентация которой - от точки 
V<SUB>0</SUB> к точке V<SUB>1</SUB>. 
<P><BR><BR>Однако вернемся к формальному рассмотрению алгоритма отсечения. 
<P>Подставляя параметрическое представление, заданное уравнениями (<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#f7_2">0.2.2</A>) и (<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#f7_3">0.2.3</A>), в неравенства 
(<A href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#f7_1">0.2.1</A>), получим 
следующие соотношения для частей удлиненной линии, которая находится в окне 
отсечения: 
<P><A name=f7_5></A>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap></TD>
          <TD noWrap>
            <TABLE align=left border=0>
              <TBODY>
              <TR>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>-dx·t </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap><FONT face=symbol>Ј</FONT> 
                    </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>x0 &nbsp;&nbsp;-&nbsp;&nbsp;Xлев 
                      </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>и</TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>dx·t </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap><FONT face=symbol>Ј</FONT> 
                    </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>Xправ 
                        &nbsp;&nbsp;-&nbsp;&nbsp;x0,</TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=middle colSpan=0 noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>-dy·t </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap><FONT face=symbol>Ј</FONT> 
                    </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>y0 &nbsp;&nbsp;-&nbsp;&nbsp;Yниз 
                      </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>и</TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>dy·t </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap><FONT face=symbol>Ј</FONT> 
                    </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE>
                    <TBODY>
                    <TR>
                      <TD align=middle colSpan=0 noWrap>Yверх 
                        &nbsp;&nbsp;-&nbsp;&nbsp;y0.</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></TD>
          <TD noWrap></TD></TR></TBODY></TABLE></TD>
    <TD align=right width=100>(0.2.5)</TD></TR></TBODY></TABLE></CENTER>
<P>Заметим, что соотношения (<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#f7_5">0.2.5</A>) - неравенства, 
описывающие внутреннюю часть окна отсечения, в то время как равенства определяют 
его границы. 
<P>Рассматривая неравенства (<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#f7_5">0.2.5</A>), видим, что они 
имеют одинаковую форму вида: 
<P><A name=f7_6></A>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>P<SUB>i</SUB>·t &nbsp;&nbsp; <FONT 
            face=symbol>Ј</FONT> &nbsp;&nbsp;Q<SUB>i</SUB> 
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;для &nbsp;&nbsp;i&nbsp;&nbsp; = 
            1,2,3,4.</TD></TR></TBODY></TABLE></TD>
    <TD align=right width=100>(0.2.6)</TD></TR></TBODY></TABLE></CENTER>
<P>Здесь использованы следующие обозначения: 
<P><A name=f7_7></A>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap></TD>
          <TD noWrap>
            <TABLE align=left border=0>
              <TBODY>
              <TR>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>P<SUB>1</SUB> 
                  </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>= </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>-dx; </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap></TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>Q<SUB>1</SUB> 
                  </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>= </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>x0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>-</TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>Xлев;</TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=middle colSpan=0 noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>P<SUB>2</SUB> 
                  </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>= </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>dx; </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap></TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>Q<SUB>2</SUB> 
                  </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>= </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>Xправ </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>-</TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>x0;</TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=middle colSpan=0 noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>P<SUB>3</SUB> 
                  </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>= </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>-dy; </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap></TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>Q<SUB>3</SUB> 
                  </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>= </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>y0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>-</TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>Yниз;</TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=middle colSpan=0 noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>P<SUB>4</SUB> 
                  </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>= </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>dy; </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap></TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>Q<SUB>4</SUB> 
                  </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>= </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>Yверх </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>-</TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE>
                    <TBODY>
                    <TR>
                      <TD align=middle colSpan=0 
                noWrap>y0.</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></TD>
          <TD noWrap></TD></TR></TBODY></TABLE></TD>
    <TD align=right width=100>(0.2.7)</TD></TR></TBODY></TABLE></CENTER>
<P>Вспоминая определения внутренней и внешней стороны линии границы (см. 
рис.&nbsp;<A href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#r7_6">0.2.8</A>), 
замечаем, что каждое из неравенств (<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#f7_6">0.2.6</A>) соответствует 
одной из граничных линий (левой, правой, нижней и верхней, соответственно) и 
описывает ее видимую сторону. (Например, для i=1 имеем: P<SUB>1</SUB>·t 
&nbsp;&nbsp; <FONT face=symbol>Ј</FONT> &nbsp;&nbsp;Q<SUB>1</SUB> <FONT 
face=symbol>Ю</FONT> -dx·t &nbsp;&nbsp; <FONT face=symbol>Ј</FONT> 
&nbsp;&nbsp;x0 - Xлев<FONT face=symbol>Ю</FONT> x0 &nbsp;&nbsp;+&nbsp;&nbsp;dx·t 
&nbsp;&nbsp; <FONT face=symbol>і</FONT> &nbsp;&nbsp;Xлев). Удлиним 
V<SUB>0</SUB>V<SUB>1</SUB> в бесконечную прямую. Тогда каждое неравенство задает 
диапазон значений параметра t, для которых эта удлиненная линия находится на 
видимой стороне соответствующей линии границы. Более того, конкретное значение 
параметра t для точки пересечения есть t = Q<SUB>i</SUB>/P<SUB>i</SUB>. Причем 
знак Q<SUB>i</SUB> показывает на какой стороне соответствующей линии границы 
находится точка V<SUB>0</SUB>. А именно, если Qi &nbsp;&nbsp; <FONT 
face=symbol>і</FONT> &nbsp;&nbsp;0, тогда V<SUB>0</SUB> находится на видимой 
стороне линии границы, включая и ее. Если же Q<SUB>i</SUB> &nbsp;&nbsp; &lt; 
&nbsp;&nbsp;0, тогда V<SUB>0</SUB> находится на невидимой стороне. 
<P>Рассмотрим P<SUB>i</SUB> в соотношениях (<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#f7_7">0.2.7</A>). Ясно, что любое 
P<SUB>i</SUB> может быть меньше 0, больше 0 и равно 0. 
<P>
<CENTER><U><B>P</B><SUB><B>i</B></SUB> &nbsp;&nbsp; &lt; &nbsp;&nbsp;0</U> 
</CENTER>
<P>Если P<SUB>i</SUB> &nbsp;&nbsp; &lt; &nbsp;&nbsp;0, тогда соответствующее 
неравенство становится: 
<P><A name=f7_8></A>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>t &nbsp;&nbsp; <FONT face=symbol>і</FONT> 
            &nbsp;&nbsp;Q<SUB>i</SUB>&nbsp;&nbsp;/&nbsp;&nbsp;P<SUB>i</SUB>. 
        </TD></TR></TBODY></TABLE></TD>
    <TD align=right width=100>(0.2.8)</TD></TR></TBODY></TABLE></CENTER>
<P>Для пояснения на рис.&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#r7_8">0.2.10</A> показано 
пересечение с левой и правой границами при P<SUB>i</SUB> &nbsp;&nbsp; &lt; 
&nbsp;&nbsp;0. 
<P>
<P><A name=tth_fIg0.8></A><A name=r7_8>
<CENTER><BR><IMG alt="Рисунок 36" 
src="Учебное пособие Основные алгоритмы компьютерной графики_files/kg0236.gif">
<P></CENTER>
<CENTER>Рис. 0.2.8: Пересечение удлиненной линии, определяемой точками 
V<SUB>0</SUB>V<SUB>1</SUB> и идущей с невидимой на видимую сторону, с левой и 
правой границами.</CENTER></A>
<P>
<P>Очевидно, что диапазон значений параметра t, для которых удлиненная линия 
находится на видимой стороне соответствующей граничной линии, имеет минимум в 
точке пересечения направленной удлиненной линии, заданной вектором 
V<SUB>0</SUB>V<SUB>1</SUB> и идущей с невидимой на видимую сторону граничной 
линии (так как только на границе t равно Q<SUB>i</SUB> 
&nbsp;&nbsp;/&nbsp;&nbsp;P<SUB>i</SUB>, а в остальной части видимой стороны 
больше). 
<P>
<CENTER><U><B>Pi</B> &nbsp;&nbsp; &gt; &nbsp;&nbsp;0</U> </CENTER>
<P>Аналогично, если P<SUB>i</SUB> &nbsp;&nbsp; &gt; &nbsp;&nbsp;0, тогда 
соответствующее неравенство становится: 
<P><A name=f7_9></A>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>t &nbsp;&nbsp; <FONT face=symbol>Ј</FONT> 
            &nbsp;&nbsp;Q<SUB>i</SUB>&nbsp;&nbsp;/&nbsp;&nbsp;P<SUB>i</SUB>. 
        </TD></TR></TBODY></TABLE></TD>
    <TD align=right width=100>(0.2.9)</TD></TR></TBODY></TABLE></CENTER>
<P>Для пояснения на рис.&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#r7_9">0.2.11</A> показано 
пересечение с левой и правой границами при P<SUB>i</SUB> &nbsp;&nbsp; &gt; 
&nbsp;&nbsp;0. 
<P>
<P><A name=tth_fIg0.9></A><A name=r7_9>
<CENTER><BR><IMG alt="Рисунок 37" 
src="Учебное пособие Основные алгоритмы компьютерной графики_files/kg0237.gif">
<P></CENTER>
<CENTER>Рис. 0.2.9: Пересечение удлиненной линии, определяемой точками 
V<SUB>0</SUB>V<SUB>1</SUB> и идущей с видимой на невидимую сторону, с левой и 
правой границами.</CENTER></A>
<P>
<P>Так как значения параметра t только на границе равны 
Q<SUB>i</SUB>/P<SUB>i</SUB>, а в остальной видимой части меньше 
Q<SUB>i</SUB>/P<SUB>i</SUB>, то значение параметра t имеет максимум на границе. 
<P>
<CENTER><U><B>P</B><SUB><B>i</B></SUB> &nbsp;&nbsp; = &nbsp;&nbsp;0</U> 
</CENTER>
<P>Наконец, если P<SUB>i</SUB> &nbsp;&nbsp; = &nbsp;&nbsp;0, тогда 
соответствующее неравенство превращается в: 
<P><A name=f7_10></A>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>0 &nbsp;&nbsp; <FONT face=symbol>Ј</FONT> 
            &nbsp;&nbsp;Q<SUB>i</SUB>. </TD></TR></TBODY></TABLE></TD>
    <TD align=right width=100>(0.2.10)</TD></TR></TBODY></TABLE></CENTER>
<P>Заметим, что здесь нет зависимости от t, т.е. неравенство выполняется для 
всех t, если Q<SUB>i</SUB> &nbsp;&nbsp; <FONT face=symbol>і</FONT> &nbsp;&nbsp;0 
и не имеет решения при Q<SUB>i</SUB>&nbsp;&nbsp; &lt; &nbsp;&nbsp;0. Для 
пояснения на рис.&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#r7_10">0.2.12</A> иллюстрируется 
случай P<SUB>i</SUB> &nbsp;&nbsp; = &nbsp;&nbsp;0. 
<P>
<P><A name=tth_fIg0.10></A><A name=r7_10>
<CENTER><BR><IMG alt="Рисунок 38" 
src="Учебное пособие Основные алгоритмы компьютерной графики_files/kg0238.gif">
<P></CENTER>
<CENTER>Рис. 0.2.10: Относительное расположение удлиненной линии, заданной 
точками V<SUB>0</SUB>V<SUB>1</SUB> и идущей параллельно левой и правой 
границам.</CENTER></A>
<P>
<P>
<P><BR>
<P><BR>Геометрически, если P<SUB>i</SUB> &nbsp;&nbsp; = &nbsp;&nbsp;0, то нет 
точек пересечения удлиненной линии, определяемой точками 
V<SUB>0</SUB>V<SUB>1</SUB>, с линиями границы. Более того, если Q<SUB>i</SUB> 
&nbsp;&nbsp; &lt; &nbsp;&nbsp;0, то удлиненная линия находится на внешней 
стороне линии границы, а при Q<SUB>i</SUB> &nbsp;&nbsp; <FONT 
face=symbol>і</FONT> &nbsp;&nbsp;0 находится на внутренней стороне (включая ее). 
В последнем случае отрезок V<SUB>0</SUB>V<SUB>1</SUB> может быть видим или нет в 
зависимости от того где находятся точки V<SUB>0</SUB>V<SUB>1</SUB> на удлиненной 
линии. В предыдущем же случае нет видимого сегмента, так как удлиненная линия 
вне окна, т.е. это случай тривиального отбрасывания. 
<P>Все эти случаи суммированы на блок-схеме, представленной на рис.&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#r7_11">0.2.13</A>. 
<P>
<P><A name=tth_fIg0.11></A><A name=r7_11>
<CENTER><BR><IMG alt="Рисунок 39" 
src="Учебное пособие Основные алгоритмы компьютерной графики_files/kg0239.gif">
<P>
<P></CENTER>
<CENTER>Рис. 0.2.11: Блок-схема алгоритма Лианга-Барски</CENTER></A>
<P>
<P>Итак, рассмотрение четырех неравенств дает диапазон значений параметра t, для 
которого удлиненная линия находится внутри окна отсечения. Однако, отрезок 
V<SUB>0</SUB>V<SUB>1</SUB> только часть удлиненной линии и он описывается 
значениями параметра t в диапазоне: 0 &nbsp;&nbsp; <FONT face=symbol>Ј</FONT> 
&nbsp;&nbsp;t&nbsp;&nbsp; <FONT face=symbol>Ј</FONT> &nbsp;&nbsp;1. Таким 
образом, решение задачи двумерного отсечения эквивалентно решению неравенств (<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#f7_6">0.2.6</A>) при условии 0 
&nbsp;&nbsp; <FONT face=symbol>Ј</FONT> &nbsp;&nbsp;t &nbsp;&nbsp; <FONT 
face=symbol>Ј</FONT> &nbsp;&nbsp;1. Решение этой задачи сводится к далее 
описанному отысканию максимумов и минимумов. 
<P>Вспомним, что для всех i таких, что P<SUB>i</SUB> &nbsp;&nbsp; &lt; 
&nbsp;&nbsp;0, условие видимости имеет вид: t &nbsp;&nbsp; <FONT 
face=symbol>і</FONT> 
&nbsp;&nbsp;Q<SUB>i</SUB>&nbsp;&nbsp;/&nbsp;&nbsp;P<SUB>i</SUB>. Из условия 
принадлежности точек удлиненной линии отрезку V<SUB>0</SUB>V<SUB>1</SUB> имеем t 
&nbsp;&nbsp; <FONT face=symbol>і</FONT> &nbsp;&nbsp;0. Таким образом, нужно 
искать: 
<P><A name=f7_11></A>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>t &nbsp;&nbsp; <FONT face=symbol>і</FONT> 
            &nbsp;&nbsp;max 
            &nbsp;&nbsp;(&nbsp;&nbsp;{&nbsp;&nbsp;Q<SUB>i</SUB>&nbsp;&nbsp;/&nbsp;&nbsp;P<SUB>i</SUB>&nbsp;&nbsp;<FONT 
            face=symbol>|</FONT>&nbsp;&nbsp;P<SUB>i</SUB>&nbsp;&nbsp; &lt; 
            &nbsp;&nbsp;0,&nbsp;&nbsp;i = 1,2,3,4&nbsp;&nbsp;}&nbsp;&nbsp;<FONT 
            face=symbol>И</FONT>{0}}.</TD></TR></TBODY></TABLE></TD>
    <TD align=right width=100>(0.2.11)</TD></TR></TBODY></TABLE></CENTER>
<P>Аналогично, для всех i таких что P<SUB>i</SUB> &nbsp;&nbsp; &gt; 
&nbsp;&nbsp;0, условие видимости - t &nbsp;&nbsp; <FONT face=symbol>Ј</FONT> 
&nbsp;&nbsp;Q<SUB>i</SUB>&nbsp;&nbsp;/&nbsp;&nbsp;P<SUB>i</SUB> и, 
следовательно, <FONT face=symbol>Ј</FONT> 1. 
<P><A name=f7_12></A>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>t &nbsp;&nbsp; <FONT face=symbol>Ј</FONT> 
            &nbsp;&nbsp;min 
            &nbsp;&nbsp;(&nbsp;&nbsp;{&nbsp;&nbsp;Q<SUB>i</SUB>&nbsp;&nbsp;/&nbsp;&nbsp;P<SUB>i</SUB>&nbsp;&nbsp;<FONT 
            face=symbol>|</FONT>&nbsp;&nbsp;P<SUB>i</SUB>&nbsp;&nbsp; &gt; 
            &nbsp;&nbsp;0,&nbsp;&nbsp;i = 1,2,3,4&nbsp;&nbsp;}&nbsp;&nbsp;<FONT 
            face=symbol>И</FONT>{1}}.</TD></TR></TBODY></TABLE></TD>
    <TD align=right width=100>(0.2.12)</TD></TR></TBODY></TABLE></CENTER>
<P>Наконец, для всех i, таких что P<SUB>i</SUB> &nbsp;&nbsp; = &nbsp;&nbsp;0 
следует проверить знак Q<SUB>i</SUB>. Если Q<SUB>i</SUB> &nbsp;&nbsp; &lt; 
&nbsp;&nbsp;0, то это случай тривиального отбрасывания, задача отсечения решена 
и дальнейшие вычисления не нужны. Если же Q<SUB>i</SUB> &nbsp;&nbsp; <FONT 
face=symbol>і</FONT> &nbsp;&nbsp;0, то информации, даваемой неравенством, 
недостаточно и это неравенство игнорируется. 
<P>Правая часть неравенств (<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#f7_11">0.2.11</A>) и (<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#f7_12">0.2.12</A>) - значения 
параметра t, соответствующие началу и концу видимого сегмента, соответственно. 
Обозначим эти значения как t<SUB>0</SUB> и t<SUB>1</SUB>: 
<P><A name=f7_13></A>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap></TD>
          <TD noWrap>
            <TABLE align=left border=0>
              <TBODY>
              <TR>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>t<SUB>0</SUB> 
                  </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap><FONT face=symbol>і</FONT> 
                    </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>max 
                        ({Q<SUB>i</SUB>/P<SUB>i</SUB> <FONT face=symbol>|</FONT> 
                        P<SUB>i</SUB> &lt; 0, </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>i = 1,2,3,4} 
                </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap><FONT 
                      face=symbol>И</FONT>{0}},</TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=middle colSpan=0 noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>t<SUB>1</SUB> 
                  </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap><FONT face=symbol>Ј</FONT> 
                    </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>min 
                        ({Q<SUB>i</SUB>/P<SUB>i</SUB> <FONT face=symbol>|</FONT> 
                        P<SUB>i</SUB> &gt; 0, </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>i = 1,2,3,4} 
                </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE>
                    <TBODY>
                    <TR>
                      <TD align=middle colSpan=0 noWrap><FONT 
                        face=symbol>И</FONT>{1}}.</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></TD>
          <TD noWrap></TD></TR></TBODY></TABLE></TD>
    <TD align=right width=100>(0.2.13)</TD></TR></TBODY></TABLE></CENTER>
<P>Если сегмент отрезка V<SUB>0</SUB>V<SUB>1</SUB> видим, то ему соответствует 
интервал параметра: 
<P><A name=f7_14></A>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>t<SUB>0</SUB> &nbsp;&nbsp; <FONT 
            face=symbol>Ј</FONT> &nbsp;&nbsp;t &nbsp;&nbsp; <FONT 
            face=symbol>Ј</FONT> &nbsp;&nbsp;t<SUB>1</SUB>. 
    </TD></TR></TBODY></TABLE></TD>
    <TD align=right width=100>(0.2.14)</TD></TR></TBODY></TABLE></CENTER>
<P>Следовательно, необходимое условие видимости сегмента: 
<P><A name=f7_15></A>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>t<SUB>0</SUB> &nbsp;&nbsp; <FONT 
            face=symbol>Ј</FONT> &nbsp;&nbsp;t<SUB>1</SUB> 
    </TD></TR></TBODY></TABLE></TD>
    <TD align=right width=100>(0.2.15)</TD></TR></TBODY></TABLE></CENTER>
<P>Но это недостаточное условие, так как оно игнорирует случай тривиального 
отбрасывания при P<SUB>i</SUB> &nbsp;&nbsp; = &nbsp;&nbsp;0, если Q<SUB>i</SUB> 
&nbsp;&nbsp; &lt; &nbsp;&nbsp;0. Тем не менее это достаточное условие для 
отбрасывания, т.е. если t<SUB>0</SUB> &nbsp;&nbsp; &gt; 
&nbsp;&nbsp;t<SUB>1</SUB>, то отрезок должен быть отброшен. Алгоритм проверяет, 
если P<SUB>i</SUB> &nbsp;&nbsp; = &nbsp;&nbsp;0 
&nbsp;&nbsp;&nbsp;&nbsp;c&nbsp;&nbsp;&nbsp;&nbsp;Q<SUB>i</SUB> &nbsp;&nbsp; &lt; 
&nbsp;&nbsp;0, или t<SUB>0</SUB> &gt; t<SUB>1</SUB> и в этом случае отрезок 
немедленно отбрасывается без дальнейших вычислений. 
<P>В алгоритме t<SUB>0</SUB> и t<SUB>1</SUB> инициализируются в 0 и 1, 
соответственно. Затем последовательно рассматривается каждое отношение 
Q<SUB>i</SUB>/P<SUB>i</SUB>. 
<P>Если P<SUB>i</SUB> &nbsp;&nbsp; &lt; &nbsp;&nbsp;0, то отношение вначале 
сравнивается с t<SUB>1</SUB> и, если оно больше t<SUB>1</SUB>, то это случай 
отбрасывания. В противном случае оно сравнивается с t<SUB>0</SUB> и, если оно 
больше, то t<SUB>0</SUB> должно быть заменено на новое значение. 
<P>Если P<SUB>i</SUB> &gt; 0, то отношение вначале сравнивается с t<SUB>0</SUB> 
и, если оно меньше t<SUB>0</SUB>, то это случай отбрасывания. В противном случае 
оно сравнивается с t<SUB>1</SUB> и, если оно меньше, то t<SUB>1</SUB> должно 
быть заменено на новое значение. 
<P>Наконец, если Pi &nbsp;&nbsp; = &nbsp;&nbsp;0 
&nbsp;&nbsp;и&nbsp;&nbsp;Q<SUB>i</SUB> &lt; 0, то это случай отбрасывания. 
<P>На последнем этапе алгоритма, если отрезок еще не отброшен, то t<SUB>0</SUB> 
и t<SUB>1</SUB> используются для вычисления соответствующих точек. Однако, если 
t<SUB>0</SUB> = 0, то конечная точка равна V<SUB>0</SUB> и не требуется 
вычислений. Аналогично, если t<SUB>1</SUB> = 1, то конечная точка - 
V<SUB>1</SUB> и вычисления также не нужны. 
<P>Геометрический смысл этого процесса состоит в том, что отрезок удлиняется для 
определения где эта удлиненная линия пересекает каждую линию границы. Более 
детально, каждая конечная точка заданного отрезка V<SUB>0</SUB>V<SUB>1</SUB> 
используется как начальное значение для конечных точек отсеченного отрезка 
C<SUB>0</SUB>C<SUB>1</SUB>. Затем вычисляются точки пересечения удлиненной линии 
с каждой линией границы (эти вычисления соответствуют вызову процедуры LB_tclip 
в программе). Если для данной линии границы направление, определяемое 
V<SUB>0</SUB>V<SUB>1</SUB>, идет с невидимой на видимую сторону линии границы, 
то эта точка пересечения вначале сравнивается с С<SUB>1</SUB>. Если точка 
находится далее вдоль линии, тогда C<SUB>1</SUB> (и таким образом, 
С<SUB>0</SUB>С<SUB>1</SUB>) должна быть на невидимой стороне линии, поэтому 
отрезок должен быть отброшен. В противном случае точка пересечения сравнивается 
с С<SUB>0</SUB>; если точка далее вдоль линии, тогда С<SUB>0</SUB> перемещается 
вперед к этой точке. 
<P>С другой стороны, если направление с видимой на невидимую сторону, тогда 
точка пересечения вначале сравнивается с С<SUB>0</SUB>. Если С<SUB>0</SUB> далее 
вдоль линии, чем точка пересечения, тогда C<SUB>0</SUB> (и, следовательно 
C<SUB>0</SUB>C<SUB>1</SUB>) находится на невидимой стороне линии границы, т.е. 
отрезок должен быть отброшен. В противном случае точка пересечения сравнивается 
с С<SUB>1</SUB> и, если С<SUB>1</SUB> далее вдоль линии, тогда С<SUB>1</SUB> 
перемещается назад к точке пересечения. 
<P>Наконец, если удлиненная линия параллельна граничной линии и она на невидимой 
стороне, то отрезок отбрасывается. В конце алгоритма, если отрезок не отброшен, 
тогда C<SUB>0</SUB> и С<SUB>1</SUB> используются как конечные точки видимой 
части отрезка. 
<P>В Приложении 7 приведена C-подпрограмма V_LBclip, реализующая описанный выше 
алгоритм. 
<P>
<CENTER>
<H3><A name=tth_sEc0.6.4>0.6.4</A>&nbsp;&nbsp;Двумерный алгоритм 
Кируса-Бека</H3></CENTER>
<P>Все рассмотренные выше алгоритмы проводили отсечение по прямоугольному окну, 
стороны которого параллельны осям координат. Это, конечно, наиболее частый 
случай отсечения. Однако, во многих случаях требуется отсечение по произвольному 
многоугольнику, например, в алгоритмах удаления невидимых частей сцены. В этом 
случае наиболее удобно использование параметрического представления линий, не 
зависящего от выбора системы координат. 
<P>Из предыдущего пункта ясно, что для выполнения отсечения в параметрическом 
представлении необходимо иметь способ определения ориентации удлиненной линии, 
содержащей отсекаемый отрезок, относительно линии границы - с внешней стороны на 
внутреннюю или с внутренней на внешнюю, а также иметь способ определения 
расположения точки, принадлежащей отрезку, относительно окна - вне, на границе, 
внутри. 
<P>Для этих целей в алгоритме Кируса-Бека [<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#mbib29" name=CITEmbib29>29</A>], 
реализующем отсечение произвольным выпуклым многоугольником, используется вектор 
внутренней нормали к ребру окна. 
<P>Внутренней нормалью <B>N</B><SUB>в</SUB> в точке А к стороне окна называется 
нормаль, направленная в сторону области, задаваемой окном отсечения. 
<P>Рассмотрим основные идеи алгоритма Кируса-Бека. 
<P>Так как многоугольник предполагается выпуклым, то может быть только две точки 
пересечения отрезка с окном. Поэтому надо найти два значения параметра t, 
соответствующие начальной и конечной точкам видимой части отрезка. 
<P>Пусть <B>N</B><SUB>i</SUB> - внутренняя нормаль к i-й граничной линии окна, а 
<B>P</B> = <B>V<SUB>1</SUB></B> - <B>V<SUB>0</SUB></B> - вектор, определяющий 
ориентацию отсекаемого отрезка, тогда ориентация отрезка относительно i-й 
стороны окна определяется знаком скалярного произведения P<SUB>i</SUB> 
&nbsp;&nbsp; = &nbsp;&nbsp;<B>N</B><SUB>i</SUB> ·<B>V</B>, равного произведению 
длин векторов на косинус наименьшего угла, требуемого для поворота вектора 
<B>N</B><SUB>i</SUB> до совпадения по направлению с вектором <B>V</B>: 
<P><A name=f7_16></A>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>P<SUB>i</SUB> = <B>N</B><SUB>i</SUB> 
            ·<B>P</B> &nbsp;&nbsp; = &nbsp;&nbsp;<B>N</B><SUB>i</SUB> 
            ·(<B>V</B><SUB>1</SUB> 
            &nbsp;&nbsp;-&nbsp;&nbsp;<B>V</B><SUB>0</SUB>).</TD></TR></TBODY></TABLE></TD>
    <TD align=right width=100>(0.2.16)</TD></TR></TBODY></TABLE></CENTER>
<P><A name=f7_17></A>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap></TD>
          <TD noWrap>
            <TABLE align=left border=0>
              <TBODY>
              <TR>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>При </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>P<SUB>i</SUB> &lt; 0 
                    </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>отсекаемый отрезок направлен с 
                        внутренней на внешнюю стороны i-й граничной линии окна 
                        (см. рис.&nbsp;<A 
                        href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#r7_12">0.2.14</A>a).</TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=middle colSpan=0 noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>При </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>P<SUB>i</SUB> = 0 
                  </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>точки V<SUB>0</SUB> и 
                        V<SUB>1</SUB> либо совпадают, либо отсекаемый отрезок 
                        параллелен i-й граничной линии окна (см. рис.&nbsp;<A 
                        href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#r7_12">0.2.14</A>б).</TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=middle colSpan=0 noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>При </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>P<SUB>i</SUB> &gt; 0 
                    </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE>
                    <TBODY>
                    <TR>
                      <TD align=middle colSpan=0 noWrap>отсекаемый отрезок 
                        направлен с внешней на внутреннюю сторону i-й граничной 
                        линии окна (см. рис.&nbsp;<A 
                        href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#r7_12">0.2.14</A>в).</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></TD>
          <TD noWrap></TD></TR></TBODY></TABLE></TD>
    <TD align=right width=100>(0.2.17)</TD></TR></TBODY></TABLE></CENTER>
<P>
<P><A name=tth_fIg0.12></A><A name=r7_12>
<TABLE width="100%">
  <TBODY>
  <TR>
    <TD align=middle>
      <CENTER><BR><IMG alt="Рисунок 40" 
      src="Учебное пособие Основные алгоритмы компьютерной графики_files/kg0240.gif">
      <P>a)<BR>Изнутри<BR>наружу </CENTER></P></TD>
    <TD align=middle>
      <CENTER><BR><IMG alt="Рисунок 41" 
      src="Учебное пособие Основные алгоритмы компьютерной графики_files/kg0241.gif">
      <P>б)<BR>Параллельно<BR>границе </CENTER></P></TD>
    <TD align=middle>
      <CENTER><BR><IMG alt="Рисунок 42" 
      src="Учебное пособие Основные алгоритмы компьютерной графики_files/kg0242.gif">
      <P>в)<BR>Снаружи<BR>внутрь </CENTER></P></TD></TR></TBODY></TABLE>
<CENTER>Рис. 0.2.12: Ориентация отсекаемого отрезка относительно 
окна</CENTER></A>
<P>
<P>Для определения расположения точки относительно окна вспомним параметрическое 
представление отсекаемого отрезка: 
<P><A name=f7_18></A>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>V(t) &nbsp;&nbsp; = 
            &nbsp;&nbsp;V<SUB>0</SUB> &nbsp;&nbsp;+&nbsp;&nbsp;(V<SUB>1</SUB> 
            &nbsp;&nbsp;-&nbsp;&nbsp;V<SUB>0</SUB>)·t; 
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0 <FONT face=symbol>і</FONT> t 
            <FONT face=symbol>і</FONT> 1.</TD></TR></TBODY></TABLE></TD>
    <TD align=right width=100>(0.2.18)</TD></TR></TBODY></TABLE></CENTER>
<P>Рассмотрим теперь скалярное произведение внутренней нормали 
<B>N</B><SUB>i</SUB> к i-й границе на вектор <B>Q</B>(t) = <B>V</B>(t) - 
<B>F</B><SUB>i</SUB>, начинающийся в начальной точке ребра окна и 
заканчивающийся в некоторой точке V(t) удлиненной линии. 
<P><A name=f7_19></A>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>Q<SUB>i</SUB> &nbsp;&nbsp; = 
            &nbsp;&nbsp;<B>N</B><SUB>i</SUB> ·<B>Q</B> &nbsp;&nbsp; = 
            &nbsp;&nbsp;<B>N</B><SUB>i</SUB> ·[<B>V</B>(t) 
            &nbsp;&nbsp;-&nbsp;&nbsp;<B>F</B><SUB>i</SUB>] 
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;для 
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i &nbsp;&nbsp; = 
            &nbsp;&nbsp;1,2,3&nbsp;&nbsp;<FONT 
      face=symbol>ј</FONT></TD></TR></TBODY></TABLE></TD>
    <TD align=right width=100>(0.2.19)</TD></TR></TBODY></TABLE></CENTER>
<P>Аналогично предыдущему имеем (рис.&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#r7_13">0.2.15</A>): 
<P><A name=f7_20></A>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap></TD>
          <TD noWrap>
            <TABLE align=left border=0>
              <TBODY>
              <TR>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>При&nbsp;&nbsp;Q<SUB>i</SUB> 
                        &lt; 0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle 
                        noWrap>точка&nbsp;&nbsp;<B>V</B>(t)&nbsp;&nbsp;лежит&nbsp;&nbsp;с 
                        &nbsp;&nbsp;внешней&nbsp;&nbsp;стороны&nbsp;&nbsp;границы</TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=middle colSpan=0 noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>При&nbsp;&nbsp;Q<SUB>i</SUB> = 0 
                      </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle 
                        noWrap>точка&nbsp;&nbsp;я<B>V</B>(t)&nbsp;&nbsp;лежит&nbsp;&nbsp;на&nbsp;&nbsp;самой 
                        &nbsp;&nbsp;границе</TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=middle colSpan=0 noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>При&nbsp;&nbsp;Q<SUB>i</SUB> 
                        &gt; 0 </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE>
                    <TBODY>
                    <TR>
                      <TD align=middle colSpan=0 
                        noWrap>точка&nbsp;&nbsp;<B>V</B>(t)&nbsp;&nbsp;лежит&nbsp;&nbsp;с 
                        &nbsp;&nbsp;внутренней&nbsp;&nbsp;стороны&nbsp;&nbsp;границы</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></TD>
          <TD noWrap></TD></TR></TBODY></TABLE></TD>
    <TD align=right width=100>(0.2.20)</TD></TR></TBODY></TABLE></CENTER>
<P>
<P><A name=tth_fIg0.13></A><A name=r7_13>
<TABLE width="100%">
  <TBODY>
  <TR>
    <TD align=middle>
      <CENTER><BR><IMG alt="Рисунок 43" 
      src="Учебное пособие Основные алгоритмы компьютерной графики_files/kg0243.gif">
      <P>a)<BR>Точка V вне </CENTER></P></TD>
    <TD align=middle>
      <CENTER><BR><IMG alt="Рисунок 44" 
      src="Учебное пособие Основные алгоритмы компьютерной графики_files/kg0244.gif">
      <P>б)<BR>Точка V на границе </CENTER></P></TD>
    <TD align=middle>
      <CENTER><BR><IMG alt="Рисунок 45" 
      src="Учебное пособие Основные алгоритмы компьютерной графики_files/kg0245.gif">
      <P>в)<BR>Точка V внутри </CENTER></P></TD></TR></TBODY></TABLE>
<CENTER>Рис. 0.2.13: Расположение точки относительно окна</CENTER></A>
<P>
<P>Подставляя в (<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#f7_19">0.2.19</A>) 
параметрическое представление (<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#f7_18">0.2.18</A>), получим 
условие пересечения отрезка с границей окна: 
<P><A name=f7_21></A>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap><B>N</B><SUB>i</SUB> 
            ·[&nbsp;&nbsp;<B>V</B><SUB>0</SUB> 
            &nbsp;&nbsp;+&nbsp;&nbsp;(<B>V</B><SUB>1</SUB> 
            &nbsp;&nbsp;-&nbsp;&nbsp;<B>V</B><SUB>0</SUB>)·t 
            &nbsp;&nbsp;-&nbsp;&nbsp;<B>F</B><SUB>i</SUB> &nbsp;&nbsp;] 
            &nbsp;&nbsp; = &nbsp;&nbsp;0</TD></TR></TBODY></TABLE></TD>
    <TD align=right width=100>(0.2.21)</TD></TR></TBODY></TABLE></CENTER>
<P>Раскрывая скобки, получим: 
<P><A name=f7_22></A>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle 
            noWrap><B>N</B><SUB>i</SUB>·[&nbsp;&nbsp;<B>V</B><SUB>0</SUB> 
            &nbsp;&nbsp;-&nbsp;&nbsp;<B>F</B><SUB>i</SUB>&nbsp;&nbsp;] 
            &nbsp;&nbsp;+&nbsp;&nbsp;<B>N</B><SUB>i</SUB>·[&nbsp;&nbsp;<B>V</B><SUB>1</SUB> 
            &nbsp;&nbsp;-&nbsp;&nbsp;<B>V</B><SUB>0</SUB>&nbsp;&nbsp;] ·t 
            &nbsp;&nbsp; = &nbsp;&nbsp;0.</TD></TR></TBODY></TABLE></TD>
    <TD align=right width=100>(0.2.22)</TD></TR></TBODY></TABLE></CENTER>
<P>Используя (<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#f7_16">0.2.16</A>) и (<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#f7_19">0.2.19</A>) перепишем (<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#f7_21">0.2.21</A>): 
<P><A name=f7_23></A>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>(&nbsp;&nbsp;<B>N</B><SUB>i</SUB> 
            &nbsp;&nbsp;·&nbsp;&nbsp;<B>P</B>&nbsp;&nbsp;)&nbsp;&nbsp;·&nbsp;&nbsp;t 
            &nbsp;&nbsp;+&nbsp;&nbsp;<B>N</B><SUB>i</SUB> 
            &nbsp;&nbsp;·&nbsp;&nbsp;<B>Q</B> &nbsp;&nbsp; = 
            &nbsp;&nbsp;P<SUB>i</SUB> &nbsp;&nbsp;·&nbsp;&nbsp;t 
            &nbsp;&nbsp;+&nbsp;&nbsp;Q<SUB>i</SUB>.</TD></TR></TBODY></TABLE></TD>
    <TD align=right width=100>(0.2.23)</TD></TR></TBODY></TABLE></CENTER>
<P>Разрешая (<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#f7_22">0.2.22</A>) относительно 
t, получим: 
<P><A name=f7_24></A>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>t &nbsp;&nbsp; = &nbsp;&nbsp;-</TD>
          <TD align=middle noWrap>Q<SUB>i</SUB>
            <HR noShade>
             P<SUB>i</SUB><BR></TD>
          <TD align=middle noWrap>&nbsp;&nbsp; = &nbsp;&nbsp;-</TD>
          <TD align=middle noWrap><B>N</B><SUB>i</SUB> ·<B>Q</B>
            <HR noShade>
             <B>N</B><SUB>i</SUB> ·<B>P</B><BR></TD>
          <TD align=middle 
            noWrap>&nbsp;&nbsp;при&nbsp;&nbsp;&nbsp;&nbsp;яP<SUB>i</SUB> <FONT 
            face=symbol>№</FONT> 0, &nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;&nbsp; = 
            &nbsp;&nbsp;1,2,3,<FONT face=symbol>ј</FONT></TD></TR></TBODY></TABLE></TD>
    <TD align=right width=100>(0.2.24)</TD></TR></TBODY></TABLE></CENTER>
<P>Это уравнение и используется для вычисления значений параметров, 
соответствующих начальной и конечной точкам видимой части отрезка. 
<P>Как следует из (<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#f7_17">0.2.17</A>), P<SUB>i</SUB> 
равно нулю если отрезок либо вырожден в точку, либо параллелен границе. В этом 
случае следует проанализировать знак Q<SUB>i</SUB> и принять или не принять 
решение об отбрасывании отрезка целиком в соответствии с условиями (<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#f7_17">0.2.17</A>). 
<P>Если же P<SUB>i</SUB> не равно 0, то уравнение (<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#f7_24">0.2.24</A>) используется 
для вычисления значений параметров t, соответствующих точкам пересечений 
удлиненной линии с линиями границ. 
<P>Алгоритм построен следующим образом: 
<P>Искомые значения параметров t<SUB>0</SUB> и t<SUB>1</SUB> точек пересечения 
инициализируются значениями 0 и 1, соответствующими началу и концу отсекаемого 
отрезка. 
<P>Затем в цикле для каждой i-й стороны окна отсечения вычисляются значения 
скалярных произведений, входящих в (<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#f7_23">0.2.23</A>). 
<P>Если очередное P<SUB>i</SUB> равно 0, то отсекаемый отрезок либо вырожден в 
точку, либо параллелен i-й стороне окна. При этом достаточно проанализировать 
знак Q<SUB>i</SUB>. Если Q<SUB>i</SUB> &lt; 0, то отрезок вне окна и отсечение 
закончено иначе рассматривается следующая сторона окна. 
<P>Если же P<SUB>i</SUB> не равно 0, то по (<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#f7_24">0.2.24</A>) можно 
вычислить значение параметра t для точки пересечения отсекаемого отрезка с i-й 
границей. Так как отрезок V<SUB>0</SUB>V<SUB>1</SUB> соответствует диапазону 0 
<FONT face=symbol>Ј</FONT> t <FONT face=symbol>Ј</FONT> 1, то все решения, 
выходящие за данный диапазон следует отбросить. Выбор оставшихся решений 
определяется знаком P<SUB>i</SUB>. 
<P>Если P<SUB>i</SUB> &lt; 0, т.е. удлиненная линия направлена с внутренней на 
внешнюю стороны граничной линии, то ищутся значения параметра для конечной точки 
видимой части отрезка. В этом случае определяется минимальное значение из всех 
получаемых решений. Оно даст значение параметра t<SUB>1</SUB> для конечной точки 
отсеченного отрезка. Если текущее полученное значение t<SUB>1</SUB> окажется 
меньше, чем t<SUB>0</SUB>, то отрезок отбрасывается, так как нарушено условие 
t<SUB>0</SUB> &nbsp;&nbsp; <FONT face=symbol>Ј</FONT> &nbsp;&nbsp;t<SUB>1</SUB>. 

<P>Если же P<SUB>i</SUB> &nbsp;&nbsp; &gt; &nbsp;&nbsp;0, т.е. удлиненная линия 
направлена с внешней на внутреннюю стороны граничной линии, то ищутся значения 
параметра для начальной точки видимой части отрезка. В этом случае определяется 
максимальное значение из всех получаемых решений. Оно даст значение параметра 
t<SUB>0</SUB> для начальной точки отсеченного отрезка. Если текущее полученное 
значение t<SUB>0</SUB> окажется больше, чем t<SUB>1</SUB>, то отрезок 
отбрасывается, так как нарушено условие t<SUB>0</SUB> &nbsp;&nbsp; <FONT 
face=symbol>Ј</FONT> &nbsp;&nbsp;t<SUB>1</SUB>. 
<P>На заключительном этапе алгоритма значения t<SUB>0</SUB> и t<SUB>1</SUB> 
используются для вычисления координат точек пересечения отрезка с окном. При 
этом, если t<SUB>0</SUB> = 0, то начальная точка осталась V<SUB>0</SUB> и 
вычисления не нужны. Аналогично, если t<SUB>1</SUB> = 1, то конечная точка 
осталась V<SUB>1</SUB> и вычисления также не нужны. 
<P>Все эти случаи пояснены на блок-схеме, представленной на рис.&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#r7_14">0.2.16</A>. 
<P>
<P><A name=tth_fIg0.14></A><A name=r7_14>
<CENTER><BR><IMG alt="Рисунок 46" 
src="Учебное пособие Основные алгоритмы компьютерной графики_files/kg0246.gif">
<P>
<P></CENTER>
<CENTER>Рис. 0.2.14: Блок-схема алгоритма Кируса-Бека</CENTER></A>
<P>
<P>Вычисления значений параметров t<SUB>0</SUB> и t<SUB>1</SUB> выполняются в 
соответствии с выражениями (<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#f7_41">0.2.25</A>). 
<P><A name=f7_41></A>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap></TD>
          <TD noWrap>
            <TABLE align=left border=0>
              <TBODY>
              <TR>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>t<SUB>0</SUB> 
                  </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap><FONT face=symbol>і</FONT> 
                    </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>max 
                        ({-Q<SUB>i</SUB>/P<SUB>i</SUB> <FONT 
                        face=symbol>|</FONT> P<SUB>i</SUB> &gt; 0, 
                  </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>i = 1,2,<FONT 
                        face=symbol>ј</FONT>} </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap><FONT 
                      face=symbol>И</FONT>{0}},</TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=middle colSpan=0 noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>t<SUB>1</SUB> 
                  </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap><FONT face=symbol>Ј</FONT> 
                    </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>min 
                        ({-Q<SUB>i</SUB>/P<SUB>i</SUB> <FONT 
                        face=symbol>|</FONT> P<SUB>i</SUB> &lt; 0, 
                  </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>i = 1,2,<FONT 
                        face=symbol>ј</FONT>} </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE>
                    <TBODY>
                    <TR>
                      <TD align=middle colSpan=0 noWrap><FONT 
                        face=symbol>И</FONT>{1}}.</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></TD>
          <TD noWrap></TD></TR></TBODY></TABLE></TD>
    <TD align=right width=100>(0.2.25)</TD></TR></TBODY></TABLE></CENTER>
<P>В Приложении 7 приведена C-подпрограмма V_CBclip, реализующая описанный выше 
алгоритм. 
<P>
<CENTER>
<H4>Проверка выпуклости и определение нормалей</H4></CENTER>
<P>Как видно из описания, алгоритм Кируса-Бека отсекает только по выпуклому 
окну. Кроме этого требуются значения внутренних нормалей к сторонам окна. 
Естественно выполнить эти вычисления в момент задания окна, так как следует 
ожидать, что одним окном будет отсекаться достаточно много отрезков. 
<P>
<P><BR>
<P><BR>
<H4>Алгоритм с использованием векторных произведений</H4>
<P>Проверка на выпуклость может производиться анализом знаков векторных 
произведений смежных ребер (рис.&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#r07_15">0.2.17</A>). 
<P>
<CENTER><FONT face=symbol>|</FONT>[A\vec] &times;[B\vec]<FONT face=symbol>|</FONT> = 
A·B · sin (AB <FONT face=symbol>Щ</FONT> ) </CENTER>
<P>
<P><A name=tth_fIg0.15></A><A name=r07_15>
<CENTER><BR><IMG alt="Рисунок 47" 
src="Учебное пособие Основные алгоритмы компьютерной графики_files/kg0247.gif">
<P>
<P></CENTER>
<CENTER>Рис. 0.2.15: Проверка выпуклости и определение нормалей</CENTER></A>
<P>
<P>Если знак векторного произведения равен 0, то вершина вырождена, т.е. смежные 
ребра лежат на одной прямой (см. рис.&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#r07_15">0.2.17</A>&nbsp;б), 
вершина Q). 
<P>Если все знаки равны 0, то многоугольник отсечения вырождается в отрезок. 
<P>Если же векторные произведения имеют разные знаки, то многоугольник отсечения 
невыпуклый (см. рис.&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#r07_15">0.2.17</A>&nbsp;б)). 
<P>Если все знаки неотрицательные, то многоугольник выпуклый, причем обход 
вершин выполняется против часовой стрелки (см. рис.&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#r07_15">0.2.17</A>&nbsp;а)), т.е. 
внутренние нормали ориентированы влево от контура. Следовательно вектор 
внутреннего перпендикуляра к стороне может быть получен поворотом ребра на 
+90<SUP><FONT face=symbol>°</FONT></SUP> (в реализации алгоритма вычисления 
нормалей на самом деле вычисляется не нормаль к стороне, а перпендикуляр, так 
как при вычислении значения t по соотношению (<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#f7_22">0.2.22</A>) длина не 
важна). 
<P>Если все знаки неположительные, то многоугольник выпуклый, причем обход 
вершин выполняется по часовой стрелке, т.е. внутренние нормали ориентированы 
вправо от контура. Следовательно вектор внутреннего перпендикуляра к стороне 
может быть получен поворотом ребра на -90<SUP><FONT face=symbol>°</FONT></SUP>. 
<P>Описанный алгоритм реализован в процедуре V_SetPclip, приведенной в 
Приложении 7 и предназначенной для установки многоугольного окна отсечения. 
<P>
<H4>Разбиение невыпуклых многоугольников</H4>
<P>Одновременное проведение операций проверки на выпуклость и разбиение простого 
невыпуклого многоугольника на выпуклые обеспечивается методом переноса и 
поворотов окна. 
<P>Алгоритм метода при обходе вершин многоугольника против часовой стрелки 
состоит в следующем: 
<OL type=1>
  <P>
  <LI>Для каждой i-й вершины многоугольник сдвигается для переноса упомянутой 
  вершины в начало координат. 
  <LI>Многоугольник поворачивается против часовой стрелки для совмещения (i+1)-й 
  вершины с положительной полуосью X.<BR>Вектор внутреннего перпендикуляра к 
  ребру, образованному вершинами i-й и (i+1)-й, вычисляется поворотом ребра на 
  -90<SUP><FONT face=symbol>°</FONT></SUP> против часовой стрелки. 
  <LI>Анализируется знак Y-координаты (i+2)-й вершины.<BR>Если Y<SUB>i+2</SUB> 
  <FONT face=symbol>і</FONT> 0, то в (i+1)-й вершине выпуклость.<BR>Если 
  Y<SUB>i+2</SUB> <FONT face=symbol>і</FONT> 0, то в (i+1)-й вершине 
  невыпуклость.<BR>Если имеется невыпуклость, то многоугольник разрезается на 
  два вдоль положительной полуоси X.<BR>Для этого вычисляется пересечение 
  положительной полуоси X с первой из сторон. Формируются два новых 
  многоугольника: первый многоугольник - вершины с (i+1)-й до точки пересечения 
  - вершины 2, 3, 4, 6, 7, [7\tilde] на рис.&nbsp;<A 
  href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#r07_16">0.2.18</A>&nbsp;б);<BR>второй 
  многоугольник - все остальные вершины - вершины [7\tilde], 8, 0, 1 на 
  рис.&nbsp;<A 
  href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#r07_16">0.2.18</A>&nbsp;б)<BR></LI></OL>
<P>Так как вновь полученные многоугольники могут в свою очередь оказаться 
невыпуклыми, алгоритм применяется к ним, пока все многоугольники не станут 
выпуклыми. 
<P>
<P><A name=tth_fIg0.16></A><A name=r07_16>
<TABLE width="100%">
  <TBODY>
  <TR>
    <TD align=middle>
      <CENTER><BR><IMG alt="Рисунок 48" 
      src="Учебное пособие Основные алгоритмы компьютерной графики_files/kg0248.gif">
      <P>a)<BR>Исходное окно </CENTER></P></TD>
    <TD align=middle>
      <CENTER><BR><IMG alt="Рисунок 49" 
      src="Учебное пособие Основные алгоритмы компьютерной графики_files/kg0249.gif">
      <P>б)<BR>Невыпуклость после вершины 2 </CENTER></P></TD>
    <TD align=middle>
      <CENTER><BR><IMG alt="Рисунок 50" 
      src="Учебное пособие Основные алгоритмы компьютерной графики_files/kg0250.gif">
      <P>в)<BR>Невыпуклость после вершины 5 </CENTER></P></TD></TR></TBODY></TABLE>
<CENTER>Рис. 0.2.16: Проверка выпуклости и разбиение многоугольника</CENTER></A>
<P>
<P>Повторное применение алгоритма в многоугольнику, образованному вершинами 2, 
3, 4, 6, 7, [7\tilde], показано на рис.&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#r07_16">0.2.18</A>&nbsp;в). 
<P>Данный алгоритм не обеспечивает минимальность числа вновь полученных выпуклых 
многоульников и некорректно работает если имеется самопересечение сторон, как 
это показано на рис.&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#r07_17">0.2.19</A>. 
<P>
<P><A name=tth_fIg0.17></A>
<CENTER><BR><IMG alt="Рисунок 51" 
src="Учебное пособие Основные алгоритмы компьютерной графики_files/kg0251.gif">
<P>
<P></CENTER>
<CENTER>Рис. 0.2.17: Многоугольник с самопересечением сторон</CENTER><A 
name=r07_17></A>
<P>
<P>
<CENTER>
<H3><A name=tth_sEc0.6.5>0.6.5</A>&nbsp;&nbsp;Сравнение алгоритмов двумерного 
отсечения</H3></CENTER>
<P>Во многих работах приводятся качественные соображения по быстродействию 
различных алгоритмов отсечения. В части работ, например, [<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#mbib32" name=CITEmbib32>32</A>] 
или [<A href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#mbib37" 
name=CITEmbib37>37</A>] приводятся результаты численных экспериментов по 
измерению скорости. Как правило, авторы работ этими экспериментами подтверждают 
преимущество своих алгоритмов. 
<P>В целом можно отметить несколько методических неточностей проведения таких 
экспериментов: 
<P><FONT face=symbol>·</FONT> неясно насколько одинаково хороши реализации 
собственного и сравниваемых алгоритмов,<BR>
<P><FONT face=symbol>·</FONT> эксперименты ([<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#mbib32" name=CITEmbib32>32</A>] и 
[<A href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#mbib37" 
name=CITEmbib37>37</A>] проводились в среде OC UNIX и нет убедительных 
свидетельств отсутствия влияния окружения на результаты,<BR>
<P><FONT face=symbol>·</FONT> неясно насколько правильно выбиралось число 
повторений одного отсечения относительно минимального измеряемого кванта 
времени.<BR>
<P>Исходя из этих соображений были проведены численные эксперименты по измерению 
быстродействия алгоритмов отсечения Коэна-Сазерленда, FC-алгоритма, 
Лианга-Барски и Кируса-Бека. 
<P>Использовались подпрограммы, приведенные в Приложении 7 при отсечении окнами 
различных размеров при полном разрешении 
<P>1000&times;1000. Процедуры транслировались и исполнялись на 486/DX4/100 в среде на 
Turbo&nbsp;C под управлением MS&nbsp;DOS 6.22. 
<P>Аналогично [<A href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#mbib37" 
name=CITEmbib37>37</A>] были подготовлены 5 наборов данных по 1000 отрезков 
каждый со случайной генерацией конечных точек при следующих ограничениях: 
<P>1. Обе конечные точки отрезка внутри окна. 
<P>2. Одна конечная точка отрезка в окне, другая вне. 
<P>3. Обе конечные точки вне окна но с видимым сегментом. 
<P>4. Обе конечные точки вне окна и отрезок невидим. 
<P>5. Обе конечные точки генерировались случайно без ограничений. 
<P>Сгенерированные данные сохранялись в файлах и считывались в оперативную 
память перед очередным прогоном теста. Процедуры отсечения использовали данные 
из оперативной памяти. Для исключения временных затрат, связанных с организацией 
циклов и запросом координат отрезков, предварительно прогонялся тест с 
использованием "пустой" процедуры отсечения. Отсечение каждого отрезка 
проводилось 1000 раз. Измерение времени проводилось перед началом цикла по 
координатам. 
<P>Результаты измерений приведены в таблицах <A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#t7_3">0.2.3</A>, <A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#t7_4">0.2.4</A>, <A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#t7_5">0.2.5</A>, <A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#t7_6">0.2.6</A>, <A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#t7_7">0.2.7</A>. Первая колонка 
таблиц - мои измерения. Вторая колонка таблиц - данные из [<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#mbib37" name=CITEmbib37>37</A>]. 
Последние проводились на DEC VAX 8600 с ускорителем плавающей арифметики, 
транслировались C-компилятором без оптимизации и исполнялись под управлением 
ULTRIX V 1.1 (C). 
<P><A name=tth_tAb0.1></A>
<P>
<CENTER>Таблица 0.2.1: Время (с) для простого приема отрезка.</CENTER><A 
name=t7_3>
<TABLE width="100%">
  <TBODY>
  <TR>
    <TD align=middle vAlign=top>
      <TABLE border=1>
        <TBODY>
        <TR>
          <TD align=middle colSpan=5>Эксперимент на 486/DX4/100</TD>
        <TR>
          <TD align=middle>Окно</TD>
          <TD align=middle>CS </TD>
          <TD align=middle>FC </TD>
          <TD align=middle>LB </TD>
          <TD align=middle>CB </TD>
        <TR>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
        <TR>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
        <TR>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
        <TR>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
        <TR>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
        <TR>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
        <TR>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
        <TR>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
        <TR>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
        <TR>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
        <TR>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD></TD></TR></TBODY></TABLE></TD>
    <TD align=middle vAlign=top>
      <TABLE border=1>
        <TBODY>
        <TR>
          <TD align=middle colSpan=5>Данные из статьи [<A 
            href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#mbib37" 
            name=CITEmbib37>37</A>]</TD>
        <TR>
          <TD align=middle>Окно</TD>
          <TD align=middle>CS </TD>
          <TD align=middle>FC </TD>
          <TD align=middle>LB </TD>
          <TD align=middle>CB </TD>
        <TR>
          <TD align=middle>0.0 </TD>
          <TD align=middle>25.3</TD>
          <TD align=middle>11.0</TD>
          <TD align=middle>113.0</TD>
          <TD align=middle>377.1</TD>
        <TR>
          <TD align=middle>10.0</TD>
          <TD align=middle>25.3</TD>
          <TD align=middle>11.0</TD>
          <TD align=middle>121.6</TD>
          <TD align=middle>393.9</TD>
        <TR>
          <TD align=middle>20.0</TD>
          <TD align=middle>25.3</TD>
          <TD align=middle>10.7</TD>
          <TD align=middle>122.3</TD>
          <TD align=middle>390.6</TD>
        <TR>
          <TD align=middle>30.0</TD>
          <TD align=middle>25.4</TD>
          <TD align=middle>11.0</TD>
          <TD align=middle>122.0</TD>
          <TD align=middle>395.0</TD>
        <TR>
          <TD align=middle>40.0</TD>
          <TD align=middle>25.4</TD>
          <TD align=middle>11.0</TD>
          <TD align=middle>123.2</TD>
          <TD align=middle>394.3</TD>
        <TR>
          <TD align=middle>50.0</TD>
          <TD align=middle>25.3</TD>
          <TD align=middle>11.2</TD>
          <TD align=middle>121.5</TD>
          <TD align=middle>394.6</TD>
        <TR>
          <TD align=middle>60.0</TD>
          <TD align=middle>25.0</TD>
          <TD align=middle>10.9</TD>
          <TD align=middle>121.6</TD>
          <TD align=middle>394.5</TD>
        <TR>
          <TD align=middle>70.0</TD>
          <TD align=middle>25.4</TD>
          <TD align=middle>11.0</TD>
          <TD align=middle>122.7</TD>
          <TD align=middle>394.7</TD>
        <TR>
          <TD align=middle>80.0</TD>
          <TD align=middle>25.2</TD>
          <TD align=middle>10.2</TD>
          <TD align=middle>121.4</TD>
          <TD align=middle>393.3</TD>
        <TR>
          <TD align=middle>90.0</TD>
          <TD align=middle>25.2</TD>
          <TD align=middle>11.0</TD>
          <TD align=middle>124.8</TD>
          <TD align=middle>394.4</TD>
        <TR>
          <TD align=middle>98.0</TD>
          <TD align=middle>25.1</TD>
          <TD align=middle>10.6</TD>
          <TD align=middle>122.7</TD>
          <TD 
align=middle>393.6</TD></TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></A>
<P>
<P>
<P><A name=tth_tAb0.2></A>
<CENTER>Таблица 0.2.2: Время (с) для отрезков с одним концом в окне.</CENTER><A 
name=t7_4>
<TABLE width="100%">
  <TBODY>
  <TR>
    <TD align=middle vAlign=top>
      <TABLE border=1>
        <TBODY>
        <TR>
          <TD align=middle colSpan=5>Эксперимент на 486/DX4/100</TD>
        <TR>
          <TD align=middle>Окно</TD>
          <TD align=middle>CS </TD>
          <TD align=middle>FC </TD>
          <TD align=middle>LB </TD>
          <TD align=middle>CB </TD>
        <TR>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
        <TR>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
        <TR>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
        <TR>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
        <TR>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
        <TR>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
        <TR>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
        <TR>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
        <TR>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
        <TR>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
        <TR>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD></TD></TR></TBODY></TABLE></TD>
    <TD align=middle vAlign=top>
      <TABLE border=1>
        <TBODY>
        <TR>
          <TD align=middle colSpan=5>Данные из статьи [<A 
            href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#mbib37" 
            name=CITEmbib37>37</A>]</TD>
        <TR>
          <TD align=middle>Окно</TD>
          <TD align=middle>CS </TD>
          <TD align=middle>FC </TD>
          <TD align=middle>LB </TD>
          <TD align=middle>CB </TD>
        <TR>
          <TD align=middle>0.0 </TD>
          <TD align=middle>124.0</TD>
          <TD align=middle>71.6</TD>
          <TD align=middle>146.7</TD>
          <TD align=middle>390.5</TD>
        <TR>
          <TD align=middle>10.0</TD>
          <TD align=middle>110.2</TD>
          <TD align=middle>61.1</TD>
          <TD align=middle>148.5</TD>
          <TD align=middle>399.1</TD>
        <TR>
          <TD align=middle>20.0</TD>
          <TD align=middle>107.0</TD>
          <TD align=middle>57.7</TD>
          <TD align=middle>148.0</TD>
          <TD align=middle>398.5</TD>
        <TR>
          <TD align=middle>30.0</TD>
          <TD align=middle>104.3</TD>
          <TD align=middle>57.2</TD>
          <TD align=middle>147.5</TD>
          <TD align=middle>401.4</TD>
        <TR>
          <TD align=middle>40.0</TD>
          <TD align=middle>101.8</TD>
          <TD align=middle>55.2</TD>
          <TD align=middle>148.7</TD>
          <TD align=middle>403.9</TD>
        <TR>
          <TD align=middle>50.0</TD>
          <TD align=middle>100.8</TD>
          <TD align=middle>54.8</TD>
          <TD align=middle>149.2</TD>
          <TD align=middle>397.2</TD>
        <TR>
          <TD align=middle>60.0</TD>
          <TD align=middle>100.8</TD>
          <TD align=middle>54.4</TD>
          <TD align=middle>148.9</TD>
          <TD align=middle>400.7</TD>
        <TR>
          <TD align=middle>70.0</TD>
          <TD align=middle>96.9</TD>
          <TD align=middle>53.6</TD>
          <TD align=middle>146.9</TD>
          <TD align=middle>399.5</TD>
        <TR>
          <TD align=middle>80.0</TD>
          <TD align=middle>96.3</TD>
          <TD align=middle>51.9</TD>
          <TD align=middle>148.3</TD>
          <TD align=middle>399.0</TD>
        <TR>
          <TD align=middle>90.0</TD>
          <TD align=middle>95.6</TD>
          <TD align=middle>51.9</TD>
          <TD align=middle>148.5</TD>
          <TD align=middle>400.3</TD>
        <TR>
          <TD align=middle>98.0</TD>
          <TD align=middle>94.6</TD>
          <TD align=middle>50.6</TD>
          <TD align=middle>147.1</TD>
          <TD 
align=middle>400.7</TD></TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></A>
<P>
<P>
<P><A name=tth_tAb0.3></A>
<CENTER>Таблица 0.2.3: Время (с) для видимых отрезков вне окна.</CENTER><A 
name=t7_5>
<TABLE width="100%">
  <TBODY>
  <TR>
    <TD align=middle vAlign=top>
      <TABLE border=1>
        <TBODY>
        <TR>
          <TD align=middle colSpan=5>Эксперимент на 486/DX4/100</TD>
        <TR>
          <TD align=middle>Окно</TD>
          <TD align=middle>CS </TD>
          <TD align=middle>FC </TD>
          <TD align=middle>LB </TD>
          <TD align=middle>CB </TD>
        <TR>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
        <TR>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
        <TR>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
        <TR>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
        <TR>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
        <TR>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
        <TR>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
        <TR>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
        <TR>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
        <TR>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
        <TR>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD></TD></TR></TBODY></TABLE></TD>
    <TD align=middle vAlign=top>
      <TABLE border=1>
        <TBODY>
        <TR>
          <TD align=middle colSpan=5>Данные из статьи [<A 
            href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#mbib37" 
            name=CITEmbib37>37</A>]</TD>
        <TR>
          <TD align=middle>Окно</TD>
          <TD align=middle>CS </TD>
          <TD align=middle>FC </TD>
          <TD align=middle>LB </TD>
          <TD align=middle>CB </TD>
        <TR>
          <TD align=middle>0.0 </TD>
          <TD align=middle>233.0</TD>
          <TD align=middle>135.4</TD>
          <TD align=middle>174.8</TD>
          <TD align=middle>406.6</TD>
        <TR>
          <TD align=middle>10.0</TD>
          <TD align=middle>193.1</TD>
          <TD align=middle>104.9</TD>
          <TD align=middle>173.2</TD>
          <TD align=middle>406.4</TD>
        <TR>
          <TD align=middle>20.0</TD>
          <TD align=middle>183.0</TD>
          <TD align=middle>98.4</TD>
          <TD align=middle>174.8</TD>
          <TD align=middle>406.1</TD>
        <TR>
          <TD align=middle>30.0</TD>
          <TD align=middle>177.5</TD>
          <TD align=middle>97.5</TD>
          <TD align=middle>174.4</TD>
          <TD align=middle>409.4</TD>
        <TR>
          <TD align=middle>40.0</TD>
          <TD align=middle>177.1</TD>
          <TD align=middle>96.6</TD>
          <TD align=middle>175.6</TD>
          <TD align=middle>409.8</TD>
        <TR>
          <TD align=middle>50.0</TD>
          <TD align=middle>173.9</TD>
          <TD align=middle>95.5</TD>
          <TD align=middle>174.2</TD>
          <TD align=middle>405.0</TD>
        <TR>
          <TD align=middle>60.0</TD>
          <TD align=middle>168.9</TD>
          <TD align=middle>93.4</TD>
          <TD align=middle>173.2</TD>
          <TD align=middle>405.9</TD>
        <TR>
          <TD align=middle>70.0</TD>
          <TD align=middle>168.0</TD>
          <TD align=middle>92.9</TD>
          <TD align=middle>173.4</TD>
          <TD align=middle>406.5</TD>
        <TR>
          <TD align=middle>80.0</TD>
          <TD align=middle>166.4</TD>
          <TD align=middle>92.1</TD>
          <TD align=middle>173.6</TD>
          <TD align=middle>413.8</TD>
        <TR>
          <TD align=middle>90.0</TD>
          <TD align=middle>164.8</TD>
          <TD align=middle>91.7</TD>
          <TD align=middle>173.3</TD>
          <TD align=middle>411.9</TD>
        <TR>
          <TD align=middle>98.0</TD>
          <TD align=middle>163.9</TD>
          <TD align=middle>91.0</TD>
          <TD align=middle>172.6</TD>
          <TD 
align=middle>403.7</TD></TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></A>
<P>
<P>
<P><A name=tth_tAb0.4></A>
<CENTER>Таблица 0.2.4: Время (с) для невидимых отрезков вне окна.</CENTER><A 
name=t7_6>
<TABLE width="100%">
  <TBODY>
  <TR>
    <TD align=middle vAlign=top>
      <TABLE border=1>
        <TBODY>
        <TR>
          <TD align=middle colSpan=5>Эксперимент на 486/DX4/100</TD>
        <TR>
          <TD align=middle>Окно</TD>
          <TD align=middle>CS </TD>
          <TD align=middle>FC </TD>
          <TD align=middle>LB </TD>
          <TD align=middle>CB </TD>
        <TR>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
        <TR>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
        <TR>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
        <TR>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
        <TR>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
        <TR>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
        <TR>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
        <TR>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
        <TR>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
        <TR>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
        <TR>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD></TD></TR></TBODY></TABLE></TD>
    <TD align=middle vAlign=top>
      <TABLE border=1>
        <TBODY>
        <TR>
          <TD align=middle colSpan=5>Данные из статьи [<A 
            href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#mbib37" 
            name=CITEmbib37>37</A>]</TD>
        <TR>
          <TD align=middle>Окно</TD>
          <TD align=middle>CS </TD>
          <TD align=middle>FC </TD>
          <TD align=middle>LB </TD>
          <TD align=middle>CB </TD>
        <TR>
          <TD align=middle>0.0 </TD>
          <TD align=middle>46.9</TD>
          <TD align=middle>25.0</TD>
          <TD align=middle>75.9</TD>
          <TD align=middle>230.4</TD>
        <TR>
          <TD align=middle>10.0</TD>
          <TD align=middle>36.9</TD>
          <TD align=middle>18.2</TD>
          <TD align=middle>79.2</TD>
          <TD align=middle>233.9</TD>
        <TR>
          <TD align=middle>20.0</TD>
          <TD align=middle>34.7</TD>
          <TD align=middle>16.8</TD>
          <TD align=middle>79.3</TD>
          <TD align=middle>237.0</TD>
        <TR>
          <TD align=middle>30.0</TD>
          <TD align=middle>31.9</TD>
          <TD align=middle>15.1</TD>
          <TD align=middle>78.8</TD>
          <TD align=middle>234.6</TD>
        <TR>
          <TD align=middle>40.0</TD>
          <TD align=middle>29.1</TD>
          <TD align=middle>13.4</TD>
          <TD align=middle>78.7</TD>
          <TD align=middle>225.9</TD>
        <TR>
          <TD align=middle>50.0</TD>
          <TD align=middle>28.4</TD>
          <TD align=middle>12.6</TD>
          <TD align=middle>78.8</TD>
          <TD align=middle>229.0</TD>
        <TR>
          <TD align=middle>60.0</TD>
          <TD align=middle>26.4</TD>
          <TD align=middle>11.7</TD>
          <TD align=middle>78.0</TD>
          <TD align=middle>226.1</TD>
        <TR>
          <TD align=middle>70.0</TD>
          <TD align=middle>25.5</TD>
          <TD align=middle>11.7</TD>
          <TD align=middle>77.2</TD>
          <TD align=middle>223.1</TD>
        <TR>
          <TD align=middle>80.0</TD>
          <TD align=middle>24.7</TD>
          <TD align=middle>11.2</TD>
          <TD align=middle>76.2</TD>
          <TD align=middle>222.3</TD>
        <TR>
          <TD align=middle>90.0</TD>
          <TD align=middle>25.0</TD>
          <TD align=middle>10.8</TD>
          <TD align=middle>75.9</TD>
          <TD align=middle>220.7</TD>
        <TR>
          <TD align=middle>98.0</TD>
          <TD align=middle>24.6</TD>
          <TD align=middle>10.8</TD>
          <TD align=middle>68.9</TD>
          <TD 
align=middle>197.5</TD></TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></A>
<P>
<P>
<P><A name=tth_tAb0.5></A>
<CENTER>Таблица 0.2.5: Время (с) для случайных отрезков.</CENTER><A name=t7_7>
<TABLE width="100%">
  <TBODY>
  <TR>
    <TD align=middle vAlign=top>
      <TABLE border=1>
        <TBODY>
        <TR>
          <TD align=middle colSpan=5>Эксперимент на 486/DX4/100</TD>
        <TR>
          <TD align=middle>Окно</TD>
          <TD align=middle>CS </TD>
          <TD align=middle>FC </TD>
          <TD align=middle>LB </TD>
          <TD align=middle>CB </TD>
        <TR>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
        <TR>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
        <TR>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
        <TR>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
        <TR>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
        <TR>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
        <TR>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
        <TR>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
        <TR>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
        <TR>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
        <TR>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD>
          <TD align=middle></TD></TD></TR></TBODY></TABLE></TD>
    <TD align=middle vAlign=top>
      <TABLE border=1>
        <TBODY>
        <TR>
          <TD align=middle colSpan=5>Данные из статьи [<A 
            href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#mbib37" 
            name=CITEmbib37>37</A>]</TD>
        <TR>
          <TD align=middle>Окно</TD>
          <TD align=middle>CS </TD>
          <TD align=middle>FC </TD>
          <TD align=middle>LB </TD>
          <TD align=middle>CB </TD>
        <TR>
          <TD align=middle>0.0 </TD>
          <TD align=middle>53.7</TD>
          <TD align=middle>27.9</TD>
          <TD align=middle>80.1</TD>
          <TD align=middle>240.5</TD>
        <TR>
          <TD align=middle>10.0</TD>
          <TD align=middle>104.6</TD>
          <TD align=middle>55.9</TD>
          <TD align=middle>124.5</TD>
          <TD align=middle>324.3</TD>
        <TR>
          <TD align=middle>20.0</TD>
          <TD align=middle>100.4</TD>
          <TD align=middle>54.5</TD>
          <TD align=middle>131.7</TD>
          <TD align=middle>347.7</TD>
        <TR>
          <TD align=middle>30.0</TD>
          <TD align=middle>98.4</TD>
          <TD align=middle>53.0</TD>
          <TD align=middle>137.7</TD>
          <TD align=middle>367.7</TD>
        <TR>
          <TD align=middle>40.0</TD>
          <TD align=middle>95.1</TD>
          <TD align=middle>50.7</TD>
          <TD align=middle>139.4</TD>
          <TD align=middle>375.4</TD>
        <TR>
          <TD align=middle>50.0</TD>
          <TD align=middle>87.2</TD>
          <TD align=middle>46.5</TD>
          <TD align=middle>140.9</TD>
          <TD align=middle>387.1</TD>
        <TR>
          <TD align=middle>60.0</TD>
          <TD align=middle>76.0</TD>
          <TD align=middle>41.1</TD>
          <TD align=middle>138.7</TD>
          <TD align=middle>388.7</TD>
        <TR>
          <TD align=middle>70.0</TD>
          <TD align=middle>65.1</TD>
          <TD align=middle>34.4</TD>
          <TD align=middle>135.4</TD>
          <TD align=middle>393.0</TD>
        <TR>
          <TD align=middle>80.0</TD>
          <TD align=middle>52.8</TD>
          <TD align=middle>26.8</TD>
          <TD align=middle>132.1</TD>
          <TD align=middle>392.1</TD>
        <TR>
          <TD align=middle>90.0</TD>
          <TD align=middle>39.0</TD>
          <TD align=middle>19.0</TD>
          <TD align=middle>126.8</TD>
          <TD align=middle>395.3</TD>
        <TR>
          <TD align=middle>98.0</TD>
          <TD align=middle>28.0</TD>
          <TD align=middle>12.4</TD>
          <TD align=middle>123.5</TD>
          <TD 
align=middle>393.4</TD></TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></A>
<P>
<P>
<CENTER>
<H3><A name=tth_sEc0.6.6>0.6.6</A>&nbsp;&nbsp;Трехмерное отсечение 
отрезка</H3></CENTER>
<P>
<CENTER>
<H3><A name=tth_sEc0.6.7>0.6.7</A>&nbsp;&nbsp;Отсечение отрезка в однородных 
координатах</H3></CENTER>
<P>
<CENTER>
<H3><A name=tth_sEc0.7>0.7</A>&nbsp;&nbsp;ОТСЕЧЕНИЕ МНОГОУГОЛЬНИКА</H3></CENTER>
<P>Многоугольники особенно важны в растровой графике как средство задания 
поверхностей. 
<P>Будем называть многоугольник, используемый в качестве окна отсечения, 
отсекателем, а многоугольник, который отсекается, - отсекаемым. 
<P>Алгоритм отсечения многоугольника должен в результате отсечения давать один 
или несколько замкнутых многоугольников (рис.&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#r08_01">0.3.20</A>). При этом 
могут быть добавлены новые ребра, а имеющиеся или сохранены или разделены или 
даже отброшены. Существенно, чтобы границы окна, которые не ограничивают видимую 
часть отсекаемого многоугольника, не входили в состав результата отсечения. Если 
это не выполняется, то возможна излишняя закраска границ окна (см. рис.&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#r08_01">0.3.20</A>б). 
<P>
<P><A name=tth_fIg0.18></A>
<CENTER><BR><IMG alt="Рисунок 52" 
src="Учебное пособие Основные алгоритмы компьютерной графики_files/kg0252.gif">
<P></CENTER>
<CENTER>Рис. 0.3.18: Отсечение окном PQRS многоугольников ABCDEFGHIJ и 
KLMN</CENTER><A name=r08_01></A>
<P>
<P>В принципе эту задачу можно решить с использованием рассмотренных выше 
алгоритмов отсечения линий, если рассматривать многоугольник просто как набор 
векторов, а не как сплошные закрашиваемые области. При этом вектора, 
составляющие многоугольник, просто последовательно отсекаются сторонами окна 
(рис.&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#r08_02">0.3.21</A>). 
<P>
<P><A name=tth_fIg0.19></A>
<CENTER><BR><IMG alt="Рисунок 53" 
src="Учебное пособие Основные алгоритмы компьютерной графики_files/kg0253.gif">
<P></CENTER>
<CENTER>Рис. 0.3.19: Отсечение окном PQRS многоугольника ABCD, рассматриваемого 
как набор векторов. Генерируется вывод из двух векторов BsCs и DsAs.</CENTER><A 
name=r08_02></A>
<P>
<P>Если же в результате отсечения должен быть получен замкнутый многоугольник, 
то формируется вектор, соединяющий последнюю видимую точку с точкой пересечения 
с окном (рис.&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#r08_03">0.3.22</A>а). Проблема 
возникает при окружении отсекаемым многоугольником угла окна (см. рис.&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#r08_03">0.3.22</A>б). 
<P>
<P><A name=tth_fIg0.20></A>
<CENTER><BR><IMG alt="Рисунок 54" 
src="Учебное пособие Основные алгоритмы компьютерной графики_files/kg0254.gif">
<P></CENTER>
<CENTER>Рис. 0.3.20: Отсечение сплошного многоугольника окном.</CENTER><A 
name=r08_03></A>
<P>
<P>Здесь мы рассмотрим три алгоритма корректно решающие задачу отсечения 
сплошного многоугольника. Первые два алгоритма быстро работают, но генерируют 
лишние ребра, как это продемонстрировано на рис.&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#r08_01">0.3.20</A>б. Последний 
алгоритм свободен от указанного недостатка. 
<P>В общем, при отсечении многоугольников возникают два типа задач - отображение 
части изображения попавшей в окно и наоборот, отображение изображения, 
находящегося вне окна. Все здесь рассматриваемые алгоритмы могут использоваться 
в обоих случаях. 
<P>
<CENTER>
<H3><A name=tth_sEc0.7.1>0.7.1</A>&nbsp;&nbsp;Алгоритм 
Сазерленда-Ходгмана</H3></CENTER>
<P>Простой метод решения проблемы охвата отсекаемым многоугольником вершины окна 
предлагается в алгоритме Сазерленда-Хогдмана [<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#mbib40" name=CITEmbib40>40</A>], 
когда весь многоугольник последовательно отсекается каждой границей окна, как 
это показано на рис.&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#r08_04">0.3.23</A>. 
<P>
<P><A name=tth_fIg0.21></A><A name=r08_04>
<CENTER><BR><IMG alt="Рисунок 55" 
src="Учебное пособие Основные алгоритмы компьютерной графики_files/kg0255.gif">
<P></CENTER>
<CENTER>Рис. 0.3.21: Последовательное отсечение многоугольника сторонами 
окна.</CENTER></A>
<P>
<P>При отсечении ребра, соединяющего очередную пару вершин K и L, возможны 4 
случая взаимного расположения (рис.&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#r08_05">0.3.24</A>): 
<P>а) ребро на внутренней стороне границы, 
<P>б) ребро выходит из окна наружу, 
<P>в) ребро на внешней стороне границы, 
<P>г) ребро входит снаружи в окно. 
<P>
<P><A name=tth_fIg0.22></A><A name=r08_05>
<CENTER><BR><IMG alt="Рисунок 56" 
src="Учебное пособие Основные алгоритмы компьютерной графики_files/kg0256.gif">
<P></CENTER>
<CENTER>Рис. 0.3.22: Относительные расположения ребра и границы 
окна.</CENTER></A>
<P>
<P>В случае а) в результат добавляется вершина L. В случае б) в результат 
заносится S - точка пересечения ребра с границей. В случае в) нет вывода. В 
случае г) выдаются точка пересечения S и конечная точка ребра L. 
<P>Для определения взаимного расположения и направленности используется 
векторное произведение вектора <B>P</B><SUB>1</SUB><B>P</B><SUB>2</SUB>, 
проведенного из начальной в конечную точку текущего ребра окна, на вектор 
<B>P</B><SUB>1</SUB><B>S</B> из начальной точки текущего ребра окна в очередную 
вершину S многоугольника (рис.&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#r08_06">0.3.25</A>). 
<P>
<P><A name=tth_fIg0.23></A><A name=r08_06>
<CENTER><BR><IMG alt="Рисунок 57" 
src="Учебное пособие Основные алгоритмы компьютерной графики_files/kg0257.gif">
<P></CENTER>Если <B>P</B><SUB>1</SUB><B>P</B><SUB>2</SUB> 
&times;<B>P</B><SUB>1</SUB><B>S</B> &lt; 0, то поворот от 
<B>P</B><SUB>1</SUB><B>P</B><SUB>2</SUB> 
&nbsp;&nbsp;&nbsp;&nbsp;к&nbsp;&nbsp;&nbsp;&nbsp;<B>P</B><SUB>1</SUB><B>S</B> по 
часовой стрелке, т.е. точка S внутри окна.<BR>Если 
<B>P</B><SUB>1</SUB><B>P</B><SUB>2</SUB> &times;<B>P</B><SUB>1</SUB><B>S</B> &gt; 0, 
то поворот от <B>P</B><SUB>1</SUB><B>P</B><SUB>2</SUB> 
&nbsp;&nbsp;&nbsp;&nbsp;к&nbsp;&nbsp;&nbsp;&nbsp;<B>P</B><SUB>1</SUB><B>S</B> 
против часовой стрелки, т.е. точка S вне окна. 
<P>
<CENTER>Рис. 0.3.23: Определение взаимного расположения окна и 
вершины</CENTER></A>
<P>
<P>Предложена аппаратная реализация этого алгоритма, состоящая из четырех 
идентичных ступеней отсечения без промежуточной памяти [<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#mbib28" name=CITEmbib28>28</A>]. 
<P>В алгоритме Сазерленда-Ходгмана в результат могут заноситься границы окна, 
даже если они и не ограничивают видимую часть отсеченного многоугольника. Это 
можно устранить дополнительным анализом, либо используя более сложный алгоритм 
отсечения. 
<P>
<CENTER>
<H3><A name=tth_sEc0.7.2>0.7.2</A>&nbsp;&nbsp;Простой алгоритм отсечения 
многоугольника</H3></CENTER>
<P>В данном разделе рассматривается простой алгоритм отсечения, который подобно 
алгоритму Сазерленда-Ходгмана может генерировать лишние стороны для отсеченного 
многоугольника, проходящие вдоль ребра окна отсечения. Но этот алгоритм 
несколько более быстрый и использует те же подпрограммы обработки многоугольного 
окна отсечения, что и алгоритм Кируса-Бека. 
<P>Многоугольник отсекается одним ребром выпуклого окна отсечения. В результате 
такого отсечения формируется новый многоугольник, который затем отсекается 
следующим ребром и т.д., пока не будет выполнено отсечение последним ребром 
окна. 
<P>Основная здесь процедура - процедура отсечения отдельным ребром, определяющая 
взаимное расположение очередной стороны многоугольника и ребра отсекателя и 
генерирующая соответствующие выходные данные. 
<P>Возможны 9 различных случаев расположения ребра окна и отсекаемой стороны, 
показанных на рис.&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#r08_07">0.3.26</A>-<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#r08_09">0.3.28</A>. 
<P>
<P><A name=tth_fIg0.24></A><A name=r08_07>
<CENTER><BR><IMG alt="Рисунок 58" 
src="Учебное пособие Основные алгоритмы компьютерной графики_files/kg0258.gif">
<P></CENTER>
<CENTER>Рис. 0.3.24: Начальная точка вне ребра окна отсечения.</CENTER></A>
<P>
<P>На них V<SUB>0</SUB> и V<SUB>1</SUB> - начальная и конечная точки отсекаемой 
стороны многоугольника, соответственно; <B>N</B>r - нормаль к ребру окна 
отсечения, направленная внутрь окна. 
<P>
<P><A name=tth_fIg0.25></A><A name=r08_08>
<CENTER><BR><IMG alt="Рисунок 59" 
src="Учебное пособие Основные алгоритмы компьютерной графики_files/kg0259.gif">
<P></CENTER>
<CENTER>Рис. 0.3.25: Начальная точка на ребре окна отсечения.</CENTER></A>
<P>
<P>Из этих рисунков очевидны правила генерации выходных данных, зависящие от 
варианта взаимного расположения: 
<P>1) Нет выходных данных. 
<P>2) В выходные данные заносится конечная точка. 
<P>3) Рассчитывается пересечение и в выходные данные заносятся точка пересечения 
и конечная точка. 
<P>4) Нет выходных данных. 
<P>5) В выходные данные заносится конечная точка. 
<P>6) В выходные данные заносится конечная точка. 
<P>7) Рассчитывается пересечение и в выходные данные заносится только точка 
пересечения. 
<P>8) В выходные данные заносится конечная точка. 
<P>9) В выходные данные заносится конечная точка. 
<P>
<P><A name=tth_fIg0.26></A><A name=r08_09>
<CENTER><BR><IMG alt="Рисунок 60" 
src="Учебное пособие Основные алгоритмы компьютерной графики_files/kg0260.gif">
<P></CENTER>
<CENTER>Рис. 0.3.26: Начальная точка внутри окна отсечения.</CENTER></A>
<P>
<P>Для определения взаимного расположения, подобно алгоритму отсечения 
Кируса-Бека, используется скалярное произведение Q вектора нормали на вектор, 
проведенный из начала ребра в анализируемую точку. Пояснение см. на 
рис.&nbsp;8.10. 
<P><A name=r08_10>
<CENTER><BR><IMG alt="Рисунок 61" 
src="Учебное пособие Основные алгоритмы компьютерной графики_files/kg0261.gif">
<P></CENTER>Рис.&nbsp;8.10.&nbsp;Анализ расположения точки относительно ребра 
окна отсечения. </A>
<P>Таким образом, для определения взаимного расположения начальной 
<B>V</B><SUB>0</SUB> и конечной <B>V</B><SUB>1</SUB> точек отсекаемой стороны и 
ребра отсечения с вектором его начала <B>R</B>, надо вычислить: 
<P>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>Qn &nbsp;&nbsp; = 
            &nbsp;&nbsp;(&nbsp;&nbsp;<B>V</B><SUB>0</SUB> 
            &nbsp;&nbsp;-&nbsp;&nbsp;<B>R</B>&nbsp;&nbsp;)&nbsp;&nbsp;·&nbsp;&nbsp;<B>N</B>r 
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;и</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>Qk &nbsp;&nbsp; = 
            &nbsp;&nbsp;(&nbsp;&nbsp;<B>V</B><SUB>1</SUB> 
            &nbsp;&nbsp;-&nbsp;&nbsp;<B>R</B>&nbsp;&nbsp;)&nbsp;&nbsp;·&nbsp;&nbsp;<B>N</B>r.</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>
<P>Расчет пересечения, если он требуется, производится аналогично алгоритму 
Кируса-Бека с использованием параметрического представления линии: 
<P>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap><B>V</B>(t) &nbsp;&nbsp; = 
            &nbsp;&nbsp;<B>V</B><SUB>0</SUB> 
            &nbsp;&nbsp;+&nbsp;&nbsp;(&nbsp;&nbsp;<B>V</B><SUB>1</SUB> 
            &nbsp;&nbsp;-&nbsp;&nbsp;<B>V</B><SUB>0</SUB>&nbsp;&nbsp;)&nbsp;&nbsp;·&nbsp;&nbsp;t.</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>
<P>Вначале находится значение параметра t для точки пересечения по формуле (см. 
описание алгоритма Кируса-Бека): 
<P>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>t &nbsp;&nbsp; = 
            &nbsp;&nbsp;-Qn&nbsp;&nbsp;/&nbsp;&nbsp;Pn,</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>
<P>где Qn - скалярное произведение вектора нормали к ребру окна на вектор из 
начала ребра в начальную точку стороны, уже вычисленное при определении 
расположения начальной точки, а Pn &nbsp;&nbsp; = 
&nbsp;&nbsp;(<B>V</B><SUB>1</SUB> - <B>V</B><SUB>0</SUB>)·&nbsp;&nbsp;<B>N</B>r 
- скалярное произведение вектора нормали к ребру окна на вектор из начальной в 
конечную точки отсекаемой стороны. 
<P>Легко выразить это произведение через уже вычисленные величины Qn и Qk: 
<P>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap></TD>
          <TD noWrap>
            <TABLE align=left border=0>
              <TBODY>
              <TR>
                <TD align=right noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=left noWrap>Pn</TD></TR></TBODY></TABLE></TD>
                <TD align=left noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=left noWrap>= </TD></TR></TBODY></TABLE></TD>
                <TD align=left noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=left noWrap>(<B>V</B><SUB>1</SUB> - 
                        <B>V</B><SUB>0</SUB>)·&nbsp;&nbsp;<B>N</B>r</TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=right colSpan=0 noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=left noWrap></TD></TR></TBODY></TABLE></TD>
                <TD align=left noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=left noWrap>= </TD></TR></TBODY></TABLE></TD>
                <TD align=left noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=left noWrap>(<B>V</B><SUB>1</SUB> - 
                        <B>V</B><SUB>0</SUB> - <B>R</B> + 
                        <B>R</B>)·&nbsp;&nbsp;<B>N</B>r</TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=right colSpan=0 noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=left noWrap></TD></TR></TBODY></TABLE></TD>
                <TD align=left noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=left noWrap>= </TD></TR></TBODY></TABLE></TD>
                <TD align=left noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=left noWrap>(<B>V</B><SUB>1</SUB> - 
                        <B>R</B>)·&nbsp;&nbsp;<B>N</B>r 
                        &nbsp;&nbsp;-&nbsp;&nbsp;(<B>V</B><SUB>0</SUB> - 
                        <B>R</B>)·&nbsp;&nbsp;<B>N</B>r</TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=right colSpan=0 noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=left noWrap></TD></TR></TBODY></TABLE></TD>
                <TD align=left noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=left noWrap>= </TD></TR></TBODY></TABLE></TD>
                <TD align=left noWrap>
                  <TABLE>
                    <TBODY>
                    <TR>
                      <TD align=right colSpan=0 noWrap>Qk - 
                  Qn.</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></TD>
          <TD noWrap></TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>
<P>Таким образом, точке пересечения соответствует значение параметра t, равное: 
<P>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>t &nbsp;&nbsp; = 
            &nbsp;&nbsp;Qn&nbsp;&nbsp;/&nbsp;&nbsp;(&nbsp;&nbsp;Qn 
            &nbsp;&nbsp;-&nbsp;&nbsp;Qk&nbsp;&nbsp;).</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>
<P>Значения координат пересечения находятся из: 
<P>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>Xp &nbsp;&nbsp; = &nbsp;&nbsp;X<SUB>0</SUB> 
            &nbsp;&nbsp;+&nbsp;&nbsp;(X<SUB>1</SUB>&nbsp;&nbsp;-&nbsp;&nbsp;X<SUB>0</SUB>)·&nbsp;&nbsp;t;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yp 
            &nbsp;&nbsp; = &nbsp;&nbsp;Y<SUB>0</SUB> 
            &nbsp;&nbsp;+&nbsp;&nbsp;(Y<SUB>1</SUB>&nbsp;&nbsp;-&nbsp;&nbsp;Y<SUB>0</SUB>)·&nbsp;&nbsp;t.</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>
<P>Описанный алгоритм реализован в процедуре V_Plclip, приведенной в Приложении 
8. 
<P>
<CENTER>
<H3><A name=tth_sEc0.7.3>0.7.3</A>&nbsp;&nbsp;Алгоритм отсечения многоугольника 
Вейлера-Азертона</H3></CENTER>
<P>В предыдущих разделах были рассмотрены два алгоритма отсечения 
многоугольника, последовательно отсекающие произвольный (как выпуклый, так и 
невыпуклый) многоугольник каждой из сторон выпуклого окна. Зачастую же требуется 
отсечение по невыпуклому окну. Кроме того оба рассмотренных алгоритма могут 
генерировать лишние стороны для отсеченного многоугольника, проходящие вдоль 
ребра окна отсечения. Далее рассматриваемый алгоритм Вейлера-Азертона [<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#mbib41" name=CITEmbib41>41</A>,,] 
свободен от указанных недостатков ценой заметно большей сложности и меньшей 
скорости работы. 
<P>Предполагается, что каждый из многоугольников задан списком вершин, причем 
таким образом, что при движении по списку вершин в порядке их задания внутренняя 
область многоугольника находится справа от границы. 
<P>В случае пересечения границ и отсекаемого многоугольника и окна возникают 
точки двух типов: 
<P><FONT face=symbol>·</FONT> входные точки, когда ориентированное ребро 
отсекаемого многоугольника входит в окно,<BR>
<P><FONT face=symbol>·</FONT> выходные точки, когда ребро отсекаемого 
многоугольника идет с внутренней на внешнюю стороны окна.<BR>
<P>Общая схема алгоритма Вейлера-Азертона для определения части отсекаемого 
многоугольника, попавшей в окно, следующая: 
<P>
<OL type=1>
  <LI>Строятся списки вершин отсекаемого многоугольника и окна. 
  <P></P>
  <LI>Отыскиваются все точки пересечения. При этом расчете касания не считаются 
  пересечением, т.е. когда вершина или ребро отсекаемого многоугольника 
  инцидентна или совпадает со стороной окна (рис.&nbsp;<A 
  href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#r08_11">0.3.29</A> и <A 
  href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#r08_12">0.3.30</A>). 
  <P></P>
  <LI>Списки координат вершин отсекаемого многоугольника и окна дополняются 
  новыми вершинами - координатами точек пересечения. Причем если точка 
  пересечения Pk находится на ребре, соединяющем вершины Vi, Vj, то 
  последовательность точек Vi, Vj превращается в последовательность Vi, Pk, Vj. 
  При этом устанавливаются двухсторонние связи между одноименными точками 
  пересечения в списках вершин отсекаемого многоугольника и окна.<BR>Входные и 
  выходные точки пересечения образуют отдельные подсписки входных и выходных 
  точек в списках вершин. 
  <P></P>
  <LI>Определение части обрабатываемого многоугольника, попавшей в окно 
  выполняется следующим образом:<BR>Если не исчерпан список входных точек 
  пересечения, то выбираем очередную входную точку.<BR>Двигаемся по вершинам 
  отсекаемого многоугольника пока не обнаружится следующая точка пересечения; 
  все пройденные точки, не включая прервавшую просмотр, заносим в результат; 
  используя двухстороннюю связь точек пересечения, переключаемся на просмотр 
  списка вершин окна.<BR>Двигаемся по вершинам окна до обнаружения следующей 
  точки пересечения; все пройденные точки, не включая последнюю, прервавшую 
  просмотр, заносим в результат.<BR>Используя двухстороннюю связь точек 
  пересечения, переключаемся на список вершин обрабатываемого 
  многоугольника.<BR>Эти действия повторяем пока не будет достигнута исходная 
  вершина - очередная часть отсекаемого многоугольника, попавшая в окно, 
  замкнулась. Переходим на выбор следующей входной точки в списке отсекаемого 
  многоугольника. </LI></OL>
<P>
<P><A name=tth_fIg0.27></A><A name=r08_11>
<CENTER><BR><IMG alt="Рисунок 62" 
src="Учебное пособие Основные алгоритмы компьютерной графики_files/kg0262.gif">
<P></CENTER>
<CENTER>Рис. 0.3.27: Случаи не считающиеся пересечением.</CENTER></A>
<P>
<P>
<P><A name=tth_fIg0.28></A><A name=r08_12>
<CENTER><BR><IMG alt="Рисунок 63" 
src="Учебное пособие Основные алгоритмы компьютерной графики_files/kg0263.gif">
<P></CENTER>
<CENTER>Рис. 0.3.28: Частные случаи пересечения.</CENTER></A>
<P>
<P>Модификация этого алгоритма для определения части отсекаемого многоугольника, 
находящейся вне окна, заключается в следующем: 
<P><FONT face=symbol>·</FONT> исходная точка пересечения пересечения берется из 
списка выходных точек,<BR>
<P><FONT face=symbol>·</FONT> движение по списку вершин окна выполняется в 
обратном порядке, т.е. так чтобы внутренняя часть отсекателя была слева.<BR>
<P>На рис.&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#r08_13">0.3.31</A> иллюстрируется 
отсечение многоугольника ABCDEFGHI окном PQRS по алгоритму Вейлера-Азертона. 
<P>
<P><A name=tth_fIg0.29></A><A name=r08_13>
<CENTER><BR><IMG alt="Рисунок 64" 
src="Учебное пособие Основные алгоритмы компьютерной графики_files/kg0264.gif">
<P></CENTER>
<CENTER>Рис. 0.3.29: Отсечение по алгоритму Вейлера-Азертона.</CENTER></A>
<P>
<P>Начиная с этого алгоритма, при рассмотрении многих дальнейших требуется 
представления о различных структурах данных и работе с ними. Следующий раздел и 
посвящен беглому рассмотрению некоторых наиболее важных структур данных. 
<P>
<CENTER>
<H3><A name=tth_sEc0.8>0.8</A>&nbsp;&nbsp;СТРУКТУРЫ ДАННЫХ</H3></CENTER>
<P>В данном разделе рассмотрены три основных способа работы с данными: 
<I>последовательный доступ, непосредственный доступ</I>, и <I>списки</I>. Данные 
могут быть организованы в виде: 
<P><FONT face=symbol>·</FONT> элементов данных (data item) - единичная 
информация, перерабатываемая системой, 
<P><FONT face=symbol>·</FONT> запись (record) - совокупность некоторого числа 
элементов данных, 
<P><FONT face=symbol>·</FONT> файл (file) - совокупность некоторого числа 
записей. 
<P>В общем случае структура данных образуется посредством упорядочивания записей 
и связей между ними в файл. В зависимости от требуемых операций данные в файле 
организуются различным образом. 
<P>
<CENTER>
<H3><A name=tth_sEc0.8.1>0.8.1</A>&nbsp;&nbsp;Последовательный 
доступ</H3></CENTER>
<P>Зачастую требуется простейшая последовательная обработка записей. Для этого 
достаточна последовательная организация данных, когда записи запоминаются в 
файле в последовательности поступления. 
<P>Выбор требуемой записи в файле с последовательной организацией возможен 
только путем его сканирования от начала до требуемой записи. 
<P>Удаление и/или вставка не последней записи приводят к большим перемещениям 
данных (рис.&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#r09_01">0.4.32</A>, <A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#r09_02">0.4.33</A>). 
<P>
<P><A name=tth_fIg0.1></A><A name=r09_01>
<CENTER><BR><IMG alt="Рисунок 65" 
src="Учебное пособие Основные алгоритмы компьютерной графики_files/kg0265.gif">
<P>
<P></CENTER>
<CENTER>Рис. 0.1.1: Удаление записи из файла с последовательным 
доступом</CENTER></A>
<P>
<P>
<P><A name=tth_fIg0.2></A><A name=r09_02>
<CENTER><BR><IMG alt="Рисунок 66" 
src="Учебное пособие Основные алгоритмы компьютерной графики_files/kg0266.gif">
<P>
<P></CENTER>
<CENTER>Рис. 0.1.2: Вставка записи в файл с последовательным 
доступом</CENTER></A>
<P>
<P>
<CENTER>
<H4>Очереди и стеки</H4></CENTER>
<P>Частными, широко используемыми случаями последовательного доступа, являются 
очереди и стеки. Наиболее широко используются стеки. 
<P>Очередь - файл данных с дисциплиной обслуживания первым пришел - первым 
обслужен (FIFO - First Input First Output) (рис&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#r09_03">0.4.34</A>). 
<P>
<P><A name=tth_fIg0.3></A><A name=r09_03>
<CENTER><BR><IMG alt="Рисунок 67" 
src="Учебное пособие Основные алгоритмы компьютерной графики_files/kg0267.gif">
<P>
<P></CENTER>
<CENTER>Рис. 0.1.3: Работа с очередью</CENTER></A>
<P>
<P>Стек (магазин, гнездовая память, память LIFO) - файл данных с дисциплиной 
обслуживания первым пришел - последним обслужен (LIFO - Last Input First 
Output). 
<P>Состояние стека определяется значением указателя стека, инициируемом при его 
создании. Для работы с созданным стеком достаточны две операции: 
<P><FONT face=symbol>·</FONT> PUSH - помещение записи в стек, 
<P><FONT face=symbol>·</FONT> POP - получение записи из стека. 
<P>Эти операции заносят/читают данные и модифицируют значение указателя стека. 
Стек может быть организован двумя способами, отличающимися правилами продвижения 
указателя стека: 
<P>
<OL type=1>
  <LI>Указатель стека указывает на последнюю занесенную запись.<BR>До занесения 
  указатель стека уменьшается на длину записи (рис.&nbsp;<A 
  href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#r09_04">0.4.35</A>).<BR>После 
  чтения указатель стека увеличивается на длину записи (рис.&nbsp;<A 
  href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#r09_05">0.4.36</A>). </LI></OL>
<P>
<P><A name=tth_fIg0.4></A><A name=r09_04>
<CENTER><BR><IMG alt="Рисунок 68" 
src="Учебное пособие Основные алгоритмы компьютерной графики_files/kg0268.gif">
<P>
<P></CENTER>
<CENTER>Рис. 0.1.4: Запись данных в стек типа 1</CENTER></A>
<P>
<P>
<P><A name=tth_fIg0.5></A><A name=r09_05>
<CENTER><BR><IMG alt="Рисунок 69" 
src="Учебное пособие Основные алгоритмы компьютерной графики_files/kg0269.gif">
<P>
<P></CENTER>
<CENTER>Рис. 0.1.5: Чтение данных из стека типа 1</CENTER></A>
<P>
<P>
<OL type=1>
  <LI>Указатель стека указывает на свободное место в стеке.<BR>После занесения 
  указатель стека увеличивается на длину записи (рис.&nbsp;<A 
  href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#r09_06">0.4.37</A>).<BR>Перед 
  чтением указатель стека уменьшается на длину записи. (рис.&nbsp;<A 
  href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#r09_07">0.4.38</A>). </LI></OL>
<P>
<P><A name=tth_fIg0.6></A><A name=r09_06>
<CENTER><BR><IMG alt="Рисунок 70" 
src="Учебное пособие Основные алгоритмы компьютерной графики_files/kg0270.gif">
<P>
<P></CENTER>
<CENTER>Рис. 0.1.6: Запись данных в стек типа 2</CENTER></A>
<P>
<P>
<P><A name=tth_fIg0.7></A><A name=r09_07>
<CENTER><BR><IMG alt="Рисунок 71" 
src="Учебное пособие Основные алгоритмы компьютерной графики_files/kg0271.gif">
<P>
<P></CENTER>
<CENTER>Рис. 0.1.7: Чтение данных из стека типа 2</CENTER></A>
<P>
<P>Наиболее часто используется первый способ организации стека. 
<P>
<CENTER>
<H3><A name=tth_sEc0.8.2>0.8.2</A>&nbsp;&nbsp;Непосредственный 
доступ</H3></CENTER>
<P>При необходимости непосредственного доступа (random access) устанавливается 
связь между адресом запоминания и ключом, по которому ищется запись. 
<P>
<CENTER>
<H4>Простой непосредственный доступ</H4></CENTER>
<P>В простейшем случае ключ поиска - просто номер записи. Чаще ключ - некоторая 
совокупность данных из записи. По значению ключа либо непосредственно 
вычисляется адрес записи (например, адрес расположения физического блока 
фиксированной длины на диске вычисляется по его номеру), либо ключ используется 
для доступа к справочнику, в котором отыскивается адрес (например, адрес начала 
расположения i-го файла задается i-й записью в директории). Метод очень быстрый 
- мы немедленно получаем доступ к записи. Но он может быть очень расточительным 
по использованию памяти, когда из полного возможного набора в N ключей, по 
которым вырабатываются адреса в диапазоне от 0 до N-1, фактически будет иметься 
только K &lt;&lt; N ключей, т.е. из всего диапазона адресов 0-(N-1) будет 
использоваться только K адресов, раскиданных по всему объему от 0 до N-1. 
<P>
<CENTER>
<H4>Непосредственный доступ с использованием хеш-адресации</H4></CENTER>
<P>В таких случаях значение ключа используется для вычисления функции 
расстановки (hash code), определяющей адрес расположения данных. Причем функция 
расстановки подбирается такой, чтобы для K ключей из полного допустимого набора 
в N ключей, генерируемое количество адресов L было возможно более близко к K. 
Этот подход обычно используется при поиске информации об объекте по его имени, 
например, для поиска информации об объекте по его наименованию, для поиска 
информации в базе данных о сотруднике по его фамилии, для работы с таблицей 
идентификаторов в трансляторах и т.д. В этом случае функция расстановки 
вычисляется из символов ключа. Идеальная функция расстановки должна вычислять 
уникальный адрес для каждого из фактических ключей. Реальные же функции 
расстановки могут для разных ключей давать один и тот же адрес. Рассмотрим 
частный пример (табл.&nbsp;9.1) занесения информации в таблицу из 10 элементов 
(L равно 10). В качестве ключа используем наименование объекта. Для вычисления 
хеш-адреса Hn в диапазоне 0-9 суммируем коды символов ключа, из которых 
предварительно вычитаем 65. В качестве хеш-адреса берем остаток от деления 
полученной суммы на 10. (На самом деле число 10 не годится, а выбрано для 
наглядности). 
<P>
<CENTER>
<TABLE border=1>
  <TBODY>
  <TR>
    <TD colSpan=6>Пример вычисления хеш-адреса. </TD>
    <TD align=right colSpan=3>Таблица 9.1 </TD>
  <TR>
    <TD>Ключ </TD>
    <TD align=middle colSpan=7>Коды символов ключа</TD>
    <TD align=middle>Хеш-адрес</TD>
  <TR>
    <TD>GALLERY</TD>
    <TD align=middle>71</TD>
    <TD align=middle>65</TD>
    <TD align=middle>76</TD>
    <TD align=middle>76</TD>
    <TD align=middle>69</TD>
    <TD align=middle>82</TD>
    <TD align=middle>89</TD>
    <TD align=middle>3</TD>
  <TR>
    <TD>HOUSE </TD>
    <TD align=middle>72</TD>
    <TD align=middle>79</TD>
    <TD align=middle>85</TD>
    <TD align=middle>83</TD>
    <TD align=middle>69</TD>
    <TD align=middle></TD>
    <TD align=middle></TD>
    <TD align=middle>3</TD>
  <TR>
    <TD>MIRROR </TD>
    <TD align=middle>77</TD>
    <TD align=middle>73</TD>
    <TD align=middle>82</TD>
    <TD align=middle>82</TD>
    <TD align=middle>79</TD>
    <TD align=middle>82</TD>
    <TD align=middle></TD>
    <TD align=middle>5</TD>
  <TR>
    <TD>RING </TD>
    <TD align=middle>82</TD>
    <TD align=middle>73</TD>
    <TD align=middle>78</TD>
    <TD align=middle>71</TD>
    <TD align=middle></TD>
    <TD align=middle></TD>
    <TD align=middle></TD>
    <TD align=middle>4</TD>
  <TR>
    <TD>SCENE </TD>
    <TD align=middle>83</TD>
    <TD align=middle>67</TD>
    <TD align=middle>69</TD>
    <TD align=middle>78</TD>
    <TD align=middle>69</TD>
    <TD align=middle></TD>
    <TD align=middle></TD>
    <TD align=middle>1</TD></TD></TR></TBODY></TABLE></CENTER>
<P>Из табл.&nbsp;9.1. видно, что для двух разных ключей GALLERY и HOUSE вычислен 
одинаковый хеш-адрес, равный 3. Предложен ряд способов разрешения таких 
коллизий. Рассмотрим один из них, называемый рехешированием. 
<P>Перед занесением очередной строки в таблицу проверяем занят ли элемент. Если 
элемент таблицы свободен, то выполняем занесение. Если же элемент таблицы уже 
занят, то сравниваем ключи So уже занесенного и Sn заносимого элементов. Если 
они совпали, то выполняем какую-либо процедуру реагирования на одинаковые ключи 
и завершаем занесение. Например, для базы данных по кадрам выдаем диагностику о 
том что информация о данном сотруднике уже есть, для таблицы идентификаторов 
формируем сообщение о повторном описании и т.п. Если же ключи So и Sn не 
совпали, то вычисляется новый адрес в таблице по формуле: 
<P><A name=f9_1></A>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>H<SUB>i</SUB> = H<SUB>n</SUB> 
            &nbsp;&nbsp;&nbsp;&nbsp;+ &nbsp;&nbsp;&nbsp;&nbsp;P<SUB>i</SUB> 
            &nbsp;&nbsp;&nbsp;&nbsp;по &nbsp;&nbsp;&nbsp;&nbsp;модулю 
            &nbsp;&nbsp;&nbsp;&nbsp;L,</TD></TR></TBODY></TABLE></TD>
    <TD align=right width=100>(0.1.1)</TD></TR></TBODY></TABLE></CENTER>
<P>где H<SUB>n</SUB> - исходный хеш-адрес, P<SUB>i</SUB> - некоторое число, L - 
длина таблицы. 
<P>Если этот элемент также оказался занятым, то задается новое значение 
P<SUB>i</SUB> и по формуле (<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#f9_1">0.4.26</A>) вычисляется 
следующий адрес т.д., пока не будет найден некоторый элемент, который либо пуст, 
либо содержит ключ Sn, либо не будет получен исходный хеш-адрес. В последнем 
случае работа прекращается из-за переполнения таблицы. Используются несколько 
основных способов рехеширования [<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#mbib12" name=CITEmbib12>12</A>,]: 

<P><B>Линейное рехеширование.</B> В этом, наиболее распространенном и простом 
случае P<SUB>1</SUB> равно 1, P<SUB>2</SUB> равно 2 и т.д.<BR>Число сравнений E 
<FONT face=symbol>»</FONT> (1 - V/2)(1-V), где V - коэффициент заполненности 
таблицы.<BR>10% - E = 1.06 сравнений,<BR>50% - E = 1.50 сравнений,<BR>90% - E = 
5.50 сравнений. 
<P><B>Случайное рехеширование.</B> При этом способе P<SUB>j</SUB> - 
псевдослучайное число.<BR>Способ хорош при L = 2<SUP>m</SUP> где m - 
целое.<BR>Число сравнений E <FONT face=symbol>»</FONT> - (1/V)log(1-V).<BR>10% - 
E = 1.05 сравнений,<BR>50% - E = 1.39 сравнений,<BR>90% - E = 2.56 сравнений. 
<P><B>Рехеширование сложением с выбором.</B> При этом способе P<SUB>i</SUB> = i 
&times;H<SUB>n</SUB> (i = 1<FONT face=symbol>ј</FONT>L-1),.<BR>Способ хорош когда L - 
простое число. 
<P><B>Квадратичное рехеширование.</B> При этом способе P<SUB>i</SUB> = 
A&times;(i<SUP>2</SUP>) + B&times;i + C.<BR>Здесь A, B, C - произвольные числа, выбор 
которых определяется эффективностью вычисления формулы на конкретной 
машине.<BR>Время вычислений хеш-адреса меньше чем при случайном 
рехешировании.<BR>Если L - простое число, то E <FONT face=symbol>Ј</FONT> 
L/2.<BR>
<P>Третья форма организации данных - списки, когда логическая и физическая 
организация данных разделены и для доступа к данным используются указатели на 
данные. 
<P>Далее будем рассматривать структуры данных с использованием списков 
указателей. 
<P>
<CENTER>
<H3><A name=tth_sEc0.8.3>0.8.3</A>&nbsp;&nbsp;Линейные списки</H3></CENTER>
<P>Линейный список - множество элементов с помощью которых свойства структуры 
задаются посредством линейного (одномерного) относительного расположения 
элементов. При этом k-й указатель непосредственно находится после (k-1)-го. 
<P>С таким списком возможны следующие операции: 
<OL type=1>
  <P>
  <LI>Определение числа элементов в списке. 
  <LI>Доступ к k-му элементу для использования и/или изменения его содержимого. 
  <LI>Вставка нового элемента. 
  <LI>Удаление элемента. 
  <LI>Комбинация нескольких списков в один общий список. 
  <LI>Разделение списка на части. 
  <LI>Поиск. 
  <LI>Сортировка. </LI></OL>
<P>Пример линейного списка показан на рис.&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#r09_08">0.4.39</A>. 
<P>
<P><A name=tth_fIg0.8></A><A name=r09_08>
<CENTER><BR><IMG alt="Рисунок 72" 
src="Учебное пособие Основные алгоритмы компьютерной графики_files/kg0272.gif">
<P>
<P></CENTER>
<CENTER>Рис. 0.1.8: Линейный список</CENTER></A>
<P>
<P>
<CENTER>
<H3><A name=tth_sEc0.8.4>0.8.4</A>&nbsp;&nbsp;Комбинированные 
списки</H3></CENTER>
<P>Очевидно, что процесс удаления может приводить к большим перемещениям данных. 
Пусть, например, надо удалить запись номер 1 (см. рис.&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#r09_08">0.4.39</A>). Это 
потребует удаления указателя p<SUB>1</SUB> и переписи всех далее расположенных 
указателей на освобождаемое место списка. Аналогичные проблемы возникают и при 
вставке в требуемое место. 
<P>Поэтому естественным шагом является построение так называемых комбинированных 
списков, содержащих кроме указателей на записи данных также и дополнительные 
указатели, указывающие на на следующий элемент списка указателей (рис.&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#r09_09">0.4.40</A>). 
<P>
<P><A name=tth_fIg0.9></A><A name=r09_09>
<CENTER><BR><IMG alt="Рисунок 73" 
src="Учебное пособие Основные алгоритмы компьютерной графики_files/kg0273.gif">
<P></CENTER>
<CENTER>Рис. 0.1.9: Комбинированный список</CENTER></A>
<P>
<P>Достоинства таких списков: 
<P><FONT face=symbol>·</FONT> много проще вставка в требуемое место, например, 
вставка нового элемента между (n-1)-м и n-м сводится к перестройке двух 
указателей (рис.&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#r09_10">0.4.41</A>) 
<P>
<P><A name=tth_fIg0.10></A><A name=r09_10>
<CENTER><BR><IMG alt="Рисунок 74" 
src="Учебное пособие Основные алгоритмы компьютерной графики_files/kg0274.gif">
<P>
<P></CENTER>
<CENTER>Рис. 0.1.10: Вставка элемента p<SUB>i</SUB> в комбинированный 
список</CENTER></A>
<P>
<P><FONT face=symbol>·</FONT> много проще удаление (рис.&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#r09_11">0.4.42</A>), которое 
сводится к перестройке трех указателей - одного указателя для собственно 
удаления и перестройке двух указателей для включения удаляемого элемента в 
список свободной памяти.<BR>
<P>
<P><A name=tth_fIg0.11></A><A name=r09_11>
<CENTER><BR><IMG alt="Рисунок 75" 
src="Учебное пособие Основные алгоритмы компьютерной графики_files/kg0275.gif">
<P>
<P></CENTER>
<CENTER>Рис. 0.1.11: Удаление элемента p<SUB>3</SUB> из комбинированного 
списка</CENTER></A>
<P>
<P><FONT face=symbol>·</FONT> разделение и соединение списков упрощается, 
<P><FONT face=symbol>·</FONT> возможно формирование сложных структур данных, 
<P><FONT face=symbol>·</FONT> можно надстраивать переменное число списков 
различных длин, 
<P><FONT face=symbol>·</FONT> любой из элементов списка может быть заголовком 
некоторого другого списка, когда указатель на данные указывает на некоторый 
другой список,<BR>
<P><FONT face=symbol>·</FONT> за счет использования нескольких указателей 
возможно формирование подсписков. 
<P>Недостатки: 
<P><FONT face=symbol>·</FONT> увеличивается потребность в памяти из-за 
дополнительных указателей, 
<P><FONT face=symbol>·</FONT> обычно требуемая последовательная обработка 
замедляется, 
<P><FONT face=symbol>·</FONT> выбор нужного элемента списка требует 
последовательного прохода по всем предшествующим элементам списка, начиная с 
начального. 
<P>
<CENTER>
<H3><A name=tth_sEc0.8.5>0.8.5</A>&nbsp;&nbsp;Циклические списки</H3></CENTER>
<P>Последнего недостатка лишены списки с указателями не только вперед, на 
следующий элемент, но и назад, на предшествующий элемент. Эти списки чаще всего 
используются в виде циклических, когда первый элемент указывает на последний, 
как предшествующий ему. В свою очередь последний элемент списка как на 
последующий указывает на начальный элемент. Доступ к началу списка обеспечивает 
специальный элемент - заголовок списка, который может сопровождаться данными, 
характеризующими список в целом (рис.&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#r09_12">0.4.43</A>). Например, 
если список представляет собой описание какой-либо фигуры (тела), то 
дополнительными данными могут быть идентификатор и тип фигуры или иная 
семантическая информация. 
<P>
<P><A name=tth_fIg0.12></A><A name=r09_12>
<CENTER><BR><IMG alt="Рисунок 76" 
src="Учебное пособие Основные алгоритмы компьютерной графики_files/kg0276.gif">
<P>
<P></CENTER>
<CENTER>Рис. 0.1.12: Циклический список</CENTER></A>
<P>
<P>Ясно, что удаление или вставка элемента в таком списке также упрощаются. 
<P>
<CENTER>
<H3><A name=tth_sEc0.9>0.9</A>&nbsp;&nbsp;ГЕОМЕТРИЧЕСКОЕ 
МОДЕЛИРОВАНИЕ</H3></CENTER>
<P>Во многих приложениях машинной графики возникает потребность в представлении 
трехмерных тел (вычислительный эксперимент, автоматизация проектирования, 
роботизация, вычислительная томография, тренажеры, видеографика и т.д.). 
<P>Можно выделить две основные задачи, связанные с представлением трехмерных 
тел, - построение модели уже существующего объекта и синтез модели заранее не 
существовавшего объекта. 
<P>При решении первой задачи в общем случае может потребоваться задание 
бесконечного количества координат точек. Чаще же всего объект с той или иной 
точностью аппроксимируют некоторым конечным набором элементов, например, 
поверхностей, тел и т.п. 
<P>При решении второй задачи, выполняемой чаще всего в интерактивном режиме, 
основное требование к средствам формирования и представления модели - удобство 
манипулирования. 
<P>Используются три основных типа 3D моделей: 
<P><FONT face=symbol>·</FONT> каркасное представление, когда тело описывается 
набором ребер, 
<P><FONT face=symbol>·</FONT> поверхностное, когда тело описывается набором 
ограничивающих его поверхностей,<BR>
<P><FONT face=symbol>·</FONT> модель сплошных тел, когда тело формируется из 
отдельных базовых геометрических и, возможно, конструктивно - технологических 
объемных элементов с помощью операций объединения, пересечения, вычитания и 
преобразований.<BR>
<P>Важно отметить, что 3D системы существенно ориентируются на область 
приложений так как многие характерные для них задачи, выполняемые программным 
путем, стоят очень дорого и сильно зависят от выбора возможных моделей. 
Типичными такими задачами, в частности, являются получение сечений и удаление 
невидимых частей изображения. Обычно имеется много вариантов реализации 
различных моделей в б\'ольшей или меньшей степени эффективных в зависимости от 
различных областей приложений и решаемых задач. Поэтому в 3D системах стремятся 
использовать многообразие моделей и поддерживать средства перехода от одной 
модели к другой. 
<P>Другим важным обстоятельством является то, что для современных систем 
характерно стремление моделировать логику работы, принятую пользователем. Это 
требует наличия средств перехода от модели, удобной для пользователя, к модели 
удобной для визуализации (модели тел в виде граней). 
<P>
<CENTER>
<H3><A name=tth_sEc0.9.1>0.9.1</A>&nbsp;&nbsp;Элементы моделей</H3></CENTER>
<P>При формировании 3D модели используются: 
<P><FONT face=symbol>·</FONT> двумерные элементы (точки, прямые, отрезки прямых, 
окружности и их дуги, различные плоские кривые и контуры),<BR>
<P><FONT face=symbol>·</FONT> поверхности (плоскости, поверхности, 
представленные семейством образующих, поверхности вращения, криволинейные 
поверхности),<BR>
<P><FONT face=symbol>·</FONT> объемные элементы (параллелепипеды, призмы, 
пирамиды, конусы, произвольные многогранники и т.п.).<BR>
<P>Из этих элементов с помощью различных операций формируется внутреннее 
представление модели.<BR>
<P>
<CENTER>
<H3><A name=tth_sEc0.9.2>0.9.2</A>&nbsp;&nbsp;Методы построения 
моделей</H3></CENTER>
<P>Используются два основных способа формирования геометрических элементов 
моделей - это построение по заданным отношениям (ограничениям) и построение с 
использованием преобразований.<BR>
<P>
<CENTER>
<H4>Построение с использованием отношений</H4></CENTER>
<P>Построение с использованием отношений заключается в том, что задаются: 
<P><FONT face=symbol>·</FONT> элемент подлежащий построению, 
<P><FONT face=symbol>·</FONT> список отношений и элементы к которым относятся 
отношения. 
<P>Например, построение прямой, проходящей через точку пересечения двух других 
прямых и касательную к окружности. 
<P>Используется два способа реализации построения по отношениям - общий и 
частный. 
<P>При общем способе реализации построение по заданным отношениям можно 
представить в виде двухшаговой процедуры: 
<P><FONT face=symbol>·</FONT> на основе заданных типов отношений, элементов и 
параметров строится система алгебраических уравнений,<BR>
<P><FONT face=symbol>·</FONT> решается построенная система уравнений. 
<P>Очевидное достоинство такого способа - простота расширения системы - для 
введения нового отношения достаточно просто написать соответствующие уравнения. 
<P>Основные проблемы такого способа заключаются в следующем: 
<P><FONT face=symbol>·</FONT> построенная система уравнений может иметь 
несколько решений, поэтому требуется выбрать одно из них, например, в диалоговом 
режиме,<BR>
<P><FONT face=symbol>·</FONT> система уравнений может оказаться нелинейной, 
решаемой приближенными методами, что может потребовать диалога для выбора 
метода(ов) приближенного решения.<BR>
<P>В связи с отмеченными проблемами общий подход реализован только в наиболее 
современных системах и при достаточно высоком уровне разработчиков в области 
вычислительной математики [<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#mbib8" name=CITEmbib8>8</A>]. 
<P>Большинство же систем реализует частный подход, первым приходящий в голову и 
заключающийся в том, что для каждой триады, включающей строящийся элемент, тип 
отношения и иные элементы, затрагиваемые отношением, пишется отдельная 
подпрограмма (например построение прямой, касательной к окружности в заданной 
точке). Требуемое построение осуществляется выбором из меню и тем или иным 
вводом требуемых данных [<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#mbib6" name=CITEmbib6>6</A>,]. 
<P>Преимущества такого подхода ясны - проще писать систему. Не менее очевидны и 
недостатки, когда пользователю требуется использовать сильно разветвленные меню 
и/или запоминать мало вразумительные сокращения или пиктограммы, так как обычно 
число требуемых вариантов построения исчисляется сотнями. Расширение системы, 
реализуемое добавлением новой подпрограммы, требует ее перепроектирования, по 
крайней мере в части обеспечения доступа пользователя к новым возможностям. В 
некотором смысле предельный пример этого подхода - система AutoCAD фирмы 
Autodesk. Авторы даже гордятся сложностью системы: "AutoCAD предоставляет эту 
крайне сложную технологию" (Предисловие к Справочному руководству AutoCAD версии 
2.5). 
<P>Понятно, что перспективы за общим подходом с разумным использованием частных 
решений. Вместе с тем устаревшие системы типа AutoCad скорее всего также будут 
продолжать использоваться в силу распространенности, сложившегося круга 
обученных пользователей и т.п. 
<P>
<CENTER>
<H4>Построение с использованием преобразований</H4></CENTER>
<P>Построение нового объекта с использованием преобразований заключается в 
следующем: 
<P><FONT face=symbol>·</FONT> задается преобразуемый объект, 
<P><FONT face=symbol>·</FONT> задается преобразование (это может быть обычное 
аффинное преобразование, определяемое матрицей, или некоторое деформирующее 
преобразование, например, замена одного отрезка контура ломаной),<BR>
<P><FONT face=symbol>·</FONT> выполнение преобразования; в случае аффинного 
преобразования для векторов всех характерных точек преобразуемого объекта 
выполняется умножение на матрицу; для углов вначале переходят к точкам и затем 
выполняют преобразование.<BR>
<P>
<CENTER>
<H4>Построение кривых</H4></CENTER>
<P>Важное значение при формировании как 2D, так и 3D моделей имеет построение 
элементарных кривых. Кривые строятся, в основном, следующими способами: 
<P><FONT face=symbol>·</FONT> той или иной интерполяцией по точкам, 
<P><FONT face=symbol>·</FONT> вычислением конических сечений, 
<P><FONT face=symbol>·</FONT> расчетом пересечения поверхностей, 
<P><FONT face=symbol>·</FONT> выполнением преобразования некоторой кривой, 
<P><FONT face=symbol>·</FONT> формированием замкнутых или разомкнутых контуров 
из отдельных сегментов, например, отрезков прямых, дуг конических сечений или 
произвольных кривых.<BR>
<P>В качестве последних обычно используются параметрические кубические кривые, 
так как это наименьшая степень при которой обеспечиваются: 
<P><FONT face=symbol>·</FONT> непрерывность значения первой (второй) производной 
в точках сшивки сегментов кривых,<BR>
<P><FONT face=symbol>·</FONT> возможность задания неплоских кривых. 
<P>Параметрическое представление кривых выбирается по целому ряду причин, в том 
числе потому, что зачастую объекты могут иметь вертикальные касательные. При 
этом аппроксимация кривой y = f(x) аналитическими функциями была бы невозможной. 
Кроме того кривые, которые надо представлять, могут быть неплоскими и 
незамкнутыми. Наконец, параметрическое представление обеспечивает независимость 
представления от выбора системы координат и соответствует процессу их 
отображения на устройствах: позиция естественным образом определяется как две 
функции времени x(t) и y(t). 
<P>В общем виде параметрические кубические кривые можно представить в форме: 
<P>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap></TD>
          <TD noWrap>
            <TABLE align=left border=0>
              <TBODY>
              <TR>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>x(t) = </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>A<SUB>11</SUB> 
                        &nbsp;&nbsp;t<SUP>3</SUP> </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>+</TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>A<SUB>12</SUB> 
                        &nbsp;&nbsp;t<SUP>2</SUP> </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>+</TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>A<SUB>13</SUB> &nbsp;&nbsp;t 
                    </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>+</TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle 
                  noWrap>A<SUB>14</SUB></TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=middle colSpan=0 noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>y(t) = </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>A<SUB>21</SUB> 
                        &nbsp;&nbsp;t<SUP>3</SUP> </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>+</TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>A<SUB>22</SUB> 
                        &nbsp;&nbsp;t<SUP>2</SUP> </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>+</TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>A<SUB>23</SUB> &nbsp;&nbsp;t 
                    </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>+</TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle 
                  noWrap>A<SUB>24</SUB></TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=middle colSpan=0 noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>z(t) = </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>A<SUB>31</SUB> 
                        &nbsp;&nbsp;t<SUP>3</SUP> </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>+</TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>A<SUB>32</SUB> 
                        &nbsp;&nbsp;t<SUP>2</SUP> </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>+</TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>A<SUB>33</SUB> &nbsp;&nbsp;t 
                    </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>+</TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE>
                    <TBODY>
                    <TR>
                      <TD align=middle colSpan=0 
                    noWrap>A<SUB>34</SUB></TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></TD>
          <TD noWrap></TD></TR></TBODY></TABLE></TD>
    <TD align=right width=100>(0.2.2)</TD></TR></TBODY></TABLE></CENTER>
<P>где параметр t можно считать изменяющимся в диапазоне от 0 до 1, так как 
интересуют конечные отрезки. 
<P>Существует много методов описания параметрических кубических кривых. К 
наиболее применяемым относятся: 
<P><FONT face=symbol>·</FONT> метод Безье, широко используемый в интерактивных 
приложениях; в нем задаются положения конечных точек кривой, а значения первой 
производной задаются неявно с помощью двух других точек, обычно не лежащих на 
кривой;<BR>
<P><FONT face=symbol>·</FONT> метод В-сплайнов, при котором конечные точки не 
лежат на кривой и на концах сегментов обеспечивается непрерывность первой и 
второй производных.<BR>
<P>В форме Безье кривая в общем случае задается в виде полинома Бернштейна: 
<P>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>P(t) = я<FONT face=symbol>е</FONT><SUB>i = 
            0</SUB><SUP>n</SUP> Cm<SUB>i</SUB> &nbsp;&nbsp;t<SUP>i</SUP> 
            &nbsp;&nbsp;(1-t)<SUP>m-1</SUP> &nbsp;&nbsp;P<SUB>i</SUB> 
        </TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>
<P>где P<SUB>i</SUB> - значения координат в вершинах ломаной, используемой в 
качестве управляющей ломаной для кривой, t - параметр, 
<P>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>Cm<SUB>i</SUB> = </TD>
          <TD align=middle noWrap>m!
            <HR noShade>
             i!&nbsp;&nbsp;(m-i)!<BR></TD>
          <TD align=middle 
noWrap></TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>
<P>При этом крайние точки управляющей ломаной и кривой совпадают, а наклоны 
первого и последнего звеньев ломаной совпадают с наклоном кривой в 
соответствующих точках. 
<P>Предложены различные быстрые схемы для вычисления кривой Безье. 
<P>В более общей форме B-сплайнов кривая в общем случае задается соотношением: 
<P>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>P(t) = <FONT face=symbol>е</FONT><SUB>i = 
            0</SUB><SUP>n</SUP> P<SUB>i</SUB> &nbsp;&nbsp;N<SUB>im</SUB>(t) 
        </TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>
<P>где P<SUB>i</SUB> - значения координат в вершинах ломаной, используемой в 
качестве управляющей ломаной для кривой, t - параметр, N<SUB>im</SUB> - весовые 
функции, определяемые рекуррентным соотношением: 
<P>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>N<SUB>i,1</SUB> = </TD>
          <TD align=left><FONT face=symbol>ь<BR>э<BR>ю </FONT></TD>
          <TD align=middle></TD>
          <TD noWrap>
            <TABLE align=left border=0>
              <TBODY>
              <TR>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>1, </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>если &nbsp;&nbsp;x<SUB>i</SUB> 
                        &nbsp;&nbsp; <FONT face=symbol>Ј</FONT> &nbsp;&nbsp;t 
                        &nbsp;&nbsp; <FONT face=symbol>Ј</FONT> 
                        &nbsp;&nbsp;x<SUB>i+1</SUB></TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=middle colSpan=0 noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>0, </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE>
                    <TBODY>
                    <TR>
                      <TD align=middle colSpan=0 noWrap>в 
                        &nbsp;&nbsp;других&nbsp;&nbsp;случаях</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></TD>
          <TD noWrap></TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>
<P>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>N<SUB>i,k</SUB>(t) = </TD>
          <TD align=middle noWrap>(t - 
x<SUB>i</SUB>)&nbsp;N<SUB>i,k-1</SUB>(t)
            <HR noShade>
             x<SUB>i+k-1</SUB> - x<SUB>i</SUB><BR></TD>
          <TD align=middle noWrap>+ </TD>
          <TD align=middle noWrap>(x<SUB>i+k</SUB> - 
            t)&nbsp;N<SUB>i+1,k-1</SUB>(t)
            <HR noShade>
             x<SUB>i+k</SUB> - x<SUB>i+1</SUB><BR></TD>
          <TD align=middle 
noWrap>.</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>
<P>Используются и многие другие методы, например, метод Эрмита, при котором 
задаются положения конечных точек кривой и значения первой производной в них. 
<P>Общее в упомянутых подходах состоит в том, что искомая кривая строится с 
использованием набора управляющих точек. 
<P>
<CENTER>
<H4>Построение поверхностей</H4></CENTER>
<P>Основные способы построения поверхностей: 
<P><FONT face=symbol>·</FONT> интерполяцией по точкам, 
<P><FONT face=symbol>·</FONT> перемещением образующей кривой по заданной 
траектории (кинематический метод),<BR>
<P><FONT face=symbol>·</FONT> деформацией исходной поверхности, 
<P><FONT face=symbol>·</FONT> построением поверхности эквидистантной к исходной, 

<P><FONT face=symbol>·</FONT> кинематический принцип, 
<P><FONT face=symbol>·</FONT> операции добавления/удаления в структуре, 
<P><FONT face=symbol>·</FONT> теоретико-множественные (булевские) операции. 
<P>Широко используется бикубические параметрические куски, с помощью которых 
сложная криволинейная поверхность аппроксимируется набором отдельных кусков с 
обеспечением непрерывности значения функции и первой (второй) производной при 
переходе от одного куска к другому. В общем случае представление бикубического 
параметрического куска имеет вид (приведена формула для x-координаты, для других 
координат формула аналогична): 
<P>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>x(s,t) = </TD>
          <TD noWrap>
            <TABLE align=left border=0>
              <TBODY>
              <TR>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>A<SUB>11</SUB> 
                        &nbsp;&nbsp;s<SUP>3</SUP> &nbsp;&nbsp;t<SUP>3</SUP> 
                    </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>+</TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle 
                        noWrap>A<SUB>12</SUB>&nbsp;&nbsp;s<SUP>3</SUP> 
                        &nbsp;&nbsp;t<SUP>2</SUP> </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>+</TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>A<SUB>13</SUB> 
                        &nbsp;&nbsp;s<SUP>3</SUP> &nbsp;&nbsp;t 
                  </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>+</TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle 
                        noWrap>A<SUB>14</SUB>&nbsp;&nbsp;s<SUP>3</SUP> 
                    </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>+</TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=middle colSpan=0 noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>A<SUB>21</SUB> 
                        &nbsp;&nbsp;s<SUP>2</SUP> &nbsp;&nbsp;t<SUP>3</SUP> 
                    </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>+</TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle 
                        noWrap>A<SUB>22</SUB>&nbsp;&nbsp;s<SUP>2</SUP> 
                        &nbsp;&nbsp;t<SUP>2</SUP> </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>+</TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>A<SUB>23</SUB> 
                        &nbsp;&nbsp;s<SUP>2</SUP> &nbsp;&nbsp;t 
                  </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>+</TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle 
                        noWrap>A<SUB>24</SUB>&nbsp;&nbsp;s<SUP>2</SUP> 
                    </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>+</TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=middle colSpan=0 noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>A<SUB>31</SUB> &nbsp;&nbsp;s 
                        &nbsp;&nbsp;t<SUP>3</SUP> </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>+</TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>A<SUB>32</SUB>&nbsp;&nbsp;s 
                        &nbsp;&nbsp;t<SUP>2</SUP> </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>+</TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>A<SUB>33</SUB> &nbsp;&nbsp;s 
                        &nbsp;&nbsp;t </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>+</TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>A<SUB>34</SUB>&nbsp;&nbsp;s 
                    </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>+</TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=middle colSpan=0 noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>A<SUB>41</SUB> 
                        &nbsp;&nbsp;t<SUP>3</SUP> </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>+</TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle 
                        noWrap>A<SUB>42</SUB>&nbsp;&nbsp;t<SUP>2</SUP> 
                    </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>+</TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>A<SUB>43</SUB> &nbsp;&nbsp;t 
                    </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>+</TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>A<SUB>44</SUB>. 
                  </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE>
                    <TBODY>
                    <TR>
                      <TD align=middle colSpan=0 
              noWrap></TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></TD>
          <TD noWrap></TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>
<P>Аналогично случаю с параметрическими кубическими кривыми, наиболее 
применимыми являются: 
<P><FONT face=symbol>·</FONT> форма Безье, 
<P><FONT face=symbol>·</FONT> форма В-сплайнов, 
<P><FONT face=symbol>·</FONT> форма Эрмита. 
<P>
<CENTER>
<H3><A name=tth_sEc0.9.3>0.9.3</A>&nbsp;&nbsp;Типы моделей</H3></CENTER>
<P>Как уже отмечалось, можно выделить два основных типа представлений 3D 
моделей: 
<P><FONT face=symbol>·</FONT> <I>граничное</I>, когда в модели хранятся границы 
объекта, например, вершины, ребра, грани,<BR>
<P><FONT face=symbol>·</FONT> в виде <I>дерева построения</I>, когда хранятся 
базовые объекты (призма, пирамида, цилиндр, конус и т.п.) из которых 
формировалось тело и использованные при этом операции; в узле дерева сохраняется 
операция формирования, а ветви представляют объекты.<BR>
<P>Предельным случаем граничной модели является модель, использующая 
<I>перечисление</I> всех точек занимаемого ею пространства. В частности, тело 
может быть аппроксимировано набором "склеенных" друг с другом параллелепипедов, 
что может быть удобно для некоторых вычислений (веса, объемы, расчеты методом 
конечных элементов и т.д.). 
<P>Часто используются гибридные модели, в которых в различной мере смешиваются 
эти два основных типа представления. В частности, в граничной модели может 
сохраняться информация о способе построения, например, информация о контуре и 
траектории его перемещения для формирования заданной поверхности (это т.н. 
<I>кинематические</I> модели). В моделях в виде дерева построения в качестве 
элементарных могут использоваться не только базовые объекты, но также и сплошные 
тела, заданные с помощью границ. 
<P>В общем случае нельзя утверждать, что одна модель во всем лучше другой. Так, 
например, граничная модель удобна для выполнения операций визуализации (удаление 
невидимых частей, закраска и т.п.), с другой стороны модель в виде дерева 
построения естественным образом может обеспечить параметризацию объекта, т.е. 
модификацию объекта изменением тех или иных отдельных параметров, вплоть до 
убирания каких-либо составных частей, но не удобна для визуализации, так как 
требует перевычисления объекта по дереву построения. Поэтому необходимы средства 
взаимного преобразования моделей. Понятно, что из более общей можно сформировать 
более простую, обратное преобразование далеко не всегда возможно или 
целесообразно, что и иллюстрируется сплошными и штриховыми линиями на 
рис.&nbsp;<A href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#r10_1">0.5.44</A>. 
<P>
<P><A name=tth_fIg0.13></A><A name=r10_1>
<CENTER><BR><IMG alt="Рисунок 77" 
src="Учебное пособие Основные алгоритмы компьютерной графики_files/kg0277.gif">
<P>
<P></CENTER>
<CENTER>Рис. 0.2.13: Преобразования моделей представления</CENTER></A>
<P>
<P>Из рис.&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#r10_1">0.5.44</A> видно особое 
место граничной модели, преобразование в которую возможно из любых других<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#tthFtNtAAB" 
name=tthFrefAAB><SUP>1</SUP></A>. Учитывая это, а также и то, что эта модель 
наиболее удобна для визуализации дальнейшее рассмотрение будет, в основном, 
относиться к этой модели. 
<P>Используются две основных разновидности способов представления поверхностей 
тела: 
<P><FONT face=symbol>·</FONT> представление в виде набора вершин, ребер и 
плоских многоугольников (полигональных сеток),<BR>
<P><FONT face=symbol>·</FONT> представление с использованием параметрических 
бикубических площадок (кусков).<BR>
<P>Полигональные сетки используются как для представления плоских поверхностей, 
так и для аппроксимации криволинейных, в том числе и параметрических 
бикубических площадок, поэтому далее в основном подразумевается представление 
поверхности в виде плоских многоугольников. 
<P>
<CENTER>
<H3><A name=tth_sEc0.9.4>0.9.4</A>&nbsp;&nbsp;Полигональные сетки</H3></CENTER>
<P>Как отмечалось, полигональная сетка представляет собой набор вершин, ребер и 
плоских многоугольников. Вершины соединяются ребрами. Многоугольники 
рассматриваются либо как последовательность вершин или ребер. Можно предложить 
много способов внутреннего представления полигональных сеток. 
<P>На рис.&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#r10_2">0.5.45</A> изображен 
простой пример полигональной сетки из четырех многоугольников с девятью 
вершинами и двенадцатью ребрами. На рис.&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#r10_3">0.5.46</A>-<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#r10_5">0.5.48</A> рассмотрены 
несколько различных представлений и приведены соображения по их эффективности и 
удобству манипулирования. 
<P>
<P><A name=tth_fIg0.14></A><A name=r10_2>
<CENTER><BR><IMG alt="Рисунок 78" 
src="Учебное пособие Основные алгоритмы компьютерной графики_files/kg0278.gif">
<P>
<P></CENTER>
<CENTER>Рис. 0.2.14: Пример полигональной сетки. P<SUB>i</SUB> - многоугольники, 
V<SUB>j</SUB> - вершины, E<SUB>k</SUB> - ребра.</CENTER></A>
<P>
<P>
<P><A name=tth_fIg0.15></A><A name=r10_3>
<CENTER><BR><IMG alt="Рисунок 79" 
src="Учебное пособие Основные алгоритмы компьютерной графики_files/kg0279.gif">
<P>
<P></CENTER>
<CENTER>Рис. 0.2.15: Представление полигональной сетки с явным заданием 
многоугольников. Компактно для одного многоугольника, но сильно избыточно для 
набора, так как не существует общего описания общих вершин и ребер.</CENTER></A>
<P>
<P>
<P><A name=tth_fIg0.16></A><A name=r10_4>
<CENTER><BR><IMG alt="Рисунок 80" 
src="Учебное пособие Основные алгоритмы компьютерной графики_files/kg0280.gif">
<P>
<P></CENTER>
<CENTER>Рис. 0.2.16: Представление полигональной сетки с указателями на списки 
вершин. Элементы списка указателей на вершины для каждого многоугольника 
ссылаются на соответствующие координатные данные для вершин. Данное 
представление компактнее предыдущего, но трудно найти многоугольники с общими 
ребрами.</CENTER></A>
<P>
<P>
<P><A name=tth_fIg0.17></A><A name=r10_5>
<CENTER><BR><IMG alt="Рисунок 81" 
src="Учебное пособие Основные алгоритмы компьютерной графики_files/kg0281.gif">
<P>
<P></CENTER>
<CENTER>Рис. 0.2.17: Представление полигональной сетки в виде списка ребер. 
Элементы списка ребер содержат указатели на вершины в списке вершин, образующие 
данное ребро. Для обеспечения поиска всех вершин, образующих данный 
многоугольник, необходимо иметь обратные указатели от вершины на одно из 
инцидентных к ней ребер.</CENTER></A>
<P>
<P>
<CENTER>
<H3><A name=tth_sEc0.9.5>0.9.5</A>&nbsp;&nbsp;Внутреннее представление 
моделей</H3></CENTER>
<P><FONT face=symbol>·</FONT> объемная модель, 
<P><FONT face=symbol>·</FONT> полиэдральная модель, 
<P><FONT face=symbol>·</FONT> упрощенные модели, 
<P><FONT face=symbol>·</FONT> сосуществование моделей. 
<P>Процедурная модель и представление в данных. 
<P>
<CENTER>
<H3><A name=tth_sEc0.10>0.10</A>&nbsp;&nbsp;УДАЛЕНИЕ СКРЫТЫХ ЛИНИЙ И 
ПОВЕРХНОСТЕЙ</H3></CENTER>
<P>
<CENTER>
<H3><A name=tth_sEc0.10.1>0.10.1</A>&nbsp;&nbsp;Классификация методов удаления 
невидимых частей</H3></CENTER>
<P>Методы удаления невидимых частей сцены можно классифицировать: 
<P>
<OL type=1>
  <LI>По выбору удаляемых частей:<BR>удаление невидимых линий, ребер, 
  поверхностей, объемов. 
  <LI>По порядку обработки элементов сцены:<BR>удаление в произвольном порядке и 
  в порядке, определяемом процессом визуализации. 
  <LI>По системе координат: 
  <UL>
    <P>
    <LI>алгоритмы работающие в пространстве объектов, когда каждая из N граней 
    объекта сравнивается с остальными N-1 гранями (объем вычислений растет как 
    N<SUP>2</SUP>), 
    <LI>алгоритмы работающие в пространстве изображения, когда для каждого 
    пиксела изображения определяется какая из N граней объекта видна (при 
    разрешении экрана M&times;M объем вычислений растет как M<SUP>2</SUP> &times;N). 
</LI></UL>
  <P></P></LI></OL>
<CENTER>
<H3><A name=tth_sEc0.10.2>0.10.2</A>&nbsp;&nbsp;Алгоритмы удаления 
линий</H3></CENTER>
<P>Применение - векторные устройства. Могут применяться и в растровых для 
ускорения процесса визуализации, но при этом не используется основное ценное 
качество растрового дисплея - возможность закраски поверхностей. 
<P>Наиболее известный ранний алгоритм - алгоритм Робертса (1963&nbsp;г.). 
Работает с только выпуклыми телами в пространстве объектов. Каждый объект сцены 
представляется многогранным телом, полученным в результате пересечения 
плоскостей. Т.е. тело описывается списком граней, состоящих из ребер, которые в 
свою очередь образованы вершинами. 
<P>Вначале из описания каждого тела удаляются нелицевые плоскости, 
экранированные самим телом. Затем каждое из ребер сравнивается с каждым телом 
для определения видимости или невидимости. Т.е. объем вычислений растет как 
квадрат числа объектов в сцене. Наконец вычисляются новые ребра, полученные при 
протыкании телами друг друга. 
<P>
<CENTER>
<H3><A name=tth_sEc0.10.3>0.10.3</A>&nbsp;&nbsp;Алгоритм удаления поверхностей с 
Z-буфером</H3></CENTER>
<P>Алгоритм предложен Эдом Кэтмулом и представляет собой обобщение буфера кадра. 
Обычный буфер кадра хранит коды цвета для каждого пиксела в пространстве 
изображения. Идея алгоритма состоит в том, чтобы для каждого пиксела 
дополнительно хранить еще и координату Z или глубину. При занесении очередного 
пиксела в буфер кадра значение его Z-координаты сравнивается с Z-координатой 
пиксела, который уже находится в буфере. Если Z-координата нового пиксела 
больше, чем координата старого, т.е. он ближе к наблюдателю, то атрибуты нового 
пиксела и его Z-координата заносятся в буфер, если нет, то ни чего не делается. 
<P>Этот алгоритм наиболее простой из всех алгоритмов удаления невидимых 
поверхностей, но требует большого объема памяти. Данные о глубине для 
реалистичности изображения обычно достаточно иметь с разрядностью порядка 20 
бит. В этом случае при изображении нормального телевизионного размера в 768&times;576 
пикселов для хранения Z-координат необходим объем памяти порядка 1 Мбайта. 
Суммарный объем памяти при 3 байтах для значений RGB составит более 2.3 Мбайта. 
<P>Время работы алгоритма не зависит от сложности сцены. Многоугольники, 
составляющие сцену, могут обрабатываться в произвольном порядке. Для сокращения 
затрат времени нелицевые многоугольники могут быть удалены. По сути дела 
алгоритм с Z-буфером - некоторая модификация уже рассмотренного алгоритма 
заливки многоугольника. Если используется построчный алгоритм заливки, то легко 
сделать пошаговое вычисление Z-координаты очередного пиксела, дополнительно 
храня Z-координаты его вершин и вычисляя приращение dz Z-координаты при 
перемещении вдоль X на dx, равное 1. Если известно уравнение плоскости, в 
которой лежит обрабатываемый многоугольник, то можно обойтись без хранения 
Z-координат вершин. Пусть уравнение плоскости имеет вид: 
<P>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>A·x + B·y + C·z + D = 
    0.</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>
<P>Тогда при C не равном нулю 
<P>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>z = -(A·x + B·y + 
  D)/C</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>
<P>Найдем приращение Z-координаты пиксела при шаге по X на dx, помня, что Y 
очередной обрабатываемой строки - константа. 
<P>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>dz = -(A·(x+dx) + D)/C + (A·x + D)/C = 
            -A·dx/C</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>
<P>но dx = 1, поэтому 
<P>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>dz = 
-A/C.</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>
<P>Основной недостаток алгоритма с Z-буфером - дополнительные затраты памяти. 
Для их уменьшения можно разбивать изображение на несколько прямоугольников или 
полос. В пределе можно использовать Z-буфер в виде одной строки. Понятно, что 
это приведет к увеличению времени, так как каждый прямоугольник будет 
обрабатываться столько раз, на сколько областей разбито пространство 
изображения. Уменьшение затрат времени в этом случае может быть обеспечено 
предварительной сортировкой многоугольников на плоскости. 
<P>Другие недостатки алгоритма с Z-буфером заключаются в том, что так как 
пикселы в буфер заносятся в произвольном порядке, то возникают трудности с 
реализацией эффектов прозрачности или просвечивания и устранением лестничного 
эффекта с использованием предфильтрации, когда каждый пиксел экрана трактуется 
как точка конечного размера и его атрибуты устанавливаются в зависимости от того 
какая часть пиксела изображения попадает в пиксел экрана. Но другой подход к 
устранению лестничного эффекта, основанный на постфильтрации - усреднении 
значений пиксела с использованием изображения с большим разрешением реализуется 
сравнительно просто за счет увеличения расхода памяти (и времени). В этом случае 
используются два метода. Первый состоит в том, что увеличивается разрешение 
только кадрового буфера, хранящего атрибуты пикселов, а разрешение Z-буфера 
делается совпадающим с размерами пространства изображения. Глубина изображения 
вычисляется только для центра группы усредняемых пикселов. Это метод неприменим, 
когда расстояние до наблюдателя имитируется изменением интенсивности пикселов. 
Во втором методе и кадровый и Z буфера имеют увеличенное разрешение и 
усредняются атрибуты пиксела, так и его глубина. 
<P>Общая схема алгоритма с Z-буфером: 
<P><FONT face=symbol>·</FONT> Инициализировать кадровый и Z-буфера. Кадровый 
буфер закрашивается фоном. Z-буфер закрашивается минимальным значением Z. 
<P><FONT face=symbol>·</FONT> Выполнить преобразование каждого многоугольника 
сцены в растровую форму. При этом для каждого пиксела вычисляется его глубина z. 
Если вычисленная глубина больше, чем глубина, уже имеющаяся в Z-буфере, то 
занести в буфера атрибуты пиксела и его глубину, иначе никаких занесений не 
выполнять. 
<P><FONT face=symbol>·</FONT> Выполнить, если это было предусмотрено, усреднение 
изображения с понижением разрешения. 
<P>
<CENTER>
<H3><A name=tth_sEc0.10.4>0.10.4</A>&nbsp;&nbsp;Построчный алгоритм с 
Z-буфером</H3></CENTER>
<P>Рассмотрим теперь алгоритм с Z-буфером размером в одну строку, который 
представляет собой обобщение алгоритма построчной заливки многоугольника, 
представленный в процедурах V_FP0 и V_FP1 в приложениях. Модификация должна 
учесть то, что для каждой строки сканирования теперь может обрабатываться не 
один многоугольник. 
<P>Общая схема такого алгоритма следующая: 
<OL type=1>
  <P>
  <LI>Подготовка данных.<BR>Для каждого многоугольника определить максимальную 
  Y-координату.<BR>Занести многоугольник в группу многоугольников, 
  соответствующую данной Y-координате. 
  <LI>Собственно заливка. </LI></OL>
<P>
<CENTER>
<H3><A name=tth_sEc0.10.5>0.10.5</A>&nbsp;&nbsp;Алгоритм разбиения области 
Варнока</H3></CENTER>
<P>Алгоритм работает в пространстве изображения и анализирует область на экране 
дисплея (окно) на наличие в них видимых элементов. Если в окне нет изображения, 
то оно просто закрашивается фоном. Если же в окне имеется элемент, то 
проверяется достаточно ли он прост для визуализации. Если объект сложный, то 
окно разбивается на более мелкие, для каждого из которых выполняется тест на 
отсутствие и/или простоту изображения. Рекурсивный процесс разбиения может 
продолжаться до тех пор пока не будет достигнут предел разрешения экрана. 
<P>Можно выделить 4 случая взаимного расположения окна и многоугольника 
(рис.&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#r11_01">0.6.49</A>):<BR><FONT 
face=symbol>·</FONT>&nbsp;многоугольник целиком вне окна,<BR><FONT 
face=symbol>·</FONT>&nbsp;многоугольник целиком внутри окна,<BR><FONT 
face=symbol>·</FONT>&nbsp;многоугольник пересекает окно,<BR><FONT 
face=symbol>·</FONT>&nbsp;многоугольник охватывает окно. 
<P>
<P><A name=tth_fIg0.18></A><A name=r11_01>
<CENTER><BR><IMG alt="Рисунок 82" 
src="Учебное пособие Основные алгоритмы компьютерной графики_files/kg0282.gif">
<P></CENTER>
<CENTER>Рис. 0.3.18: Соотношения между окном экрана (сплошная рамка) и 
многоугольником (штриховая рамка)</CENTER></A>
<P>
<P>В четырех случаях можно сразу принять решение о правилах закраски области 
экрана: 
<P><FONT face=symbol>·</FONT> все многоугольники сцены - внешние по отношению к 
окну. В этом случае окно закрашивается фоном; 
<P><FONT face=symbol>·</FONT> имеется всего один внутренний или пересекающий 
многоугольник. В этом случае все окно закрашивается фоном и затем часть окна, 
соответствующая внутреннему или пересекающему окну закрашивается цветом 
многоугольника; 
<P><FONT face=symbol>·</FONT> имеется единственный охватывающий многоугольник. В 
этом случае окно закрашивается его цветом. 
<P><FONT face=symbol>·</FONT> имеется несколько различных многоугольников и хотя 
бы один из них охватывающий. Если при этом охватывающий многоугольник расположен 
ближе остальных к наблюдателю, то окно закрашивается его цветом. 
<P>В любых других случаях процесс разбиения окна продолжается. Легко видеть, что 
при растре 1024&times;1024 и делении стороны окна пополам требуется не более 10 
разбиений. Если достигнуто максимальное разбиение, но не обнаружено ни одного из 
приведенных выше четырех случаев, то для точки с центром в полученном 
минимальном окне (размером в пиксел) вычисляются глубины оставшихся 
многоугольников и закраску определяет многоугольник, наиболее близкий к 
наблюдателю. При этом для устранения лестничного эффекта можно выполнить 
дополнительные разбиения и закрасить пиксел с учетом всех многоугольников, 
видимых в минимальном окне. 
<P>Первые три случая идентифицируются легко. Последний же случай фактически 
сводится к поиску охватывающего многоугольника, перекрывающего все остальные 
многоугольники, связанные с окном. Проверка на такой многоугольник может быть 
выполнена следующим образом: в угловых точках окна вычисляются Z-координаты для 
всех многоугольников, связанных с окном. Если все четыре такие Z-координаты 
охватывающего многоугольника ближе к наблюдателю, чем все остальные, то окно 
закрашивается цветом соответствующего охватывающего многоугольника. Если же нет, 
то мы имеем сложный случай и разбиение следует продолжить. 
<P>Очевидно, что после разбиения окна охватывающие и внешние многоугольники 
наследуются от исходного окна. Поэтому необходимо проверять лишь внутренние и 
пересекающие многоугольники. 
<P>Из изложенного ясно, что важной частью алгоритма является определение 
расположения многоугольника относительно окна. 
<P>Проверка на то что многоугольник внешний или внутренний относительно окна для 
случая прямоугольных окон легко реализуется использованием прямоугольной 
оболочки многоугольника и сравнением координат. Для внутреннего многоугольника 
должны одновременно выполняться условия: 
<P>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>Xmin <FONT face=symbol>і</FONT> 
            Wл&nbsp;&nbsp;&nbsp;&nbsp;и&nbsp;&nbsp;&nbsp;&nbsp;Xmax <FONT 
            face=symbol>Ј</FONT> 
            Wп&nbsp;&nbsp;&nbsp;&nbsp;и&nbsp;&nbsp;&nbsp;&nbsp;Ymin <FONT 
            face=symbol>і</FONT> 
            Wн&nbsp;&nbsp;&nbsp;&nbsp;и&nbsp;&nbsp;&nbsp;&nbsp;Ymax <FONT 
            face=symbol>Ј</FONT> 
Wв,</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>
<P>
<TABLE>
  <TBODY>
  <TR>
    <TD>здесь </TD>
    <TD>Xmin,Xmax,Ymin,Ymax </TD>
    <TD align=middle>- </TD>
    <TD>ребра оболочки</TD>
  <TR>
    <TD></TD>
    <TD>Wл, Wп, Wн, Wв </TD>
    <TD align=middle>- </TD>
    <TD>ребра окна</TD></TD></TR></TBODY></TABLE>
<P>Для внешнего многоугольника достаточно выполнение любого из следующих 
условий: 
<P>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>Xmin &gt; Xп,&nbsp;&nbsp;&nbsp;&nbsp;Xmax 
            &lt; Wл,&nbsp;&nbsp;&nbsp;&nbsp;Ymin &gt; Wв, 
            &nbsp;&nbsp;&nbsp;&nbsp;Ymax &lt; 
  Wн</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>
<P>Таким способом внешний многоугольник, охватывающий угол окна не будет 
идентифицирован как внешний (см. рис.&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#r11_02">0.6.50</A>). 
<P>
<P><A name=tth_fIg0.19></A><A name=r11_02>
<CENTER><BR><IMG alt="Рисунок 83" 
src="Учебное пособие Основные алгоритмы компьютерной графики_files/kg0283.gif">
<P></CENTER>
<CENTER>Рис. 0.3.19: Ошибочное определение внешнего многоугольника как 
пересекающего при использовании прямоугольной оболочки</CENTER></A>
<P>
<P>Проверка на пересечение окна многоугольником может быть выполнена проверкой 
на расположение всех вершин окна по одну сторону от прямой, на которой 
расположено ребро многоугольника. Пусть ребро многоугольника задано точками 
P1(x1,y1,z1) и P2(x2,y2,z2), а очередная вершина окна задается точкой 
P3(x3,y3,z3). Векторное произведение вектора <B>P1P3</B> на вектор <B>P1P2</B>, 
равное (x3-x1)(y2-y1) - (y3-y1)(x2-x1) будет меньше 0, равно 0 или больше 0, 
если вершина лежит слева, на или справа от прямой P1P2. Если знаки различны, то 
окно и многоугольник пересекаются. Если же все знаки одинаковы, то окно лежит по 
одну сторону от ребра, т.е. многоугольник может быть либо внешним, либо 
охватывающим. 
<P>Вернемся к примеру&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#r11_02">0.6.50</A>. Такой 
многоугольник рассмотренными тестами не был идентифицирован ни как внутренний ни 
как пересекающий. Т.е. он может быть либо внешним, либо охватывающим. Для 
завершающей классификации может использоваться тест с подсчетом угла, 
рассматривавшийся ранее для определения нахождения точки внутри/вне 
многоугольника. В этом тесте вычисляется суммарный угол, на который повернется 
луч, исходящий из некоторой точки окна (обычно центра), при последовательном 
обходе вершин многоугольника. 
<P>Если суммарный угол равен 0, то многоугольник - внешний. Если же угол равен 
N&times;360<SUP><FONT face=symbol>°</FONT></SUP>, то многоугольник охватывает окно N 
раз. Простейшая иллюстрация этого теста приведена на рис.&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#r11_03">0.6.51</A>. 
<P>
<P><A name=tth_fIg0.20></A><A name=r11_03>
<CENTER><BR><IMG alt="Рисунок 84" 
src="Учебное пособие Основные алгоритмы компьютерной графики_files/kg0284.gif">
<P></CENTER>
<CENTER>Рис. 0.3.20: Тест на охватывающий/внешний многоугольник</CENTER></A>
<P>
<P>
<CENTER>
<H3><A name=tth_sEc0.10.6>0.10.6</A>&nbsp;&nbsp;Построчный алгоритм 
Уоткинса</H3></CENTER>
<P>В алгоритмах построчного сканирования результирующее изображение генерируется 
построчно причем, подобно ранее рассмотренному алгоритму построчной заливки 
многоугольника, используется связность соседних растровых строк изображения. 
Отличие состоит в том, что учитываются все, а не один многоугольник. 
<P>Алгоритм работает в пространстве изображения с окном высотой в одну строку и 
шириной в экран, тем самым трехмерная задача сводится к двумерной. 
<P>Последовательность шагов алгоритма:<BR><FONT 
face=symbol>·</FONT>&nbsp;построение списка ребер,<BR><FONT 
face=symbol>·</FONT>&nbsp;построение списка многоугольников, 
<P><FONT face=symbol>·</FONT> построение списка активных ребер - создается 
таблица ребер, включающая все негоризонтальные ребра многоугольников, причем 
элементы таблицы по значению Y-координаты отсортированы по группам. 
<P>
<CENTER>
<H3><A name=tth_sEc0.10.7>0.10.7</A>&nbsp;&nbsp;Алгоритм трассировки 
лучей</H3></CENTER>
<P>При рассмотрении этого алгоритма предполагается, что наблюдатель находится на 
положительной полуоси Z, а экран дисплея перпендикулярен оси Z и располагается 
между объектом и наблюдателем. 
<P>Удаление невидимых (скрытых) поверхностей в алгоритме трассировки лучей 
выполняется следующим образом:<BR><FONT face=symbol>·</FONT>&nbsp;сцена 
преобразуется в пространство изображения, 
<P><FONT face=symbol>·</FONT> из точки наблюдения в каждый пиксел экрана 
проводится луч и определяется какие именно объекты сцены пересекаются с лучом, 
<P><FONT face=symbol>·</FONT> вычисляются и упорядочиваются по Z координаты 
точек пересечения объектов с лучом. В простейшем случае для непрозрачных 
поверхностей без отражений и преломлений видимой точкой будет точка с 
максимальным значением Z-координаты. Для более сложных случаев требуется 
сортировка точек пересечения вдоль луча. 
<P>Ясно, что наиболее важная часть алгоритма - процедура определения 
пересечения, которая в принципе выполняется Rx&times;Ry&times;N раз (здесь Rx,Ry - 
разрешение дисплея по X и Y, соответственно, а N - количество многоугольников в 
сцене). 
<P>Очевидно, что повышение эффективности может достигаться сокращением времени 
вычисления пересечений и избавлением от ненужных вычислений. Последнее 
обеспечивается использованием геометрически простой оболочки, объемлющей объект 
- если луч не пересекает оболочку, то не нужно вычислять пересечения с ним 
многоугольников, составляющих исследуемый объект. 
<P>При использовании прямоугольной оболочки определяется преобразование, 
совмещающее луч с осью Z. Оболочка подвергается этому преобразованию, а затем 
попарно сравниваются знаки Xmin с Xmax и Ymin с Ymax. Если они различны, то есть 
пересечение луча с оболочкой (см. рис.&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#r11_04">0.6.52</A>) 
<P>
<P><A name=tth_fIg0.21></A><A name=r11_04>
<CENTER><BR><IMG alt="Рисунок 85" 
src="Учебное пособие Основные алгоритмы компьютерной графики_files/kg0285.gif" 
?>
<P></CENTER>
<CENTER>Рис. 0.3.21: Определение пересечения луча и оболочки</CENTER></A>
<P>
<P>При использовании сферической оболочки для определения пересечения луча со 
сферой достаточно сосчитать расстояние от луча до центра сферы. Если оно больше 
радиуса, то пересечения нет. Параметрическое уравнение луча, проходящего через 
две точки P1(x1,y1,z1) и P2(x2,y2,z2), имеет вид: 
<P>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>P(t) = P1 + (P2 - 
    P1)&times;t</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>
<P>Минимальное расстояние от точки центра сферы P0(x0,y0,z0) до луча равно: 
<P>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>d<SUP>2</SUP> = (x-x0)<SUP>2</SUP> + 
            (y-y0)<SUP>2</SUP> + 
  (z-z0)<SUP>2</SUP></TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>
<P>Этому соответствует значение t: 
<P>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>t = -</TD>
          <TD align=middle noWrap>(x2-x1)·(x1-x0) + (y2-y1)·(y1-y0) + 
            (z2-z1)·(z1-z0)
            <HR noShade>
             (x2-x1)<SUP>2</SUP> + (y2-y1)<SUP>2</SUP> + 
          (z2-z1)<SUP>2</SUP><BR></TD>
          <TD align=middle 
noWrap>.</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>
<P>Если d2 &gt; R2, то луч не пересекает объекты, заключенные в оболочку. 
<P>Дальнейшее сокращение расчетов пересечений основывается на использовании 
групп пространственно связанных объектов. Каждая такая группа окружается общей 
оболочкой. Получается иерархическая последовательность оболочек, вложенная в 
общую оболочку для всей сцены. Если луч не пересекает какую-либо оболочку, то из 
рассмотрения исключаются все оболочки, вложенные в нее и, следовательно, 
объекты. Если же луч пересекает некоторую оболочку, то рекурсивно анализируются 
все оболочки вложенные в нее. 
<P>Наряду с вложенными оболочками для сокращения расчетов пересечений 
используется отложенное вычисление пересечений с объектами. Если обнаруживается, 
что объект пересекается лучом, то он заносится в специальный список 
пересеченных. После завершения обработки всех объектов сцены объекты, попавшие в 
список пересеченных упорядочиваются по глубине. Заведомо невидимые отбрасываются 
а для оставшихся выполняется расчет пересечений и отображается точка пересечения 
наиболее близкая к наблюдателю. 
<P>Дополнительное сокращение объема вычислений может достигаться отбрасыванием 
нелицевых граней, учетов связности строк растрового разложения и т.д. 
<P>Для сокращения времени вычислений собственно пересечений предложено 
достаточно много алгоритмов, упрощающих вычисления для определенной формы 
задания поверхностей. 
<P>
<CENTER>
<H3><A name=tth_sEc0.11>0.11</A>&nbsp;&nbsp;РЕАЛИСТИЧНОЕ ПРЕДСТАВЛЕНИЕ 
СЦЕН</H3></CENTER>
<P>Где нужен реализм:<BR><FONT face=symbol>·</FONT>&nbsp;в 
конструировании,<BR><FONT face=symbol>·</FONT>&nbsp;в архитектуре,<BR><FONT 
face=symbol>·</FONT>&nbsp;в биологии и медицине,<BR><FONT 
face=symbol>·</FONT>&nbsp;в науке (компьютерное моделирование),<BR><FONT 
face=symbol>·</FONT>&nbsp;в масс-медиа,<BR><FONT face=symbol>·</FONT>&nbsp;в 
тренажерах, играх. 
<P>Основные направления:<BR><FONT face=symbol>·</FONT>&nbsp;синтез реалистичных 
изображений,<BR><FONT face=symbol>·</FONT>&nbsp;реалистическое оживление 
синтезированных объектов. 
<P>С точки зрения приложений в науке и промышленности наиболее важно первое 
направление. Ключевая проблема - реалистическое представление 
освещенности:<BR><FONT face=symbol>·</FONT>&nbsp;модели освещения, прозрачность, 
тени, фактура, <FONT face=symbol>·</FONT>&nbsp;глобальная модель освещения с 
трассировкой лучей, <FONT face=symbol>·</FONT>&nbsp;излучательность. 
<P>
<CENTER>
<H3><A name=tth_sEc0.11.1>0.11.1</A>&nbsp;&nbsp;Модели освещения</H3></CENTER>
<P>
<CENTER>
<H4>Механизм диффузного и зеркального отражения света</H4></CENTER>
<P>Диффузное отражение света точечного источника от идеального рассеивателя 
определяется по закону Ламберта, согласно которому падающий свет рассеивается во 
все стороны с одинаковой интенсивностью. В этом случае освещенность точки 
пропорциональна доле ее площади, видимой от источника. 
<P>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>Ir = Ip ·Pd ·cos(<FONT 
          face=symbol>f</FONT>),</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>
<P>где Ir - интенсивность отраженного света, Ip - интенсивность точечного 
источника, 0 <FONT face=symbol>Ј</FONT> Pd <FONT face=symbol>Ј</FONT> 1 - 
коэффициент диффузного отражения, зависящий от материала поверхности и длины 
волны, 0 <FONT face=symbol>Ј</FONT> <FONT face=symbol>f</FONT> <FONT 
face=symbol>Ј</FONT> <FONT face=symbol>p</FONT>/2 - угол между направлением 
света и нормалью к поверхности. 
<P>В реальных сценах, кроме света от точечных источников, присутствует и 
рассеянный свет, который упрощенно учитывается с помощью коэффициента рассеяния: 

<P>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>I = Ir ·Pr + Ip ·Pd ·cos(<FONT 
            face=symbol>f</FONT>),</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>
<P>где Ir - интенсивность рассеянного света, 0 <FONT face=symbol>Ј</FONT> Pr 
<FONT face=symbol>Ј</FONT> 1 - коэффициент диффузного отражения рассеянного 
света. 
<P>Субъективно достаточно реалистичный учет расстояния от центра проекции до 
объекта обеспечивается линейным затуханием: 
<P>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>I = Ir·Pr + </TD>
          <TD align=middle noWrap>Ip·Pd·cos(<FONT face=symbol>f</FONT>)
            <HR noShade>
             d + K<BR></TD>
          <TD align=middle 
noWrap>,</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>
<P>где d - расстояние от центра проекции до объекта, а K - произвольная 
константа. 
<P>При параллельной проекции, когда точка наблюдения находится в бесконечности, 
учет расстояния обеспечивается тем, что объект, ближайший к точке наблюдения, 
освещается полностью, далее расположенные - с уменьшенной освещенностью и в 
качестве d берется расстояние от объекта ближайшего к наблюдателю. 
<P>Свет, отраженный от идеального зеркала, виден только если угол между 
направлениями наблюдения и отражения равен нулю. Для неидеальных отражающих 
поверхностей используется модель Фонга [<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#mbib27" name=CITEmbib27>27</A>]: 
<P>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>Is = Ip ·W(<FONT face=symbol>l</FONT>, <FONT 
            face=symbol>f</FONT>) ·cos<SUP>n</SUP>(<FONT 
          face=symbol>a</FONT>),</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>
<P>где W(<FONT face=symbol>l</FONT>, <FONT face=symbol>f</FONT>) - кривая 
отражения, зависящая от длины волны <FONT face=symbol>l</FONT> света источника и 
угла падения <FONT face=symbol>f</FONT>, &nbsp;&nbsp;&nbsp;&nbsp;-<FONT 
face=symbol>p</FONT>/1 <FONT face=symbol>Ј</FONT> <FONT face=symbol>a</FONT> 
<FONT face=symbol>Ј</FONT> <FONT face=symbol>p</FONT>/2 - угол между 
направлениями наблюдения и отражения, 1 <FONT face=symbol>Ј</FONT> n <FONT 
face=symbol>Ј</FONT> 200 - показатель степени, определяющий убывание 
интенсивности при изменении угла. 
<P>Часто W(<FONT face=symbol>l</FONT>, <FONT face=symbol>f</FONT>) заменяется 
константой Ks, такой чтобы полученная картина была субъективно приемлема. 
<P>Суммарная модель освещения имеет вид: 
<P>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>I = Ir ·Pr + </TD>
          <TD align=middle noWrap>Ip
            <HR noShade>
             d+K<BR></TD>
          <TD align=middle noWrap>(Pd ·cos(<FONT face=symbol>f</FONT>) + 
            W(<FONT face=symbol>l</FONT>, <FONT face=symbol>f</FONT>) 
            ·cos<SUP>n</SUP>(<FONT 
  face=symbol>a</FONT>)).</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>
<P>Или при использовании вместо W(<FONT face=symbol>l</FONT>, <FONT 
face=symbol>f</FONT>) константы Ks: 
<P>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>I = Ir·Pr +</TD>
          <TD align=middle noWrap>Ip
            <HR noShade>
             d+K<BR></TD>
          <TD align=middle noWrap>(Pd ·cos(<FONT face=symbol>f</FONT>) + Ks 
            ·cos<SUP>n</SUP>(<FONT 
  face=symbol>a</FONT>)).</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>
<P>Если использовать нормированные вектора направлений падения <B>L</B>, нормали 
<B>N</B>, отражения <B>R</B> и наблюдения <B>V</B>, то модель освещения для 
одного источника принимает вид: 
<P>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>I = Ir ·Pr + </TD>
          <TD align=middle noWrap>Ip
            <HR noShade>
             d+K<BR></TD>
          <TD align=middle noWrap>(Pd·<B>L</B>·<B>N</B> + Ks 
            ·(<B>R</B>·<B>V</B>)<SUP>n</SUP>).</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>
<P>Если источник света находится бесконечности, то для данного плоского 
многоугольника <B>L·N</B> равно константе, а <B>R·V</B> меняется в пределах 
многоугольника. Для поверхностей, представленных например в виде бикубических 
кусков, каждое произведение меняется в пределах куска. Так как эти вычисления 
требуется производить для каждого пиксела строки, то вычислительные затраты 
могут быть очень велики. Фонг предложил алгоритм пошагового вычисления по 
рассмотренной модели, существенно снижающий затраты. 
<P>Кроме эмпирической модели освещенности Фонга используются модели, 
представляющие отражающую поверхность в виде плоских микроскопических граней. 
Ориентации нормалей к граням относительно нормали к средней линии поверхности 
задаются некоторым распределением, например, Гаусса. 
<P>
<CENTER>
<H3><A name=tth_sEc0.11.2>0.11.2</A>&nbsp;&nbsp;Модели закраски</H3></CENTER>
<P>Существует три основных способа закраски многоугольников: однотонная 
закраска, закраска с интерполяцией интенсивности и закраска с интерполяцией 
векторов нормали. 
<P>При однотонной закраске предполагается, что и источник света и наблюдатель 
находятся в бесконечности, поэтому произведения <B>L·N</B> и <B>R·V</B> 
постоянны. На изображении могут быть хорошо заметны резкие перепады 
интенсивности между различно закрашенными многоугольниками. Если многоугольники 
представляют собой результат аппроксимации криволинейной поверхности, то 
изображение недостаточно реалистично. 
<P>В методе закраски с интерполяцией интенсивности (метод Гуро) нормали в 
вершинах многоугольников вычисляются как результат усреднения нормалей ко всем 
полигональным граням, которым принадлежит данная вершина. Используя значения 
нормалей, вычисляют интенсивности в вершинах по той или иной модели освещения. 
Эти значения затем используются для билинейной интерполяции: для данной строки 
сканирования вначале находят значения интенсивностей на ребрах, а затем линейно 
интерполируют между ними при закраске вдоль строки. 
<P>В методе закраски с интерполяцией нормали (метод Фонга) значение нормали 
вдоль строки интерполируется между значениями нормалей на ребрах для данной 
строки. Значения нормалей на ребрах получается как результат интерполирования 
между вершинами. Значения же нормалей в вершинах являются результатом 
усреднения, как и выше рассмотренном методе. Значение нормали для каждого из 
пикселов строки используется для вычислений по той или иной модели освещения. 
<P>
<CENTER>
<H3><A name=tth_sEc0.11.3>0.11.3</A>&nbsp;&nbsp;Прозрачность</H3></CENTER>
<P>В простейшей модели прозрачности преломление не учитывается. При расчетах по 
такой модели могут использоваться любые алгоритмы удаления невидимых 
поверхностей, учитывающие порядок расположения многоугольников. При 
использовании построчных алгоритмов если передний многоугольник оказывается 
прозрачным, то определяется ближайший из оставшихся, внутри которых находится 
строка сканирования. Суммарная закраска определяется следующим образом: 
<P>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>I = k·Iб + 
  (1-k)·Iд,</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>
<P>где 0 <FONT face=symbol>Ј</FONT> k <FONT face=symbol>Ј</FONT> 1 - 
характеризует прозрачность ближнего многоугольника. Если k = 1, то он 
непрозрачен. Если же k = 0, то ближний многоугольник полностью прозрачен; Iб - 
интенсивность для пиксела ближнего многоугольника, Iд - дальнего. 
<P>
<CENTER>
<H3><A name=tth_sEc0.11.4>0.11.4</A>&nbsp;&nbsp;Тени</H3></CENTER>
<P>Простой способ определения объектов, попавших в тень и, следовательно, 
неосвещенных, аналогичен алгоритму удаления невидимых поверхностей: те объекты, 
которые невидимы из источника освещения, но видимы из точки зрения находятся в 
тени. На первом шаге в алгоритме с учетом тени определяются все многоугольники, 
видимые из точки освещения. Затем выполняется удаление поверхностей невидимых из 
точки зрения. При выполнении закраски многоугольника проверяется не закрыт ли он 
многоугольником, видимым из источника освещения. Если да, то в модели освещения 
учитываются (если надо) все три компоненты - диффузное и зеркальное отражения и 
рассеянный свет. Если же перекрытия нет, то закрашиваемый многоугольник 
находится в тени и надо учитывать только рассеянный свет. 
<P>
<CENTER>
<H3><A name=tth_sEc0.11.5>0.11.5</A>&nbsp;&nbsp;Фактура</H3></CENTER>
<P>Решение в лоб - представление в виде соответствующего (очень большого) 
количества многоугольников мало приемлемо. Более практичное решение - 
"натягивание" массива узора, полученного в результате оцифровки изображения 
реальной поверхности на раскрашиваемую. При этом значения из массива узора 
используются для масштабирования диффузной компоненты в модели освещения. 
<P>Для устранения лестничного эффекта должны учитываться все элементы узора, 
затрагивающие обрабатываемый пиксел изображения. 
<P>Такой метод влияет на раскраску поверхности, но оставляет ее гладкой. 
Неровности могут моделироваться возмущениями нормали поверхности. Другой способ, 
используемый при синтезе картин - метод фрактальной геометрии. 
<P>
<CENTER>
<H3><A name=tth_sEc0.11.6>0.11.6</A>&nbsp;&nbsp;Трассировка лучей</H3></CENTER>
<P>Метод трассировки лучей используется не только для удаления невидимых частей, 
но, в основном, для получения высокореалистичных изображений с учетом отражений 
и преломлений света. 
<P>Прямой трассировкой лучей называется процесс расчета освещения сцены с 
испусканием от всех источников лучей во всех направлениях. При попадании на 
какой-либо объект сцены луч света может преломившись уйти внутрь тела или 
отразившись далее продолжить прямолинейное распространение до попадания на 
следующий объект и так далее. Следовательно, каждая точка сцены может освещаться 
либо напрямую источником, либо отраженным светом. Часть лучей в конце концов 
попадет в глаз наблюдателя и сформирует в нем изображение сцены. 
<P>Понятно, что вычисления, необходимые для трассировки всех лучей для всех 
источников и поверхностей слишком объемисты. Причем существенный вклад в 
полученное изображение внесет лишь небольшая часть оттрассированных лучей. 
<P>Для избавления от излишних вычислений используется обратная трассировка, в 
которой вычисляются интенсивности только лучей, попавших в глаз наблюдателя. В 
простейшей реализации обратной трассировки отслеживаются лучи, проходящие из 
глаза наблюдателя через каждый пиксел экрана в сцену. На каждой поверхности 
сцены, на которую попадает луч, в общем случае формируются отраженный и 
преломленный лучи. Каждый из таких лучей отслеживается, чтобы определить 
пересекаемые поверхности. В результате для каждого пиксела строится дерево 
пересечений. Ветви такого дерева представляют распространение луча в сцене, а 
узлы - пересечения с поверхностями в сцене. Окончательная закраска определяется 
прохождением по дереву и вычислением вклада каждой пересеченной поверхности в 
соответствии с используемыми моделями отражения. При этом различают и обычно 
по-разному рассчитывают первичную освещенность, непосредственно получаемую от 
источников света, и вторичную освещенность, получаемую от других объектов. 
<P>
<CENTER>
<H3><A name=tth_sEc0.11.7>0.11.7</A>&nbsp;&nbsp;Излучательность</H3></CENTER>
<P>Сцену можно представить как набор поверхностей, обменивающихся лучистой 
энергией. Большинство реальных поверхностей является диффузными отражателями, 
когда падающий луч отражается или рассеивается во всех направлениях полусферы, 
находящейся над отражающей поверхностью. Особый здесь случай - отражение 
Ламберта (идеальная диффузия). Метод излучательности описывает баланс 
энергетического равновесия в замкнутой системе. Предполагается что поверхности 
идеально диффузны, т.е. после отражения падающий луч пропадает. Излучательность 
отдельной поверхности включает самоизлучение и отраженный или пропущенный свет. 
<P>
<P><A name=tth_fIg0.22></A><A name=r12_01>
<CENTER><BR><IMG alt="Рисунок 86" 
src="Учебное пособие Основные алгоритмы компьютерной графики_files/kg0286.gif">
<P></CENTER>
<CENTER>Рис. 0.4.22: Излучательность</CENTER></A>
<P>
<P>E<SUB>i</SUB> = [Энергия/ ед.площади ·ед.времени] - эмиссия, 
<P>P<SUB>i</SUB> - безразмерный коэффициент отражения, 
<P>B<SUB>i</SUB> - полный уровень света, исходящего от поверхности 
<P>F<SUB>ij</SUB> - форм-фактор - часть энергии, исходящая от одной поверхности 
и достигающая другой 
<P>Если поверхности сцены разделены на n элементов, имеющих постоянную 
излучательность, то взаимодействие потоков света в сцене описывается системой 
уравнений: 
<P>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap></TD>
          <TD align=left><FONT face=symbol>щ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ы 
            </FONT></TD>
          <TD align=middle></TD>
          <TD noWrap>
            <TABLE align=left border=0>
              <TBODY>
              <TR>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>1-P<SUB>1</SUB>·F<SUB>11</SUB> 
                      </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>-P<SUB>1</SUB>·F<SUB>12</SUB> 
                    </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap><FONT 
                    face=symbol>ј</FONT></TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle 
                    noWrap>-P<SUB>1</SUB>·F<SUB>1n</SUB></TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=middle colSpan=0 noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>1-P<SUB>2</SUB>·F<SUB>21</SUB> 
                      </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>-P<SUB>2</SUB>·F<SUB>22</SUB> 
                    </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap><FONT 
                    face=symbol>ј</FONT></TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle 
                    noWrap>-P<SUB>2</SUB>·F<SUB>2n</SUB></TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=middle colSpan=0 noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap></TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap><FONT 
                    face=symbol>ј</FONT></TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap></TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=middle colSpan=0 noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>1-P<SUB>n</SUB>·F<SUB>n1</SUB> 
                      </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap>-P<SUB>n</SUB>·F<SUB>n2</SUB> 
                    </TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap><FONT 
                    face=symbol>ј</FONT></TD></TR></TBODY></TABLE></TD>
                <TD align=middle noWrap>
                  <TABLE>
                    <TBODY>
                    <TR>
                      <TD align=middle colSpan=0 
                        noWrap>-P<SUB>n</SUB>·F<SUB>nn</SUB></TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></TD>
          <TD noWrap></TD>
          <TD align=left><FONT face=symbol>щ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ы 
            </FONT></TD>
          <TD align=middle></TD>
          <TD align=left><FONT face=symbol>щ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ы 
            </FONT></TD>
          <TD align=middle></TD>
          <TD noWrap>
            <TABLE align=left border=0>
              <TBODY>
              <TR>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle 
                noWrap>B<SUB>1</SUB></TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=middle colSpan=0 noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle 
                noWrap>B<SUB>2</SUB></TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=middle colSpan=0 noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap><FONT 
                    face=symbol>ј</FONT></TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=middle colSpan=0 noWrap>
                  <TABLE>
                    <TBODY>
                    <TR>
                      <TD align=middle colSpan=0 
                    noWrap>B<SUB>n</SUB></TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></TD>
          <TD noWrap></TD>
          <TD align=left><FONT face=symbol>щ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ы 
            </FONT></TD>
          <TD align=middle>= </TD>
          <TD align=left><FONT face=symbol>щ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ы 
            </FONT></TD>
          <TD align=middle></TD>
          <TD noWrap>
            <TABLE align=left border=0>
              <TBODY>
              <TR>
                <TD align=middle noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle 
                noWrap>E<SUB>1</SUB></TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=middle colSpan=0 noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle 
                noWrap>E<SUB>2</SUB></TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=middle colSpan=0 noWrap>
                  <TABLE border=0>
                    <TBODY>
                    <TR>
                      <TD align=middle noWrap><FONT 
                    face=symbol>ј</FONT></TD></TR></TBODY></TABLE></TD></TR>
              <TR>
                <TD align=middle colSpan=0 noWrap>
                  <TABLE>
                    <TBODY>
                    <TR>
                      <TD align=middle colSpan=0 
                    noWrap>E<SUB>n</SUB></TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></TD>
          <TD noWrap></TD>
          <TD align=left><FONT face=symbol>щ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ъ<BR>ы 
            </FONT></TD>
          <TD 
align=middle>.</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>Так 
как форм-фактор определяет часть энергии, исходящей от одной поверхности и 
достигающей другой, то сумма всех форм-факторов элемента меньше 1. 
<P>Эта система уравнений решается итерационным методом с выбором в качестве 
начального приближения для излучательности эмиссии поверхности: 
<P>B<SUB>i</SUB><SUP>0</SUP> = E<SUB>i</SUB>, 
<P>и последующих приближений вида: 
<P>B<SUB>i</SUB><SUP>k+1</SUP> = E<SUB>i</SUB> + P<SUB>i</SUB> <FONT 
face=symbol>е</FONT><SUB>j = 1</SUB><SUP>n</SUP> F<SUB>ij</SUB> 
B<SUB>j</SUB><SUP>k</SUP>. 
<P>После определения излучательности каждого фрагмента производится вычисление 
излучательностей вершин таким образом, чтобы при билинейной интерполяции в 
пределах каждого фрагмента была обеспечена непрерывность закраски на границах. 
<P>Для этого в каждом многоугольнике значения излучательности для внутренних 
относительно многоугольника вершин фрагментов вычисляются как среднее значение 
излучательностей фрагментов, окружающих вершину (рис.&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#r12_02">0.7.54</A>). Определения 
излучательности внешних вершин выполняют экстраполяцией средних значений в 
смежных внутренних вершинах (см. рис.&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#r12_02">0.7.54</A>). 
<P><A name=tth_fIg0.23></A>
<P><A name=r12_02>
<CENTER><BR><IMG alt="Рисунок 87" 
src="Учебное пособие Основные алгоритмы компьютерной графики_files/kg0287.gif">
<P></CENTER>
<CENTER>Рис. 0.4.23: Вычисление излучательности вершин</CENTER></A>
<P>
<P>Формирование результирующего изображения выполняется после выбора требуемой 
точки наблюдения и проецирования сцены на картинную плоскость. Видно, что этот 
метод не зависит от точки наблюдения. При выводе определяется какой фрагмент 
отображается в каждом пикселе экрана. При этом используются z-буфер и кадровый 
буфер. Пересечение линии, соединяющей глаз и пиксел с плоскостью фрагмента, 
позволяет найди координату точки, отображаемую в текущий пиксел. Координата 
пересечения (x, y, z) преобразуется в координаты (u, v) на фрагменте. После 
этого значения излучательностей вершин используются при билинейной интерполяции 
трех значений излучательностей в пределах каждого фрагмента (рис.&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#r12_03">0.7.55</A>). 
<P><A name=tth_fIg0.24></A>
<P><A name=r12_03>
<CENTER><BR><IMG alt="Рисунок 88" 
src="Учебное пособие Основные алгоритмы компьютерной графики_files/kg0288.gif">
<P></CENTER>
<CENTER>Рис. 0.4.24: Билинейная интерполяция излучательностей по значениям в 
вершинах</CENTER></A>
<P>
<P>Наиболее трудоемкая часть метода излучательности - вычисление форм факторов. 
<P>Для двух неперекрытых элементарных площадок i и j форм-фактор определяет 
часть световой энергии, исходящей из одной площадки на другую, и имеет вид: 
<P>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>F<SUB>dAi,dAj</SUB> = </TD>
          <TD align=middle noWrap>cos(<FONT face=symbol>f</FONT><SUB>i</SUB>) 
            ·cos(<FONT face=symbol>f</FONT><SUB>j</SUB>)
            <HR noShade>
             <FONT face=symbol>p</FONT>·r<SUP>2</SUP><BR></TD>
          <TD align=middle 
noWrap></TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>
<P>где r - расстояние между элементами dA<SUB>i</SUB> и dA<SUB>j</SUB>, <FONT 
face=symbol>f</FONT><SUB>i</SUB> и <FONT face=symbol>f</FONT><SUB>j</SUB> - углы 
между нормалями к элементам и соединяющим их отрезком (рис.&nbsp;<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#r12_04">0.7.56</A>). 
<P><A name=tth_fIg0.25></A>
<P><A name=r12_04>
<CENTER><BR><IMG alt="Рисунок 89" 
src="Учебное пособие Основные алгоритмы компьютерной графики_files/kg0289.gif">
<P></CENTER>
<CENTER>Рис. 0.4.25: Форм-фактор для двух элементарных площадок</CENTER></A>
<P>
<P>Интегрируя по площади dA<SUB>j</SUB> получаем форм-фактор конечного элемента 
площади A<SUB>j</SUB> относительно элементарной площадки dA<SUB>i</SUB>: 
<P>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>F<SUB>dAi,Aj</SUB> = </TD>
          <TD align=left><FONT face=symbol>у<BR>х </FONT></TD>
          <TD align=middle><FONT size=-1></FONT><BR><BR><FONT 
            size=-1>Aj</FONT>&nbsp;<BR></TD>
          <TD noWrap></TD>
          <TD align=middle noWrap>cos(<FONT face=symbol>f</FONT><SUB>i</SUB>) 
            ·cos(<FONT face=symbol>f</FONT><SUB>j</SUB>)
            <HR noShade>
             <FONT face=symbol>p</FONT>·r<SUP>2</SUP><BR></TD>
          <TD align=middle 
noWrap>·dAj</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>
<P>Выражение для форм-фактора между двух конечных неперекрытых площадок 
определяется как средняя площадь: 
<P>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>F<SUB>ij</SUB> = F<SUB>Ai,Aj</SUB> = </TD>
          <TD align=middle noWrap>1
            <HR noShade>
             A<SUB>i</SUB><BR></TD>
          <TD align=middle noWrap></TD>
          <TD align=left><FONT face=symbol>у<BR>х </FONT></TD>
          <TD align=middle><FONT size=-1></FONT><BR><BR><FONT 
            size=-1>Ai</FONT>&nbsp;<BR></TD>
          <TD noWrap></TD>
          <TD align=left><FONT face=symbol>у<BR>х </FONT></TD>
          <TD align=middle><FONT size=-1></FONT><BR><BR><FONT 
            size=-1>Aj</FONT>&nbsp;<BR></TD>
          <TD noWrap></TD>
          <TD align=middle noWrap>cos(<FONT face=symbol>f</FONT><SUB>i</SUB>) 
            ·cos(<FONT face=symbol>f</FONT><SUB>j</SUB>)
            <HR noShade>
             <FONT face=symbol>p</FONT>·r<SUP>2</SUP><BR></TD>
          <TD align=middle noWrap>·dA<SUB>j</SUB> 
      ·dA<SUB>i</SUB></TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>
<P>Взаимное перекрытие может быть учтено с помощью функции H<SUB>ij</SUB>, 
принимающей значение от 0 до 1 в зависимости от степени перекрытия площадки 
A<SUB>j</SUB> площадкой A<SUB>i</SUB>: 
<P>
<CENTER>
<TABLE align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <TABLE align=left>
        <TBODY>
        <TR>
          <TD align=middle noWrap>F<SUB>ij</SUB> = F<SUB>Ai,Aj</SUB> = </TD>
          <TD align=middle noWrap>1
            <HR noShade>
             A<SUB>i</SUB><BR></TD>
          <TD align=middle noWrap></TD>
          <TD align=left><FONT face=symbol>у<BR>х </FONT></TD>
          <TD align=middle><FONT size=-1></FONT><BR><BR><FONT 
            size=-1>Ai</FONT>&nbsp;<BR></TD>
          <TD noWrap></TD>
          <TD align=left><FONT face=symbol>у<BR>х </FONT></TD>
          <TD align=middle><FONT size=-1></FONT><BR><BR><FONT 
            size=-1>Aj</FONT>&nbsp;<BR></TD>
          <TD noWrap></TD>
          <TD align=middle noWrap>cos(<FONT face=symbol>f</FONT><SUB>i</SUB>) 
            ·cos(<FONT face=symbol>f</FONT><SUB>j</SUB>)
            <HR noShade>
             <FONT face=symbol>p</FONT>·r<SUP>2</SUP><BR></TD>
          <TD align=middle noWrap>· H<SUB>ij</SUB> ·dA<SUB>j</SUB> 
            ·dA<SUB>i</SUB></TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></CENTER>
<P>Вычисление этого интеграла, как правило, затруднено. Для его вычисления 
предложен т.н. алгоритм полукуба. Основная идея которого состоит в том, что если 
два любых фрагмента в пространстве после проецирования на полусферу заняли на 
ней одну и ту же площадь и место, то их формфакторы будут одинаковы. Это 
утверждение справедливо и при проецировании на любую другую окружающую 
поверхность, в том числе куб. 
<P>Куб строится таким образом, чтобы центр фрагмента, принимающего отраженные 
световые потоки, совпал с центром куба, а нормаль к фрагменту в этой точке 
примем за положительное направление оси Z. В этом случае полусфера заменяется 
верхней частью куба (полукубом). Разобьем плоскости полукуба на квадратные 
пикселы. Спроектируем все пространство на пять плоскостей полукуба при этом 
производится отсечение по пирамиде видимости с центром в центре куба. Если два 
фрагмента сцены проецируются на один и тот писел куба, 
<P>
<H3><A name=tth_bib>Список литературы</A></H3>
<DL compact>
  <DT>[<A href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#CITEmbib1" 
  name=mbib1>1</A>]
  <DD>Encarnacao&nbsp;J. Einfurung in die Graphische Datenverarbeiterung// 
  Eurographics '89. Tutorial Notes 1. Hamburg, FRG, September 4-8, 1989. 122 s. 
  <P></P>
  <DT>[<A href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#CITEmbib2" 
  name=mbib2>2</A>]
  <DD>Ньюмен&nbsp;У., Спрулл&nbsp;Р. Основы интерактивной машинной графики. Пер. 
  с англ. М.: Мир, 1976. 
  <P></P>
  <DT>[<A href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#CITEmbib3" 
  name=mbib3>3</A>]
  <DD>Роджерс&nbsp;Д. Алгоритмические основы машинной графики. Пер. с англ. М.: 
  Мир, 1989. 512&nbsp;c. 
  <P></P>
  <DT>[<A href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#CITEmbib4" 
  name=mbib4>4</A>]
  <DD>Фоли&nbsp;Дж., вэн Дэм&nbsp;А. Основы интерактивной машинной графики: В 
  2-х книгах. Пер. с англ. М.: Мир, 1985. 
  <P></P>
  <DT>[<A href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#CITEmbib5" 
  name=mbib5>5</A>]
  <DD>Антонофф&nbsp;М., Линдерхолм&nbsp;О. Лазерные принтеры// Компьютер Пресс, 
  сборник N 1, 1989, с. 3-8. 
  <P></P>
  <DT>[<A href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#CITEmbib6" 
  name=mbib6>6</A>]
  <DD>Введение в Автокад 11R: Метод.пособие/ НГТУ; Составители: Р.М.Сидорук, 
  О.А.Соснина, И.М.Моисеенко. Н.Новгород, 1993. 181 с. 
  <P></P>
  <DT>[<A href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#CITEmbib7" 
  name=mbib7>7</A>]
  <DD>Кречко Ю.А., Полищук В.В. Автокад. Курс практической работы. М.: 
  "Диалог-МИФИ", 1994. 256 с. 
  <P></P>
  <DT>[<A href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#CITEmbib8" 
  name=mbib8>8</A>]
  <DD>Вельтмандер П.В., Голубев В.М. Обучение автоматизации проектирования 
  машиностроительного направления// Информатизация образования: Межвуз. сб. 
  науч. тр./ под ред. В.Н.Врагова. Новосибирск: НГУ, 1994. С. 123-131. 
  <P></P>
  <DT>[<A href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#CITEmbib9" 
  name=mbib9>9</A>]
  <DD>Винцюк&nbsp;Т.К. Системы речевого диалога// Материалы пятой школы-семинара 
  "Интерактивные системы" (Кутаиси, 2-10 апреля 1983 г.). Тбилиси: Мецниереба, 
  1983, с. 16-22. 
  <P></P>
  <DT>[<A href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#CITEmbib10" 
  name=mbib10>10</A>]
  <DD>Печатающие устройства персональных ЭВМ: Справочник// Под редакцией проф. 
  И.М.Витенберга. М.: Радио и связь, 1992. 
  <P></P>
  <DT>[<A href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#CITEmbib11" 
  name=mbib11>11</A>]
  <DD>Гилой&nbsp;В. Интерактивная машинная графика. Пер. с англ. М.: Мир, 1981. 
  <P></P>
  <DT>[<A href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#CITEmbib12" 
  name=mbib12>12</A>]
  <DD>Грис&nbsp;Д. Конструирование компиляторов для цифровых вычислительных 
  машин. Пер. с англ. М.: Мир, 1975. 544 с. 
  <P></P>
  <DT>[<A href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#CITEmbib13" 
  name=mbib13>13</A>]
  <DD>Лисицин&nbsp;Б.Л. Низковольтные индикаторы: Справочник. М.: Радио и связь, 
  1985. 
  <P></P>
  <DT>[<A href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#CITEmbib14" 
  name=mbib14>14</A>]
  <DD>Справочник по машинной графике в проектировании/ В.Е.Михайленко, 
  В.А.Анпилогова, Л.А.Кириевский и др.: Под ред. В.Е.Михайленко. А.А.Лященко. 
  Киев: Будiвельник, 1984 . 184 с. 
  <P></P>
  <DT>[<A href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#CITEmbib15" 
  name=mbib15>15</A>]
  <DD>Мячев&nbsp;А.А., Степанов&nbsp;В.Н. Персональные ЭВМ и микроЭВМ. Основы 
  организации: Справочник/ Под ред. А.А.Мячева. М.: Радио и связь, 1991. 
  <P></P>
  <DT>[<A href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#CITEmbib16" 
  name=mbib16>16</A>]
  <DD>Новаковский&nbsp;С.В. Цвет в цветном телевидении. М.: Радио и связь, 1988. 
  288 с. 
  <P></P>
  <DT>[<A href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#CITEmbib17" 
  name=mbib17>17</A>]
  <DD>Павлидис&nbsp;Т. Алгоритмы машинной графики и обработки изображений. Пер. 
  с англ. М.: Радио и связь, 1986. 
  <P></P>
  <DT>[<A href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#CITEmbib18" 
  name=mbib18>18</A>]
  <DD>Прэтт&nbsp;У. Цифровая обработка изображений: Пер. с англ. в 2-х книгах. 
  М.: Мир, 1982. 
  <P></P>
  <DT>[<A href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#CITEmbib19" 
  name=mbib19>19</A>]
  <DD>Роджерс&nbsp;Д., Адамс&nbsp;Дж. Математические основы машинной графики. 
  Пер. с англ. М.: Машиностроение, 1980. 
  <P></P>
  <DT>[<A href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#CITEmbib20" 
  name=mbib20>20</A>]
  <DD>Сизых&nbsp;В.Г. Растровые дисплеи ряда Гамма. Новосибирск, 1985. 26 с. 
  (Препринт ВЦ СО АН СССР; N 607). 
  <P></P>
  <DT>[<A href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#CITEmbib21" 
  name=mbib21>21</A>]
  <DD>Ткаченко&nbsp;А.П. Цветное телевидение. Минск: Беларусь, 1981. 253 с. 
  <P></P>
  <DT>[<A href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#CITEmbib22" 
  name=mbib22>22</A>]
  <DD>Фролов&nbsp;А.В., Фролов&nbsp;Г.В. Программирование видеоадаптеров CGA, 
  EGA, VGA. M.: Диалог-МИФИ, 1992. 
  <P></P>
  <DT>[<A href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#CITEmbib23" 
  name=mbib23>23</A>]
  <DD>Фостер&nbsp;Дж. Обработка списков. Пер. с англ. М.: Мир, 1974. 71 с. 
  <P></P>
  <DT>[<A href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#CITEmbib24" 
  name=mbib24>24</A>]
  <DD>Холл&nbsp;П. Вычислительные структуры. Ведение в нечисленное 
  программирование. Пер. с англ. М.: Мир, 1978. 214 с. 
  <P></P>
  <DT>[<A href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#CITEmbib25" 
  name=mbib25>25</A>]
  <DD>Bresenham&nbsp;J.E. Algorithm for computer control of a digital plotter// 
  IBM Systems Journal, vol. 4, No. 1, pp. 25-30, 1965. 
  <P></P>
  <DT>[<A href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#CITEmbib26" 
  name=mbib26>26</A>]
  <DD>Bresenham&nbsp;J., A Linear Algoritm for Incremental Didgital Display of 
  Circular Arcs, CACM, vol. 20, pp. 100-106, 1977. 
  <P></P>
  <DT>[<A href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#CITEmbib27" 
  name=mbib27>27</A>]
  <DD>Bui-Tuong&nbsp;Phong. Illumination for Computer-Generated Pictures. 
  Communication of the ASM, 18(6), June 1975, pp. 311-317. 
  <P></P>
  <DT>[<A href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#CITEmbib28" 
  name=mbib28>28</A>]
  <DD>Clark,&nbsp;J.H. A VLSI geometry Processor for Graphics// IEEE Computer, 
  12(7). 
  <P></P>
  <DT>[<A href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#CITEmbib29" 
  name=mbib29>29</A>]
  <DD>Cyrus&nbsp;M., Beck&nbsp;J. Generalized two- and threedimensional 
  clipping// Computer and Graphics, Vol. 3, pp. 23-28, 1978. 
  <P></P>
  <DT>[<A href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#CITEmbib30" 
  name=mbib30>30</A>]
  <DD>Hans&nbsp;Joseph, Max&nbsp;Mehl. Computer Graphics Hardware: Introduction 
  and State of the Art// Eurographics '91. Tutorial Note 9. Viena, 2.-6. 
  September 1991. Austria, Viena. 29 p. 
  <P></P>
  <DT>[<A href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#CITEmbib31" 
  name=mbib31>31</A>]
  <DD>Fontenier&nbsp;Guy, Pascal&nbsp;Gros&nbsp;Pascal. Architectures of Graphic 
  Processors for Interactive 2D Graphics// Computer Graphics Forum 7 (1988) 
  78-89. 
  <P></P>
  <DT>[<A href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#CITEmbib32" 
  name=mbib32>32</A>]
  <DD>You-Dong&nbsp;Liang and Brian&nbsp;A.&nbsp;Barsky. A new concept and 
  method for line clipping// ACM Transaction on Graphics, Vol. 3, No. 1, January 
  1984, pp. 1-22. 
  <P></P>
  <DT>[<A href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#CITEmbib33" 
  name=mbib33>33</A>]
  <DD>Tina&nbsp;M.&nbsp;Nicholl, D.T.Lee&nbsp;and Robin&nbsp;A.&nbsp;Nicholl. An 
  efficient new algoritm for 2-D line clipping: its development and analysis// 
  Computer Graphics, V. 21, N. 4, July 1987, pp. 253-262. 
  <P></P>
  <DT>[<A href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#CITEmbib34" 
  name=mbib34>34</A>]
  <DD>R.Pinkman, M.Novak, K.Guttag. Video-RAM exels at fast graphics// 
  Electronics Design, pp. 161-171 (August 18 1983). 
  <P></P>
  <DT>[<A href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#CITEmbib35" 
  name=mbib35>35</A>]
  <DD>H.-P.&nbsp;Seidel. PC Graphics Hardware // Eurographics '88. 
  Tutorial/Cours 8. Nice, 12.-16. September 1988. France, Nice. 44 p. 
  <P></P>
  <DT>[<A href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#CITEmbib36" 
  name=mbib36>36</A>]
  <DD>Smit&nbsp;A.R., Tint&nbsp;Fill, SIGGRAPH'79 Proceedings // Computer 
  Graphics, Vol.13(2), Aug. 1979, pp. 276-283. 
  <P></P>
  <DT>[<A href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#CITEmbib37" 
  name=mbib37>37</A>]
  <DD>Mark&nbsp;S.&nbsp;Sobkow, Paul&nbsp;Pospisil and Yee-Hong&nbsp;Yang. A 
  Fast Two-Dimensional Line Clipping Algoritm via Line Encoding//Computer &amp; 
  Graphics, Vol. 11, No. 4, pp. 459-467, 1987. 
  <P></P>
  <DT>[<A href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#CITEmbib38" 
  name=mbib38>38</A>]
  <DD>Robert&nbsp;F.&nbsp;Sproull and Ivan&nbsp;E.&nbsp;Sutherland. A Clipping 
  Divider // AFIP Fall Joint Computer Conference. San Francisco, 1968. 
  <P></P>
  <DT>[<A href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#CITEmbib39" 
  name=mbib39>39</A>]
  <DD>Stralunsfreier Flacbildschirm. MC, Die MikrocomputerZeitschrift. N 8, 
  1989, s. 66. 
  <P></P>
  <DT>[<A href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#CITEmbib40" 
  name=mbib40>40</A>]
  <DD>Sutherland&nbsp;I.E., Hodgman&nbsp;G.W. Reentrant Polygon 
  Clipping//Communications of the ACM, 17(1), pp. 32-42. 
  <P></P>
  <DT>[<A href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#CITEmbib41" 
  name=mbib41>41</A>]
  <DD>Weiler&nbsp;K., Atherton&nbsp;P,. Hidden Surface Removal Using Polygon 
  Area Sorting// SIGGGRAPH'77 Proceedings, Computer Graphics, Vol. 11, N. 2, pp. 
  214-222, 1977. 
  <P></P>
  <DT>[<A href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#CITEmbib42" 
  name=mbib42>42</A>]
  <DD>Weiler&nbsp;K., Polygon Comparision Using a Graph Representation// 
  SIGGGRAPH'80 Proceedings, Computer Graphics, Vol. 14, pp. 10-18, 1980. 
  <P></P></DD></DL>
<CENTER>
<H3><A name=tth_sEc0.12>0.12</A>&nbsp;&nbsp;Приложение 1. Процедуры 
преобразований</H3></CENTER>
<P>
<CENTER>
<H3><A name=tth_sEc0.13>0.13</A>&nbsp;&nbsp;Приложение 2. Процедуры генерации 
отрезков</H3></CENTER>
<P>Здесь приведены тексты соответствующих процедур с пояснениями и тестовая 
программа. Процедуры позволяют генерировать вектора в любом квадранте с 
использованием алгоритмов несимметричного цифрового дифференциального 
анализатора и Брезенхема, а также построения ребра, ограничивающего заполненный 
многоугольник, модифицированным алгоритмом Брезенхема, уменьшающим лестничный 
эффект. 
<P>Предусмотрена возможность задания атрибутов формируемых отрезков - номер 
цвета и размер пиксела, используемого при формировании отрезков. 
<P>В тестовой программе предусмотрено, что при наличии SVGA-адаптера он может 
использоваться как в обычном режиме, так и в режиме до 1024x768 точек с 256 
цветами. 
<P><PRE>/*------------------------------------------------- V_VECTOR.C
 * Подпрограммы генерации векторов
 */

#include &lt;graphics.h&gt;
#include &lt;stdio.h&gt;

#define PutMay putpixel

static int Pix_X= 3,    /* Размер пиксела по X  */
           Pix_Y= 3,    /* Размер пиксела по Y  */
           Pix_C= 64,   /* Нач. индекс цвета пиксела */
           Pix_V= 64;   /* Количество оттенков  */

/*--------------------------------------------------- PutPixLn
 * Подпрограмма заносит "кpупный" пиксел в позицию X,Y
 * Точка (0, 0) - левый верхний угол экрана.
 * Размеры пиксела задается фактическими паpаметpами x и y.
 * Hомер оттенка пиксела задается фактическим паpаметpом c.
 */

void PutPixLn (int x, int y, int c)
{  int  ii, jj, kk;
   x *= Pix_X;  y *= Pix_Y;
   ii= Pix_Y;
   while (--ii &gt;= 0) {
      jj= Pix_X;  kk= x;
      while (--jj &gt;= 0) PutMay (kk++, y, c);
      y++;
   }
}  /* PutPixLn */


/*--------------------------------------------------- V_setlin
 * Устанавливает атрибуты построения линий:
 * размер элементарного пиксела, индекс цвета, кол-во оттенков
 * Если размер &lt;= 0, то он не меняется
 * Если атрибут цвета &lt; 0, то он не меняется
 */
void V_setlin (sizex, sizey, colorindex, colorvalue)
int  sizex, sizey, colorindex;
{
   if (sizex &gt; 0) Pix_X= sizex;
   if (sizey &gt; 0) Pix_Y= sizey;
   if (colorindex &gt;= 0) Pix_C= colorindex;
   if (colorvalue &gt;= 0) Pix_V= colorvalue;
}  /* V_setlin */
</PRE>
<P>
<CENTER>
<H3><A name=tth_sEc0.13.1>0.13.1</A>&nbsp;&nbsp;V_DDA - несимметричный 
ЦДА</H3></CENTER>
<P><PRE>/*-----------------------------------------------------  V_DDA
 * void V_DDA (int xn, int yn, int xk, int yk)
 *
 * Подпрограмма построения вектора из точки (xn,yn)
 * в точку (xk, yk) в первом квадранте методом
 * несимметричного цифрового дифференциального анализатора
 * с использованием только целочисленной арифметики.
 *
 * Обобщение на другие квадранты труда не составляет.
 *
 * Построение ведется от точки с меньшими  координатами
 * к точке с большими координатами с единичным шагом по
 * координате с большим приращением.
 *
 * Отдельно выделяется случай вектора с dx == dy
 *
 * Всего надо выдать пикселы в dx= xk - xn + 1 позиции
 * по оси X и в dy= yk - yn + 1 позиции по оси Y.
 *
 * Для определенности рассмотрим случай dx &gt; dy
 *
 * При приращении X-координаты на 1 Y-координата должна
 * увеличиться на величину меньшую единицы и равную dy/dx.
 *
 * После того как Y-приращение станет больше или равно 1.0,
 * то Y-координату пиксела надо увеличить на 1, а из
 * накопленного приращения вычесть 1.0 и продолжить построения
 * Т.е. приращение Y на 1 выполняется при условии:
 * dy/dx + dy/dx + ... + dy/dx &gt;= 1.0
 * Т.к. вычисления в целочисленной арифметике быстрее, то
 * умножим на dx обе части и получим эквивалентное условие:
 * dy + dy + ... + dy &gt;= dx
 *
 * Эта схема и реализована в подпрограмме.
 *
 * При реализации на ассемблере можно избавиться от
 * большинства операторов внутри цикла while.
 * Для этого перед циклом надо домножить dy на величину,
 * равную 65536/dx.
 * Тогда надо увеличивать Y на 1 при признаке переноса
 * после вычисления s, т.е. операторы
 *       s= s + dy;
 *       if (s &gt;= dx) { s= s - dx;  yn= yn + 1; }
 * заменяются командами ADD и ADC
 *
 */

void V_DDA (xn, yn, xk, yk)
int  xn, yn, xk, yk;
{  int  dx, dy, s;

/* Упорядочивание координат и вычисление приращений */
   if (xn &gt; xk) {
      s= xn;  xn= xk;  xk= s;
      s= yn;  yn= yk;  yk= s;
   }
   dx= xk - xn;  dy= yk - yn;

/* Занесение начальной точки вектора */
   PutPixLn (xn, yn, Pix_C);

   if (dx==0 &amp;&amp; dy==0) return;

/* Вычисление количества позиций по X и Y */
   dx= dx + 1;  dy= dy + 1;

/* Собственно генерация вектора */
   if (dy == dx) {                 /* Наклон == 45 градусов */
      while (xn &lt; xk) {
         xn= xn + 1;
         PutPixLn (xn, xn, Pix_C);
      }
   } else if (dx &gt; dy) {           /* Наклон &lt;  45 градусов */
      s= 0;
      while (xn &lt; xk) {
         xn= xn + 1;
         s= s + dy;
         if (s &gt;= dx) { s= s - dx;  yn= yn + 1; }
         PutPixLn (xn, yn, Pix_C);
      }
   } else {                        /* Наклон &gt;  45 градусов */
      s= 0;
      while (yn &lt; yk) {
         yn= yn + 1;
         s= s + dx;
         if (s &gt;= dy) { s= s - dy;  xn= xn + 1; }
         PutPixLn (xn, yn, Pix_C);
      }
   }
}  /* V_DDA */
</PRE>
<P>
<CENTER>
<H3><A name=tth_sEc0.13.2>0.13.2</A>&nbsp;&nbsp;V_Bre - алгоритм 
Брезенхема</H3></CENTER>
<P><PRE>/*-----------------------------------------------------  V_Bre
 * void V_Bre (int xn, int yn, int xk, int yk)
 *
 * Подпрограмма иллюстрирующая построение вектора из точки
 * (xn,yn) в точку (xk, yk) методом Брезенхема.
 *
 * Построение ведется от точки с меньшими  координатами
 * к точке с большими координатами с единичным шагом по
 * координате с большим приращением.
 *
 * В общем случае исходный вектор проходит не через вершины
 * растровой сетки, а пересекает ее стороны.
 * Пусть приращение по X больше приращения по Y и оба они &gt; 0.
 * Для очередного значения X нужно выбрать одну двух ближайших
 * координат сетки по Y.
 * Для этого проверяется как проходит  исходный  вектор - выше
 * или ниже середины расстояния между ближайшими значениями Y.
 * Если выше середины,  то Y-координату  надо  увеличить на 1,
 * иначе оставить прежней.
 * Для этой проверки анализируется знак переменной s,
 * соответствующей разности между истинным положением и
 * серединой расстояния между ближайшими Y-узлами сетки.
 */

void V_Bre (xn, yn, xk, yk)
int  xn, yn, xk, yk;
{  int  dx, dy, s, sx, sy, kl, swap, incr1, incr2;

/* Вычисление приращений и шагов */
   sx= 0;
   if ((dx= xk-xn) &lt; 0) {dx= -dx; --sx;} else if (dx&gt;0) ++sx;
   sy= 0;
   if ((dy= yk-yn) &lt; 0) {dy= -dy; --sy;} else if (dy&gt;0) ++sy;
/* Учет наклона */
   swap= 0;
   if ((kl= dx) &lt; (s= dy)) {
      dx= s;  dy= kl;  kl= s; ++swap;
   }
   s= (incr1= 2*dy)-dx; /* incr1 - констан. перевычисления */
                        /* разности если текущее s &lt; 0  и  */
                        /* s - начальное значение разности */
   incr2= 2*dx;         /* Константа для перевычисления    */
                        /* разности если текущее s &gt;= 0    */
   PutPixLn (xn,yn,Pix_C); /* Первый  пиксел вектора       */
   while (--kl &gt;= 0) {
      if (s &gt;= 0) {
         if (swap) xn+= sx; else yn+= sy;
         s-= incr2;
      }
      if (swap) yn+= sy; else xn+= sx;
      s+=  incr1;
      PutPixLn (xn,yn,Pix_C); /* Текущая  точка  вектора   */
   }
}  /* V_Bre */
</PRE>
<P>
<CENTER>
<H3><A name=tth_sEc0.13.3>0.13.3</A>&nbsp;&nbsp;V_BreM - модифицированный 
алгоритм Брезенхема</H3></CENTER>
<P><PRE>/*----------------------------------------------------- V_BreM
 * void V_BreM (int xn, int yn, int xk, int yk)
 *
 * Подпрограмма иллюстрирующая построение ребра залитого
 * многоугольника из точки (xn,yn) в точку (xk,yk)
 * модифициpованным методом Брезенхема.
 *
 * Строки многоугольника от занесенного пиксела границы до xk
 * заполняются оттенком с максимальным номером.
 */

void V_BreM (xn, yn, xk, yk)
int  xn, yn, xk, yk;
{  int  dx, dy, sx, sy, kl, swap;
   long incr1, incr2;
   long s;              /* Текущее значение ошибки  */
   long s_max;          /* Макс значение ошибки     */
   int  color_tek;      /* Текущий номеp оттенка    */
   int  xt;

/* Вычисление приращений и шагов */
   sx= 0;
   if ((dx= xk-xn) &lt; 0) {dx= -dx; --sx;} else if (dx&gt;0) ++sx;
   sy= 0;
   if ((dy= yk-yn) &lt; 0) {dy= -dy; --sy;} else if (dy&gt;0) ++sy;
/* Учет наклона */
   swap= 0;
   if ((kl= dx) &lt; (s= dy)) {dx= s;  dy= kl;  kl= s; ++swap;}
   s= (long)dx*(long)Pix_V; /* Hачальное значение ошибки    */
   incr1= 2l*(long)dy       /* Конст. перевычисления ошибки */
            *(long)Pix_V;   /* если текущее s &lt; s_max       */
   incr2= 2l*s;             /* Конст. перевычисления ошибки */
                            /* если текущее s &gt;= s_max      */
   s_max= incr2 - incr1;    /* Максимальное значение ошибки */
   color_tek= Pix_V;        /* Яpкость стаpтового пиксела   */
   if (dx)color_tek=(int)((((long)Pix_V*(long)dy)/(long)dx)/2l);
   PutPixLn (xn, yn, Pix_C+color_tek);      /* 1-й пиксел */
   while (--kl &gt;= 0) {
      if (s &gt;= s_max) {
         if (swap) xn+= sx; else yn+= sy;
         s-= incr2;
      }
      if (swap) yn+= sy; else xn+= sx;
      s+=  incr1;
      color_tek= Pix_V;
      if (dx) color_tek= s / dx /2;
      PutPixLn (xn,yn,Pix_C+color_tek);     /* Тек.пиксел */
/* Однотонная закраска строки многоугольника макс цветом  */
      xt= xn;
      while (++xt &lt;= xk) PutPixLn (xt,yn,Pix_C+Pix_V-1);
   }
}  /* V_BreM */
</PRE>
<P>
<CENTER>
<H3><A name=tth_sEc0.13.4>0.13.4</A>&nbsp;&nbsp;T_VECTOR - тестовая программа 
генерации векторов</H3></CENTER>
<P><PRE>/*================================================= T_VECTOR.C
 * ТЕСТ ГЕНЕРАЦИИ ВЕКТОРОВ
 *
 * Строит вектора из точки Xn,Yn в заданную
 * Программа запрашивает ввод четыpех чисел:
 * mode  = -2 - прекращение работы
 *         -1 - очистка экрана
 *          0 - вывод сетки
 *          1-7 построение вектоpа:
 *            1рр == 1 - по алгоритму ЦДА
 *            2рр == 1 - по алгоритму Брезенхема
 *            3рр == 1 - по модифиц. алгоритму Брезенхема
 *         иное значение - замена Xn,Yn на введенные Xk,Yk
 * atrib - атpибуты постpоения в виде десятичного числа
 *         из 8 цифр - PPСCCVVV:
 *         PP  - pазмеp элементаpного пиксела
 *         ССС - начальный номер оттенка
 *         VVV - количество оттенков
 * Xk    - конечная координата вектора
 * Yk
 */

#include "V_VECTOR.C"

#define MODE_256 1 /* 0/1 - обычный VGA/SVGA режим */

#if MODE_256
#   include "V_SVGA.C"
#endif

#include &lt;conio.h&gt;
#include &lt;graphics.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

/*------------------------------------------------------- Grid
 * Строит сетку 10*10
 */

void Grid (int col)
{  int Xn,Yn,Xk,Yk;
   setcolor (col);
   Xn= 0;  Xk= getmaxx();
   Yn= 0;  Yk= getmaxy();
   while (Xn &lt;= Xk) {line (Xn,Yn,Xn,Yk); Xn+= 10; }
   Xn= 0;
   while (Yn &lt;= Yk) {line (Xn,Yn,Xk,Yn); Yn+= 10; }
}  /* Grid */

/*----------------------------------------- MAIN T_VECTOR.C */

void main (void)
{
   int  ii, jj,
        mode=1,           /* Режим pаботы              */
        Xn=0,Yn=0,        /* Координаты начала отрезка */
        Xk,Yk,            /* Координаты конца отрезка  */
        fon,              /* Индекс цвета фона         */
        col_beg, col_val, /* Атpибуты пикселов         */
        xpix, ypix,
        colgrid,          /* Цвет сетки                */
        col_lin= 200,     /* Цвет "точного" отрезка    */
        col_Bre= 201,     /* Цвет построения для ЦДА   */
        col_DDA= 202;     /* Цвет построения для Брезенхема */
   int  gdriver= DETECT, gmode;
   long atrib=5064064l,la;/* Размеp пиксела*100+цвета  */

#if MODE_256
   V_ini256 (&amp;gdriver, &amp;gmode, "");
   jj= getmaxcolor();
   for (ii=0; ii&lt;=jj; ++ii)     /* Ч/б палитра    */
      setrgbpalette (ii, ii, ii, ii);
   atrib=5064064l;              /* Пиксел 5х5, нач цвет=64*/
   colgrid= 170;                /* Цвет сетки */
   fon= 140;
   setrgbpalette(7,255,255,255);/* Цвет для printf */
#else
   initgraph (&amp;gdriver, &amp;gmode, "");
   atrib= 5000016l;             /* Пиксел 5х5, нач цвет=0*/
   colgrid= 9;
   fon= 8;
#endif

   setbkcolor(fon);                     /* Очистка экрана */
   cleardevice();
   Xk= getmaxx(); Yk= getmaxy();

   Grid (colgrid);

/* Цвет для построения алгоритмом ЦДА */
   setrgbpalette(col_lin,63, 0,0);  /* Цвет точного отрезка  */
   setrgbpalette(col_DDA,63,63,0);  /* Цвет для ЦДА          */
   setrgbpalette(col_Bre,00,63,0);  /* Цвет для Брезенхема   */

   for (;;) {
      gotoxy (1, 1);
      printf("                                            ");
      printf("              \r");
      printf("mode atrib Xk Yk= (%d %ld %d %d) ? ",
              mode, atrib, Xk, Yk);
      scanf ("%d%ld%d%d", &amp;mode, &amp;atrib, &amp;Xk, &amp;Yk);
      xpix= ypix= atrib / 1000000l;
      la= atrib % 1000000l;
      col_beg= la / 1000l;
      col_val= la % 1000l;
      if (mode == -2) goto konec; else
      if (mode == -1) cleardevice(); else
      if (!mode) Grid (colgrid); else
      if (mode &amp; 7) {
        if (mode &amp; 1) {
           V_setlin (xpix, ypix, col_DDA, 1);
           V_DDA (Xn, Yn, Xk, Yk);
/* Постpоение "точного" отpезка */
           setcolor (col_lin);
           line (Xn, Yn, Xk*xpix, Yk*ypix);
        }
        if (mode &amp; 2) {
           V_setlin (xpix, ypix, col_Bre, 1);
           V_Bre (Xn, Yn+3, Xk, Yk+3);
/* Постpоение "точного" отpезка */
           setcolor (col_lin);
           line (Xn, (Yn+3)*ypix, Xk*xpix, (Yk+3)*ypix);
        }
        if (mode &amp; 4) {
           V_setlin (xpix, ypix, col_beg, col_val);
           V_BreM (Xn, Yn+6, Xk, Yk+6);
/* Постpоение "точного" отpезка */
           setcolor (col_lin);
           line (Xn, (Yn+6)*ypix, Xk*xpix, (Yk+6)*ypix);
        }
      } else {
         Xn= Xk;  Yn= Yk;
      }
   }
konec:
   closegraph();
}  /* main */
</PRE>
<CENTER>
<H3><A name=tth_sEc0.14>0.14</A>&nbsp;&nbsp;Приложение 3. Процедуры 
фильтрации</H3></CENTER>
<P>В данном приложении содержатся процедуры поддержки низкочастотной фильтрации 
растровых изображений и процедуры усреднения растровых изображений с понижением 
разрешения, а также тестовая программа демонстрирующая их работу. 
<P>Всего представлены две процедуры низкочастотной фильтрации V_fltr0 и V_fltr1, 
предназначенные для обработки изображений прямо в видеопамяти и с построчной 
буферизацией в оперативной памяти, соответственно. Последняя при модификации 
вспомогательных процедур доступа к изображению может обрабатывать картины, 
находящиеся в файле на внешнем носителе или просто в оперативной памяти. 
<P>Аналогично, представлены две процедуры усреднения изображения с понижением 
разрешения - V_fltr2 и V_fltr3. 
<P>При фильтрации и усреднении может использоваться одна из пяти предусмотренных 
масок фильтрации. 
<P><PRE>/*================================================== V_FILTR.C
 * В файле V_FILTR.C содержатся процедуры
 * поддержки фильтрации изображений:
 *
 * GetStr, PutStr - служебные
 *
 * V_fltr0 - фильтрует изображение в прямоугольной области,
 *           работая прямо с видеопамятью
 * V_fltr1 - фильтрует изображение в прямоугольной области,
 *           работая с буферами строк
 * V_fltr2 - усредняет картину по маске с понижением
 *           разрешения, работая прямо с видеопамятью
 * V_fltr3 - усредняет картину по маске с понижением
 *           разрешения, работая с буферами строк
 */

#include &lt;alloc.h&gt;

#define GetMay getpixel
#define PutMay putpixel

static int
   Mask0[]= {1,1, 1,1 },
   Mask1[]= {1,1,1, 1,1,1, 1,1,1 },
   Mask2[]= {1,1,1, 1,2,1, 1,1,1 },
   Mask3[]= {1,2,1, 2,4,2, 1,2,1 },
   Mask4[]= {1,1,1,1,
             1,1,1,1,
             1,1,1,1,
             1,1,1,1 },
   Mask5[]= {1,2, 3, 4, 3,2,1,
             2,4, 6, 8, 6,4,2,
             3,6, 9,12, 9,6,5,
             4,8,12,16,12,8,4,
             3,6, 9,12, 9,6,5,
             2,4, 6, 8, 6,4,2,
             1,2, 3, 4, 3,2,1 },
   Mask_ln[]= {2, 3, 3, 3, 4, 7},   /* Размер маски    */
   Mask_st[]= {2, 2, 2, 2, 4, 4},   /* Шаг усреднения  */
   Mask_vl[]= {4, 9,10,16,16,256},  /* Сумма элементов */
   *Mask_bg[]={                    /* Адреса начал    */
      Mask0,Mask1,Mask2,Mask3,Mask4,Mask5
   };

/*----------------------------------------------------- GetStr
 * Запрашивает фрагмент растровой строки из видеопамяти
 */
static void GetStr (st, Yst, Xn, Xk)
char *st;  int Yst, Xn, Xk;
{ while (Xn &lt;= Xk) *st++= GetMay (Xn++, Yst); }


/*----------------------------------------------------- PutStr
 * Записывает фрагмент растровой строки в видеопамять
 */
static void PutStr (st, Yst, Xn, Xk)
char *st;  int Yst, Xn, Xk;
{while (Xn &lt;= Xk) PutMay (Xn++, Yst, *st++); }
</PRE>
<P>
<P><BR><PRE>/*---------------------------------------------------- V_fltr0
 * Фильтрует изображение в прямоугольной области,
 * работая прямо с видеопамятью
 * msknum              = 0-5 - номер маски фильтра
 * Xn_source,Yn_source - окно исходного изображения
 * Xk_source,Xk_source
 * Xn_target,Yn_target - верхний левый угол результата
 */
void V_fltr0 (msknum,Xn_source,Yn_source,Xk_source,Yk_source,
              Xn_target,Yn_target)
int  msknum,Xn_source,Yn_source,Xk_source,Yk_source,
     Xn_target,Yn_target;
{
   char *plut;          /* Указатель палитры */
   int  *pi;            /* Тек указат маски  */
   int  pixel;          /* Пиксел исх изображения */
   int  *Maska,         /* Указатель маски */
        Mask_Y,Mask_X,  /* Размеры маски   */
        X_centr,Y_centr,/* Центр маски     */
        Mask_sum,       /* Сумма элементов */
        Xk,             /* Предельные положения маски */
        Yk,             /* в исходной области */
        s, sr, sg, sb,  /* Скаляры для суммир в маской   */
        ii, jj,
        Xt, Yt;

/* Запрос параметров маски */
   Maska=  Mask_bg[msknum];             /* Указатель маски */
   Mask_Y= Mask_X= Mask_ln[msknum];     /* Размеры маски   */
   X_centr= Mask_X / 2;                 /* Центр маски     */
   Y_centr= Mask_Y / 2;
   Mask_sum= Mask_vl[msknum];           /* Сумма элементов */

/* Предельные положения маски в исходной области */
   Xk= Xk_source+1-Mask_X;
   Yk= Yk_source+1-Mask_Y;

/*------- Фильтрация с прямой работой с видеопамятью -------*/

   for (Yt= Yn_source; Yt&lt;=Yk; ++Yt) {
      for (Xt=Xn_source; Xt&lt;=Xk; ++Xt) {
         pi= Maska; sr=0; sg=0; sb=0;   /* Суммированные RGB*/
         for (ii=0; ii&lt;Mask_Y; ++ii)
            for (jj=0; jj&lt;Mask_X; ++jj) {
               pixel= GetMay (Xt+jj, Yt+ii);
               plut= &amp;V_pal256[pixel][0];
               s= *pi++;                /* Элемент маски */
               sr+= (s * *plut++);      /* Суммирование  */
               sg+= (s * *plut++);      /* по цветам с   */
               sb+= (s * *plut++);      /* весами маски  */
            }
         sr /= Mask_sum; sg /= Mask_sum;  sb /= Mask_sum;
/* Поиск элемента ТЦ, наиболее подходящего для данных R,G,B */
         ii= V_clrint (sr, sg, sb);
         PutMay (Xn_target+(Xt-Xn_source)+X_centr,
                 Yn_target+(Yt-Yn_source)+Y_centr, ii);
      }
   }
}  /* V_fltr0 */
</PRE>
<P>
<P><BR><PRE>/*---------------------------------------------------- V_fltr1
 * Фильтрует изображение в прямоугольной области,
 * работая с буферами строк
 * msknum              = 0-5 - номер маски фильтра
 * Xn_source,Yn_source - окно исходного изображения
 * Xk_source,Xk_source
 * Xn_target,Yn_target - верхний левый угол результата
 */
void V_fltr1 (msknum,Xn_source,Yn_source,Xk_source,Yk_source,
              Xn_target,Yn_target)
int  msknum,Xn_source,Yn_source,Xk_source,Yk_source,
     Xn_target,Yn_target;
{
   char *plut;          /* Указатель палитры */
   int  *pi;            /* Тек указат маски  */
   int  pixel;          /* Пиксел исх изображения */
   int  *Maska,         /* Указатель маски */
        Mask_Y,Mask_X,  /* Размеры маски   */
        X_centr,Y_centr,/* Центр маски     */
        Mask_sum,       /* Сумма элементов */
        Xk,             /* Предельные положения маски */
        Yk,             /* в исходной области */
        Dx_source,      /* Размер строки исх изображения */
        Ystr,           /* Y тек читаемой строки изображ */
        s, sr, sg, sb,  /* Скаляры для суммир в маской   */
        ii, jj,
        Xt, Yt;
   char *ps, *sbuf, *pt, *tbuf, *ptstr[8];

   Dx_source= Xk_source-Xn_source+1;

/* Запрос параметров маски */
   Maska=  Mask_bg[msknum];             /* Указатель маски */
   Mask_Y= Mask_X= Mask_ln[msknum];     /* Размеры маски   */
   X_centr= Mask_X / 2;                 /* Центр маски     */
   Y_centr= Mask_Y / 2;
   Mask_sum= Mask_vl[msknum];           /* Сумма элементов */

/* Предельные положения маски в исходной области */
   Xk= Xk_source+1-Mask_X;
   Yk= Yk_source+1-Mask_Y;

/* Заказ буферов */
   if ((sbuf= malloc (Dx_source * Mask_Y)) == NULL) goto all;
   if ((tbuf= malloc (Dx_source)) == NULL)
      goto fr_sbuf;

/*------- Фильтрация с использованием буферов строк --------*/

/* Подготовка массива указателей на строки
 *  ptstr[0] --&gt; последняя строка
 *  ptstr[1] --&gt; строка 0
 *  ptstr[2] --&gt; строка 1
 *  и т.д.
 */
   ps= sbuf;  ii= Mask_Y;  jj= 1;
   do {
      ptstr[jj]= ps;  ps+= Dx_source;
      if (++jj == Mask_Y) jj= 0;
   } while (--ii &gt; 0);

/* Начальное чтение Mask_Y - 1 строк */
   Ystr= Yn_source;
   for (ii=1; ii&lt;Mask_Y; ++ii)
      GetStr (ptstr[ii], Ystr++, Xn_source, Xk_source);

   for (Yt= Yn_source; Yt&lt;=Yk; ++Yt) {

/* Запрос следующей строки и циклический сдвиг указателей */
      GetStr (ps= ptstr[0], Ystr++, Xn_source, Xk_source);
      jj= Mask_Y-1;
      for (ii=0; ii&lt;jj; ++ii) ptstr[ii]= ptstr[ii+1];
      ptstr[jj]= ps;

      pt= tbuf;
      for (Xt=Xn_source; Xt&lt;=Xk; ++Xt) {
         pi= Maska; sr=0; sg=0; sb=0;   /* Суммированные RGB*/
         for (ii=0; ii&lt;Mask_Y; ++ii) {
            ps= ptstr[ii] + (Xt-Xn_source);
            for (jj=0; jj&lt;Mask_X; ++jj) {
               plut= &amp;V_pal256[*ps++ &amp; 255][0];
               s= *pi++;                /* Элемент маски */
               sr+= (s * *plut++);      /* Суммирование  */
               sg+= (s * *plut++);      /* по цветам с   */
               sb+= (s * *plut++);      /* весами маски  */
            }
         }
         sr /= Mask_sum; sg /= Mask_sum;  sb /= Mask_sum;
/* Поиск элемента ТЦ, наиболее подходящего для данных R,G,B */
         *pt++= V_clrint (sr, sg, sb);
      }
      PutStr (tbuf,                     /* Запись строки */
              Yn_target + Y_centr + (Yt-Yn_source) ,
              Xn_target + X_centr,
              Xn_target + X_centr + (--pt - tbuf));
   }
   free (tbuf);
fr_sbuf:
   free (sbuf);
all:;
}  /* V_fltr1 */
</PRE>
<P>
<P><BR><PRE>/*---------------------------------------------------- V_fltr2
 * Усредняет картину по маске с понижением разрешения,
 * работая прямо с видеопамятью
 * msknum              = 0-5 - номер маски фильтра
 * Xn_source,Yn_source - окно исходного изображения
 * Xk_source,Xk_source
 * Xn_target,Yn_target - верхний левый угол результата
 */
void V_fltr2 (msknum,Xn_source,Yn_source,Xk_source,Yk_source,
              Xn_target,Yn_target)
int  msknum,Xn_source,Yn_source,Xk_source,Yk_source,
     Xn_target,Yn_target;
{
   char *plut;          /* Указатель палитры */
   int  *pi;            /* Тек указат маски  */
   int  pixel;          /* Пиксел исх изображения */
   int  *Maska,         /* Указатель маски */
        Mask_Y,Mask_X,  /* Размеры маски   */
        X_centr,Y_centr,/* Центр маски     */
        Mask_sum,       /* Сумма элементов */
        Xk,             /* Предельные положения маски */
        Yk,             /* в исходной области */
        s, sr, sg, sb,  /* Скаляры для суммир в маской   */
        Xr,Yr,          /* Координаты пиксела результата */
        Sm,             /* Сдвиг маски для обраб след точки */
        ii, jj,
        Xt, Yt;

/* Запрос параметров маски */
   Maska=  Mask_bg[msknum];             /* Указатель маски */
   Mask_Y= Mask_X= Mask_ln[msknum];     /* Размеры маски   */
   X_centr= Mask_X / 2;                 /* Центр маски     */
   Y_centr= Mask_Y / 2;
   Mask_sum= Mask_vl[msknum];           /* Сумма элементов */

/* Предельные положения маски в исходной области */
   Xk= Xk_source+1-Mask_X;
   Yk= Yk_source+1-Mask_Y;

   Yt= Yn_source;
   Yr= Yn_target+Y_centr;
   Sm= Mask_st[msknum];                 /* Шаг усреднения*/
   while (Yt &lt;= Yk) {
      Xt=Xn_source;  Xr= Xn_target+X_centr;
      while (Xt &lt;= Xk) {
         pi= Maska; sr=0; sg=0; sb=0;   /* Суммированные RGB*/
         for (ii=0; ii&lt;Mask_Y; ++ii)
            for (jj=0; jj&lt;Mask_X; ++jj) {
               pixel= GetMay (Xt+jj, Yt+ii);
               plut= &amp;V_pal256[pixel][0];
               s= *pi++;                /* Элемент маски */
               sr+= (s * *plut++);      /* Суммирование  */
               sg+= (s * *plut++);      /* по цветам с   */
               sb+= (s * *plut++);      /* весами маски  */
            }
         sr /= Mask_sum; sg /= Mask_sum;  sb /= Mask_sum;
/* Поиск элемента ТЦ, наиболее подходящего для данных R,G,B */
         ii= V_clrint (sr, sg, sb);
         PutMay (Xr++, Yr, ii);
         Xt+= Sm;
      }
      Yt+= Sm;  ++Yr;
   }
}  /* V_fltr2 */
</PRE>
<P>
<P><BR><PRE>/*---------------------------------------------------- V_fltr3
 * Усредняет картину по маске с понижением разрешения,
 * работая с буферами строк
 * msknum              = 0-5 - номер маски фильтра
 * Xn_source,Yn_source - окно исходного изображения
 * Xk_source,Xk_source
 * Xn_target,Yn_target - верхний левый угол результата
 */
void V_fltr3 (msknum,Xn_source,Yn_source,Xk_source,Yk_source,
              Xn_target,Yn_target)
int  msknum,Xn_source,Yn_source,Xk_source,Yk_source,
     Xn_target,Yn_target;
{
   char *plut;          /* Указатель палитры */
   int  *pi;            /* Тек указат маски  */
   int  pixel;          /* Пиксел исх изображения */
   int  *Maska,         /* Указатель маски */
        Mask_Y,Mask_X,  /* Размеры маски   */
        X_centr,Y_centr,/* Центр маски     */
        Mask_sum,       /* Сумма элементов */
        Xk,             /* Предельные положения маски */
        Yk,             /* в исходной области */
        Dx_source,      /* Размер строки исх изображения */
        s, sr, sg, sb,  /* Скаляры для суммир в маской   */
        Xr,Yr,          /* Координаты пиксела результата */
        Sm,             /* Сдвиг маски для обраб след точки */
        ii, jj,
        Xt, Yt;
   char *ps, *sbuf, *pt, *tbuf, *ptstr[8];


   Dx_source= Xk_source-Xn_source+1;

/* Запрос параметров маски */
   Maska=  Mask_bg[msknum];             /* Указатель маски */
   Mask_Y= Mask_X= Mask_ln[msknum];     /* Размеры маски   */
   X_centr= Mask_X / 2;                 /* Центр маски     */
   Y_centr= Mask_Y / 2;
   Mask_sum= Mask_vl[msknum];           /* Сумма элементов */

/* Предельные положения маски в исходной области */
   Xk= Xk_source+1-Mask_X;
   Yk= Yk_source+1-Mask_Y;

/* Заказ буферов */
   if ((sbuf= malloc (Dx_source * Mask_Y)) == NULL) goto all;
   if ((tbuf= malloc (Dx_source/Mask_st[msknum]+16)) == NULL)
      goto fr_sbuf;

/* Подготовка массива указателей на строки
 *  ptstr[0] --&gt; строка 0
 *  ptstr[1] --&gt; строка 1
 *  ptstr[2] --&gt; строка 2
 *  и т.д.
 */
   ps= sbuf;
   for (ii=0; ii&lt;Mask_Y; ++ii) {
      ptstr[ii]= ps;  ps+= Dx_source;
   }

   Yt= Yn_source;
   Yr= Yn_target+Y_centr;
   Sm= Mask_st[msknum];                 /* Шаг усреднения*/
   while (Yt &lt;= Yk) {
      for (ii=0; ii&lt;Mask_Y; ++ii)       /* Чтен исх строк */
         GetStr (ptstr[ii], Yt+ii, Xn_source, Xk_source);
      Xt=Xn_source;  pt= tbuf;
      while (Xt &lt;= Xk) {
         pi= Maska; sr=0; sg=0; sb=0;   /* Суммированные RGB*/
         for (ii=0; ii&lt;Mask_Y; ++ii) {
            ps= ptstr[ii] + (Xt-Xn_source);
            for (jj=0; jj&lt;Mask_X; ++jj) {
               plut= &amp;V_pal256[*ps++ &amp; 255][0];
               s= *pi++;                /* Элемент маски */
               sr+= (s * *plut++);      /* Суммирование  */
               sg+= (s * *plut++);      /* по цветам с   */
               sb+= (s * *plut++);      /* весами маски  */
            }
         }
         sr /= Mask_sum; sg /= Mask_sum;  sb /= Mask_sum;
/* Поиск элемента ТЦ, наиболее подходящего для данных R,G,B */
         *pt++= V_clrint (sr, sg, sb);
         Xt+= Sm;
      }
      PutStr (tbuf,Yr++,                /* Запись строки */
              Xn_target+X_centr,
              Xn_target+X_centr + (--pt - tbuf));
      Yt+= Sm;
   }
   free (tbuf);
fr_sbuf:
   free (sbuf);
all:;
}  /* V_fltr3 */
</PRE>
<P>
<P><BR><PRE>/*================================================== T_FILTR.C
 *
 * ТЕСТ ФИЛЬТРАЦИИ
 *
 * Программа вначале строит два смещенных вектора
 * большими пикселами, затем последовательно для каждой
 * из пяти масок:
 * - фильтрует с непосредственным доступом к видеопамяти
 * - фильтрует с буферизацией растровых строк
 * - формирует усредненную картинку меньшего разрешения
 *   с непосредственным доступом к видеопамяти
 * - формирует усредненную картинку меньшего разрешения
 *   с буферизацией растровых строк
 *
 * После вывода очередной картинки ждет нажатия любой клавиши
 *
 * Виды масок:
 *   0: 1 1   1: 1 1 1   2: 1 1 1   3: 1 2 1
 *      1 1      1 1 1      1 2 1      2 4 2
 *               1 1 1      1 1 1      1 2 1
 *
 *  4: 1 1 1 1   5: 1 2  3  4  3 2 1
 *     1 1 1 1      2 4  6  8  6 4 2
 *     1 1 1 1      3 6  9 12  9 6 5
 *     1 1 1 1      4 8 12 16 12 8 4
 *                  3 6  9 12  9 6 5
 *                  2 4  6  8  6 4 2
 *                  1 2  3  4  3 2 1
 */

#include "V_VECTOR.C"
#include "VGA_256.C"
#include "V_FILTR.C"

#include &lt;conio.h&gt;
#include &lt;graphics.h&gt;
#include &lt;stdio.h&gt;

#define VECTOR 0  /* 0/1 - фикс вектор/ввод координат */

/*------------------------------------------------------- Grid
 * Строит сетку 10*10
 */

void Grid (void)
{  int Xn,Yn,Xk,Yk;
   setcolor (170);
   Xn= 0;  Xk= getmaxx();
   Yn= 0;  Yk= getmaxy();
   while (Xn &lt;= Xk) {line (Xn,Yn,Xn,Yk); Xn+= 10; }
   Xn= 0;
   while (Yn &lt;= Yk) {line (Xn,Yn,Xk,Yn); Yn+= 10; }
}  /* Grid */
</PRE>
<P>
<P><BR><PRE>/*---------------------------------------------- main Filtr */

void main (void)
{
   int  ii, jj,
        mov_lin,                /* 0/1 - позиционир/отрезок */
        Xn,Yn,Xk,Yk,            /* Координаты отрезка       */
        fon=   140;             /* Индекс фона              */
   int  gdriver= DETECT, gmode;
   int  Xn_source, Yn_source,   /* Фильтруемая область      */
        Xk_source, Yk_source,
        Dx_source;
   int  Xn_target, Yn_target,   /* Результаты фильтрации    */
        Xk_target, Yk_target;
   int  msknum;                 /* Номер текущей маски  */
   char *ps;

   V_ini256 (&amp;gdriver, &amp;gmode, "");

   ps= (char *)V_pal256;
   for (ii=0; ii&lt;=255; ++ii) {          /* Ч/б палитра    */
      jj= ii / 4;
      *ps++= jj; *ps++= jj; *ps++= jj;
      setrgbpalette (ii, jj, jj, jj);
   }
   setbkcolor(fon);                     /* Очистка экрана */
   cleardevice();
   Xk= getmaxx(); Yk= getmaxy();

/* Начальные установки для фильтрации */
   Xn_source= 0;                        /* Исходная область */
   Yn_source= 0;
   Xk_source= (Xk + 1)/2 - 1;
   Yk_source= Yk;
   Xn_target= Xk_source + 1;            /* Результ. область */
   Yn_target= 0;
   Xk_target= Xk;
   Yk_target= Yk_source;

   Dx_source= Xk_source-Xn_source+1;    /* X-размер исходной*/

#if VECTOR
   Grid ();
   mov_lin= 1;  Xn= 0;  Yn= 0;  Xk= 0;  Yk= 0;
   for (;;) {
      gotoxy (1, 1);
      printf("                                       \r");
      printf("mov_lin Xk Yk= (%d %d %d) ? ", mov_lin, Xk, Yk);
      scanf ("%d%d%d", &amp;mov_lin, &amp;Xk, &amp;Yk);
      if (mov_lin &lt; 0) cleardevice(); else
      if (!mov_lin) Grid (); else {
         if (mov_lin &amp; 1) V_DDA (0, 0, Xk, Yk);
         if (mov_lin &amp; 2) V_Bre (0, 0, Xk, Yk);
      }
   }
#else
   Xk= Dx_source / Pix_X - 1;
   Yk= (Yk_source-Yn_source+1) / Pix_Y - 1;
   V_DDA (Xn_source, Yn_source,    Xk, Yk-17);
   V_Bre (Xn_source, Yn_source+17, Xk, Yk);
   getch();
#endif

   ii= 0xF;     /* Обе фильтрации и оба сжатия */

   setfillstyle (SOLID_FILL, fon);

   for (msknum=0; msknum&lt;6; ++msknum) {
      if (ii &amp; 1) {     /* Фильтрация из видеоозу */
         bar (Xn_target, Yn_target, Xk_target, Yk_target);
         V_fltr0 (msknum,Xn_source,Yn_source,
                  Xk_source,Yk_source,Xn_target,Yn_target);
        getch ();
      }
      if (ii &amp; 2) {     /* Фильтрация из буферов */
         bar (Xn_target, Yn_target, Xk_target, Yk_target);
         V_fltr1 (msknum,Xn_source,Yn_source,
                  Xk_source,Yk_source,Xn_target,Yn_target);
         getch ();
      }
      if (ii &amp; 4) {     /* Сжатие из из видеоозу */
         bar (Xn_target, Yn_target, Xk_target, Yk_target);
         V_fltr2 (msknum,Xn_source,Yn_source,
                  Xk_source,Yk_source,Xn_target,Yn_target);
        getch ();
      }
      if (ii &amp; 8) {     /* Сжатие из буферов */
         bar (Xn_target, Yn_target, Xk_target, Yk_target);
         V_fltr3 (msknum,Xn_source,Yn_source,
                  Xk_source,Yk_source,Xn_target,Yn_target);
         getch ();
      }
   }
   closegraph();
}  /* main */
</PRE>
<CENTER>
<H3><A name=tth_sEc0.15>0.15</A>&nbsp;&nbsp;Приложение 4. Процедуры генерации 
окружности</H3></CENTER>
<P>В данном приложении помещены процедуры генерации окружностей по алгоритму 
Брезенхема и Мичнера, а также программа T_Circle для тестирования данных 
процедур. 
<P><PRE>/*--------------------------------------------------- V_Circle
 * Подпрограммы для генерации окружности
 * Pixel_circle - занесение пикселов с учетом симметрии
 * V_BRcirc     - генерирует окружность по алгоритму
 *                Брезенхема.
 * V_MIcirc     - генерирует окружность по алгоритму
 *                Мичнера.
 */

#include &lt;graphics.h&gt;

/*----------------------------------------------- Pixel_circle
 * Заносит пикселы окружности по часовой стрелке
 */

static void Pixel_circle (xc, yc, x, y, pixel)
int  xc, yc, x, y, pixel;
{
   putpixel(xc+x, yc+y, pixel);
   putpixel(xc+y, yc+x, pixel);
   putpixel(xc+y, yc-x, pixel);
   putpixel(xc+x, yc-y, pixel);
   putpixel(xc-x, yc-y, pixel);
   putpixel(xc-y, yc-x, pixel);
   putpixel(xc-y, yc+x, pixel);
   putpixel(xc-x, yc+y, pixel);
}  /* Pixel_circle */


/*--------------------------------------------------- V_BRcirc
 * Генерирует 1/8 окружности по алгоритму Брезенхема
 *
 * Процедура может строить 1/4 окружности.
 * Для этого надо цикл while заменить на for (;;)
 * и после Pixel_circle проверять достижение конца по условию
 * if (y &lt;= end) break;
 * Где end устанавливается равным 0
 * В этом случае не нужен и последний оператор
 * if (x == y) Pixel_circle (xc, yc, x, y, pixel);
 * Генерацию 1/8 можно обеспечить задав end = r / sqrt (2)
 */

void V_BRcirc (xc, yc, r, pixel)
int  xc, yc, r, pixel;
{  int  x, y, z, Dd;
   x= 0;  y= r;  Dd= 2*(1-r);
   while (x &lt; y) {
      Pixel_circle (xc, yc, x, y, pixel);
      if (!Dd) goto Pd;
      z= 2*Dd - 1;
      if (Dd &gt; 0) {
         if (z + 2*x &lt;= 0) goto Pd; else goto Pv;
      }
      if (z + 2*y &gt; 0) goto Pd;
Pg:   ++x;      Dd= Dd + 2*x + 1;   continue; /* Горизонт */
Pd:   ++x; --y; Dd= Dd + 2*(x-y+1); continue; /* Диагонал */
Pv:   --y;      Dd= Dd - 2*y + 1;             /* Вертикал */
   }
   if (x == y) Pixel_circle (xc, yc, x, y, pixel);
}  /* V_BRcirc */


/*--------------------------------------------------- V_MIcirc
 * Генерирует 1/8 окружности по алгоритму Мичнера
 */

void V_MIcirc (xc, yc, r, pixel)
int  xc, yc, r, pixel;
{  int  x, y, d;
   x= 0;  y= r;  d= 3 - 2*r;
   while (x &lt; y) {
      Pixel_circle (xc, yc, x, y, pixel);
      if (d &lt; 0) d= d + 4*x + 6; else {
         d= d + 4*(x-y) + 10;  --y;
      }
      ++x;
   }
   if (x == y) Pixel_circle (xc, yc, x, y, pixel);
}  /* V_MIcirc */




/*=============================================== T_CIRCLE.C
 *
 * ТЕСТ ГЕНЕРАЦИИ ОКРУЖНОСТЕЙ
 *
 * Запрашивает ввод четырех чисел - координат центра,
 * радиуса и цвета построения: Xc Yc R Pix
 *
 * Затем строит заданную окружность по алгоритму Брезенхема
 * и концентрично с ней с радиусом, уменьшенным на 2, и
 * номером цвета, уменьшенным на 1, выдает окружность по
 * алгоритму Мичнера.
 *
 * При вводе Xc &lt; 0 программа прекращает работу
 */

#include &lt;graphics.h&gt;
#include &lt;stdio.h&gt;
#include "V_CIRCLE.C"


/*-------------------------------------------- MAIN T_CIRCLE.C
 */
void main (void)
{
   int   ii, Xc=300, Yc=240, R=238, Pix=14;
   int   gdriver = DETECT, gmode;

   initgraph(&amp;gdriver, &amp;gmode, "c:\tc\bgi");
   if ((ii= graphresult()) != grOk) {
      printf ("Err=%d\n", ii); goto all;
   }
   setbkcolor(0);
   cleardevice();

for (;;) {
gotoxy (1,1);
printf("                                                 \r");
printf("Xc, Yc, R, Pix= (%d %d %d %d) ? ", Xc,Yc,R,Pix);
scanf ("%d%d%d%d", &amp;Xc, &amp;Yc, &amp;R, &amp;Pix);
if (Xc &lt; 0) break;
V_BRcirc (Xc, Yc, R, Pix);
V_MIcirc (Xc, Yc, R-2, Pix-1);
}
all:
   closegraph();
}
</PRE>
<CENTER>
<H3><A name=tth_sEc0.16>0.16</A>&nbsp;&nbsp;Приложение 5. Процедуры заполнения 
многоугольника</H3></CENTER>
<P>В данном приложении приведены две процедуры заливки многоугольника: V_FP0 и 
V_FP1. Обе они реализуют алгоритм построчного заполнения, описанный в разделе 5. 

<P>В данных процедурах все массивы используются, начиная с элемента с индексом 
1, а не 0, как это принято в языке C. 
<P>
<CENTER>
<H3><A name=tth_sEc0.16.1>0.16.1</A>&nbsp;&nbsp;V_FP0 - простая процедура 
заливки многоугольника</H3></CENTER>
<P><PRE>/*=====================================================  V_FP0
 * Простая (и не слишком эффективная) подпрограмма
 * однотонной заливки многоугольника методом построчного
 * сканирования. Имеет место дублирование закраски
 * строк.
 * Более эффективная программа, практически не дублирующая
 * занесение пикселов, - V_FP1 приведена далее в этом
 * приложении.
 */

#include &lt;stdio.h&gt;
#include &lt;graphics.h&gt;

#define MAXARR 300  /* Макс кол-во вершин многоугольника  */
#define MAXLST 300  /* Макс размер списка активных ребер  */


/*---------------------------------------------------- FILSTR
 * Заливает строку iy от ixn до ixk
 *
 * void FILSTR (int kod, int iy, int ixn, int ixk)
 */
void FILSTR (kod, iy, ixn, ixk)
int kod, iy, ixn, ixk;
{
   while (ixn &lt;= ixk) putpixel (ixn++, iy, kod);
}  /* FILSTR */


/*----------------------------------------------------   SORT
 * Сортирует n элементов iarr по возрастанию
 */
void SORT (n, iarr)
int  n, *iarr;
{  int  ii, jj, kk, ll, min;
   for (ii=0; ii&lt;n; ++ii) {
      min= iarr[ll= ii];
      for (jj=ii+1; jj&lt;n; ++jj)
         if ((kk= iarr[jj]) &lt; min) {ll= jj; min= kk; }
      if (ll != ii) {iarr[ll]= iarr[ii]; iarr[ii]= min; }
   }
}  /* SORT */


/*--------------- Глобалы процедуры закраски ---------------*/

static int   KOD, NWER; /* Код заливки и количество вершин  */
static float *pt_X;     /* Массивы входных координат вершин */
static float *pt_Y;

static int   ntek;          /* Номер текущей вершины */

/* Список активных ребер */
static int   idlspi;        /* Длина списка активных ребер */
static int   IYREB[MAXLST]; /* Макс Y-коорд активных ребер */
static float RXREB[MAXLST]; /* Тек  X-коорд активных ребер */
static float RPRIR[MAXLST]; /* X-приращение на 1 шаг по Y  */


/*---------------------------------------------------- OBRREB
 * По данным :
 *     NWER - количество вершин,
 *     ntek - номер текущей вершины,
 *     isd = -1/+1 - сдвиг для вычисления номера
 *           соседней вершины - слева/справа
 *     вычисляет DY,
 *     Если DY &lt;  0 то вершина уже обработана,
 *     Если DY == 0 то вершины на одном Y, т.е.
 *                     строится горизонтальный отрезок,
 *     Если DY &gt;  0 то формируется новый элемент списка
 *                     активных ребер
 */
static void OBRREB (isd)
int   isd;
{
   int   inext,iyt,ixt;
   float xt, xnext, dy;

   inext= ntek + isd;
   if (inext &lt; 1) inext= NWER;
   if (inext &gt; NWER) inext= 1;

   dy= pt_Y[inext] - pt_Y[ntek];
   if (dy &lt; 0) goto RETOBR;
   xnext= pt_X[inext];
   xt= pt_X[ntek];
   if (dy != 0) goto DYNE0;
      iyt= pt_Y[ntek];
      inext= xnext;
      ixt= xt;
      FILSTR (KOD, iyt, inext, ixt);
      goto RETOBR;
DYNE0:
   idlspi++;
   IYREB[idlspi]= pt_Y[inext];
   RXREB[idlspi]= xt;
   RPRIR[idlspi]= (xnext - xt) / dy;
RETOBR:;
}  /* OBRREB */
</PRE>
<P>
<P><BR><PRE>/*----------------------------------------------------  V_FP0
 * Однотонно заливает многоугольник,
 * заданный координатами вершин
 *
 * void V_FP0 (int pixel, int kol, float *Px, float *Py)
 *
 */
void V_FP0 (pixel, kol, Px, Py)
int  pixel, kol;  float *Px, *Py;
{
int  ii, jj, kk;
int  iymin;         /* Мин  Y-координата многоугольн   */
int  iymax;         /* Макс Y-координата многоугольн   */
int  iysled;        /* Y-коорд появления новых вершин  */
int  iytek;
int  ikledg;        /* Кол-во вершин с данным iytek    */
int  ibgind;        /* Нач индекс таких вершин         */
int  iedg[MAXARR];  /* Y-коорд вершин по возрастанию   */
int  inom[MAXARR];  /* Их номера в исходном массиве Py */
int  irabx[MAXLST]; /* X-коорд пересечений в строке сканир */

   KOD= pixel;      /* Параметры в глобалы */
   NWER= kol;
   pt_X= Px;
   pt_Y= Py;

/* Построение массивов Y и их номеров */
   for (ii=1; ii&lt;=kol; ++ii) {
      iedg[ii]= Py[ii]; inom[ii]= ii;
   }

/* Cовместная сортировка Y-коорд вершин и их номеров */
   for (ii=1;  ii &lt;= kol;  ++ii) {
      iymin= iedg[ii];
      ntek= ii;
      for (jj=ii+1;  jj &lt;= kol;  ++jj)
         if (iedg[jj] &lt; iymin) {iymin= iedg[jj]; ntek= jj; }
      if (ntek != ii) {
         iedg[ntek]= iedg[ii]; iedg[ii]= iymin;
         iymin= inom[ntek];
         inom[ntek]= inom[ii]; inom[ii]= iymin;
      }
   }

   idlspi= 0;                   /* Начальные присвоения */
   ibgind= 1;
   iytek= iedg[1];
   iymax= iedg[kol];

/* Цикл раскраски */

/* ikledg = кол-во вершин с данным iytek
 * ibgind = индексы таковых в массиве inom
 */
FORM_EDGES:
   ikledg= 0;
   for (ii=ibgind; ii&lt;=kol; ++ii)
      if (iedg[ii] != iytek) break; else ikledg++;

/* Цикл построения списка активных ребер
 * и закрашивание горизонтальных ребер
 */

/* Построение списка активных ребер (САР) */

   for (ii=1; ii&lt;=ikledg; ++ii) {
      ntek= inom[ ibgind+ii-1];     /* Исх ном тек вершины */
      OBRREB (-1);                  /* DY с соседями затем */
      OBRREB (+1);                  /* либо отказ,  либо   */
                                    /* горизонталь, либо   */
   }                                /* измен списка активных*/

   if (!idlspi) goto KOHGFA;

   ii= ibgind + ikledg;         /* Y ближайшей вершины */
   iysled= iymax;
   if (ii &lt; kol) iysled= iedg[ii];

/* Горизонтальная раскраска по списку */

   for (ii=iytek; ii&lt;=iysled; ++ii) {
/* Выборка X-ов из списка активных ребер (САР) */
      for (jj=1; jj &lt;= idlspi; ++jj)
         irabx[jj]= RXREB[jj];
      SORT (idlspi, irabx+1);           /* Сортировка X-ов */
      for (jj=1; jj&lt;=idlspi-1; jj+= 2)  /* Заливка */
         FILSTR (pixel, ii, irabx[jj], irabx[jj+1]);
      if (ii == iysled) continue;
      for (jj=1; jj &lt;= idlspi; ++jj)    /* Перестройка САР */
         RXREB[jj]= RXREB[jj] + RPRIR[jj];
   }

   if (iysled == iymax) goto KOHGFA;

/* Выбрасывание из списка всех ребер с YMAK ребра = YSLED */

   ii= 0;
M1:ii++;
M2:if (ii &gt; idlspi) goto WYBROSILI;
      if (IYREB[ii] != iysled) goto M1;
         --idlspi;
         for (jj=ii;  jj &lt;= idlspi;  ++jj) {
            IYREB[jj]= IYREB[kk= jj+1];
            RXREB[jj]= RXREB[kk];
            RPRIR[jj]= RPRIR[kk];
         }
         goto M2;
WYBROSILI:
   ibgind+= ikledg;
   iytek= iysled;

   goto FORM_EDGES;

KOHGFA:;
}  /* V_FP0 */
</PRE>
<P>
<P><BR>
<CENTER>
<H3><A name=tth_sEc0.16.2>0.16.2</A>&nbsp;&nbsp;Тестовая процедуры 
V_FP0</H3></CENTER>
<P><PRE>/*---------------------------------------------- main V_FP0 */

float Px[MAXARR] = {
   0.0,200.0,200.0,250.0,270.0,270.0,210.0,210.0,230.0,230.0
};
float Py[MAXARR] = {
   0.0,200.0,250.0,250.0,230.0,200.0,210.0,230.0,230.0,210.0
};

void main (void)
{
   int   ii, kol, grn, new, entry;
   int   gdriver = DETECT, gmode;

   kol= 5;              /* Кол-во вершин        */
   grn= 11;             /* Код пикселов границы */
   new= 14;             /* Код заливки          */
   entry= 1;

   initgraph(&amp;gdriver, &amp;gmode, "c:\tc\bgi");
   if ((ii= graphresult()) != grOk) {
      printf ("Err=%d\n", ii); goto all;
   }

m0:goto m2;
m1:++entry;
   printf("Vertexs, boundary_pixel, pixel= (%d %d %d) ? ",
            kol, grn, new);
   scanf ("%d%d%d", &amp;kol, &amp;grn, &amp;new);
   if (kol &lt; 0) goto all;

   for (ii=1; ii&lt;=kol; ++ii) {
      printf ("Px[%d], Py[%d] = ? ", ii, ii);
      scanf  ("%d%d", &amp;Px[ii], &amp;Py[ii]);
   }

m2:
   setbkcolor(0);       /* Очистка экрана */
   cleardevice();

/* Заливка */
   V_FP0 (new, kol, Px, Py);

/* Построение границы */
   setcolor (grn);
   for (ii= 1; ii&lt;kol; ++ii)
      line (Px[ii], Py[ii], Px[ii+1], Py[ii+1]);
   line (Px[kol], Py[kol], Px[1], Py[1]);

/* При первом входе строится квадратик дырки */
   if (!entry) {
      for (ii=kol+1; ii&lt;kol+4; ++ii)
         line (Px[ii], Py[ii], Px[ii+1], Py[ii+1]);
      line (Px[kol+4], Py[kol+4], Px[kol+1], Py[kol+1]);
   }

   goto m1;

all:
   closegraph();
}
</PRE>
<P>
<P><BR>
<CENTER>
<H3><A name=tth_sEc0.16.3>0.16.3</A>&nbsp;&nbsp;V_FP1 - эффективная процедура 
заливки многоугольника</H3></CENTER>
<P><PRE>/*=====================================================  V_FP1
 * Более эффективная по сравнению с V_FP0 подпрограмма
 * однотонной заливки многоугольника методом построчного
 * сканирования.
 *
 * Дублирувание занесения пикселов практически отсутствует
 *
 */

#include &lt;stdio.h&gt;
#include &lt;graphics.h&gt;

#define MAXARR 300  /* Макс кол-во вершин многоугольника  */
#define MAXLST 300  /* Макс размер списка активных ребер  */


/*---------------------------------------------------- FILSTR
 * Заливает строку iy от ixn до ixk
 *
 * void FILSTR (int kod, int iy, int ixn, int ixk)
 */
void FILSTR (kod, iy, ixn, ixk)
int kod, iy, ixn, ixk;
{
   while (ixn &lt;= ixk) putpixel (ixn++, iy, kod);
}  /* FILSTR */



/*--------------- Глобалы процедуры закраски ---------------*/

static int   KOD, NWER; /* Код заливки и кол-во вершин      */
static float *pt_X;     /* Массивы входных координат вершин */
static float *pt_Y;

static int   IBGIND;        /* Номер след вершины в списке */
static int   IEDG[MAXARR];  /* Y-коорд вершин по возрастан */
static int   INOM[MAXARR];  /* и их номера в исх масс Py   */

/* Список активных ребер */
static int   IDLSPI;        /* Длина списка активных ребер */
static int   IYREB[MAXLST]; /* Макс Y-коорд активных ребер */
static float RXREB[MAXLST]; /* Тек  X-коорд активных ребер */
static float RPRIR[MAXLST]; /* Х-приращение на 1 шаг по Y  */
static float RYSL[MAXLST];  /* Dy между тек и соседн верш  */
                            /* Dy &lt;= 0.0 - обычная вершина */
                            /*     &gt; 0.0 - локал экстремум */


/*---------------------------------------------------- FORSPI
 * int  FORSPI (int IYBEG)
 *
 *  1) Формирует элементы списка для ребер,
 *     начинающихся в IYBEG;
 *  2) Вычиcляeт IBGIND - индeкc нaчaлa следующей
 *     вepшины в cпиcкe вepшин;
 *  3) Возвращает IYSLED - Y кoopдинaтy ближaйшeй
 *     вepшины, дo кoтopoй мoжнo зaливaть бeз
 *     пepecтpoйки cпиcкa.
 *
 *  Глoбaльныe вeличины :
 *
 *  KOD    - код заливки
 *  NWER   - кoл-вo вepшин в иcxoднoм мнoгoyгoльникe,
 *  *pt_X  - X-кoopдинaты иcxoднoгo мнoгoyгoльника,
 *  *pt_Y  - Y-кoopдинaты иcxoднoгo мнoгoyгoльника,
 *  IEDG   - yпopядoчeнный пo вoзpacтaнию мaccив
 *           Y кoopдинaт вepшин иcxoднoгo мнoгoyгoльн
 *  INOM   - INOM[i] зaдaeт нoмep вepшины в иcxoднoм
 *           мнoгoyгoльникe для IEDG[i],
 *  IBGIND - индeкc мaccивoв IEDG, INOM
 *           oпpeдeляeт гдe мoжeт нaчaтьcя ребpo,
 *  IDLSPI - длинa пocтpoeннoгo cпиcкa aктивныx ребep,
 *           cocтoящeгo из :
 *           IYREB  - мaкc кoopдинaты ребep,
 *           RXREB  - внaчaлe мин, зaтeм тeкyщaя X-кoopдинaтa,
 *           RPRIR  - пpиpaщeниe к X-кoopдинaтe нa 1 шaг пo Y,
 *           RYSL   - пpизнaк тoгo чтo зa вepшинa :
 *                    &lt;= 0 - oбычнaя,
 *                     &gt; 0 - лoкaльный экcтpeмyм
 *                     пepeceчeниe cтpoки зaкpacки
 *                     c экcтpeмyмoм cчитaeтcя зa 2 тoчки,
 *                     c oбычнoй - зa 1;
 */

static int  FORSPI (IYBEG)
int  IYBEG;
{

   int   i,ikledg,intek,intabs,isd;
   int   iyt,ixt,nrebra,inc,inpred,inposl;
   float xt, xc, yt, yc, dy;

/* ikledg = кoл-вo вepшин c дaнным IYBEG */

   ikledg= 0;
   for (i=IBGIND; i&lt;=NWER; ++i)
      if (IEDG[i] != IYBEG) break; else ++ikledg;

/* Цикл пocтpoeния cпиcкa aктивныx ребep
   и зaкpaшивaниe гopизонтальных ребep
 */

   for (i=1; i&lt;=ikledg; ++i) {
/* Bычисл номера текущей вершины */
      intek= INOM[IBGIND+i-1];
      intabs= abs (intek);
      xt= pt_X[intabs];
      yt= pt_Y[intabs];

/*  Bычисл номеров предыд и послед вершин */
      if ((inpred= intabs - 1) &lt; 1) inpred= NWER;
      if ((inposl= intabs + 1) &gt; NWER) inposl= 1;

/*
 * По заданным :
 *    NWER   - кол-во вершин,
 *    intek  - номер текущей вершины,
 *    isd = 0/1 - правилу выбора соседней вершины -
 *                предыдущая/последующая
 *    вычиcляeт dy,
 *    Еcли dy &lt;  0 тo вepшинa yжe oбpaбoтaнa,
 *    Еcли dy == 0 тo вepшины нa oдном Y
 *                 Пpи этoм cтpoитcя гopизoнтaльный oтpeзoк.
 *                 Фaкт зaкpacки гopизoнтaльнoгo ребpa
 *                 oтмeчaeтcя oтpицaтeльным знaчeниeм
 *                 cooтвeтcтвyющeгo знaчeния INOM.
 *    Еcли dy &gt;  0 тo фopмиpyeтcя нoвый элeмент cпиcкa
 *                 aктивныx ребep
 */

      for (isd=0;  isd&lt;=1; ++isd) {
         if (!isd) nrebra= inc= inpred; else {
            inc= inposl;  nrebra= intabs;
         }
         yc= pt_Y[inc];
         dy= yc - yt;
         if (dy &lt; 0.0) continue;
         xc= pt_X[inc];
         if (dy != 0.0) goto DYNE0;
            if ((inc= INOM[nrebra]) &lt; 0) continue;
            INOM[nrebra]= -inc;
            iyt= yt;
            inc= xc;
            ixt= xt;
            FILSTR (KOD, iyt, inc, ixt);
            continue;
DYNE0:   ++IDLSPI;
         IYREB[IDLSPI]= yc;
         RXREB[IDLSPI]= xt;
         RPRIR[IDLSPI]= (xc - xt) / dy;
         inc= (!isd) ? inposl : inpred;
         RYSL[IDLSPI]=  pt_Y[inc] - yt;
      }   /* цикла по isd */
   }  /* построения списка активных ребер */

/*  Bычисление Y ближайшей вершины */
   if ((i= (IBGIND += ikledg)) &gt; NWER) i= NWER;
   return (IEDG[i]);
} /* Процедуры FORSPI */
</PRE>
<P>
<P><BR><PRE>/*-----------------------------------------------------  V_FP1
 * Однотонно заливает многоугольник,
 * заданный координатами вершин
 *
 * void V_FP1 (int pixel, int kol, float *Px, float *Py)
 *
 */
void V_FP1 (pixel, kol, Px, Py)
int  pixel, kol;  float *Px, *Py;
{
int  i,j,k,l;
int  iytek;    /* Y текущей строки сканирования        */
int  iymin;    /* Y-мин при сортировке массива Y-коорд */
int  iybeg;    /* Мин Y-координата заливки  */
int  iymak;    /* Max Y-координата заливки  */
int  iysled;   /* Y кoopд ближaйшeй вepшины, дo кoтopoй */
               /* можно зaливaть бeз пepecтpoйки cпиcкa */
int  newysl;
int  ixmin;    /* X-мин при сортировке для тек строки */
int  ixtek;    /* X-тек при сортировке для тек строки */
int  irabx[MAXLST]; /* X-коорд пересечений в строке сканир */

   KOD= pixel;    /* Параметры в глобалы */
   NWER= kol;
   pt_X= Px;
   pt_Y= Py;

/*  Построение массивов Y и их номеров */
   for (i= 1; i&lt;=NWER; ++i) {IEDG[i]= Py[i];  INOM[i]= i; }

/*  Cовместная сортировка массивов IEDG, IHOM */
   for (i= 1; i&lt;=NWER; ++i) {
      iymin= IEDG[i];
      k= 0;
      for (j=i+1; j&lt;=NWER; ++j)
         if ((l= IEDG[j]) &lt; iymin) {iymin= l; k= j; }
      if (k) {
         IEDG[k]= IEDG[i]; IEDG[i]= iymin;
         iymin= INOM[k];
         INOM[k]= INOM[i]; INOM[i]= iymin;
      }
   }

/* Hачальные присвоения */
   IDLSPI= 0;
   IBGIND= 1;
   iybeg= IEDG[1];
   iymak= IEDG[NWER];

/* Формирование начального списка акт ребер */

   iysled= FORSPI (iybeg);
   if (!IDLSPI) goto KOHGFA;

/* Горизонтальная раскраска по списку */

ZALIWKA:

   for (iytek=iybeg; iytek&lt;=iysled; ++iytek) {
      if (iytek == iysled) {    /* Y-координата перестройки */
         newysl= FORSPI (iytek);
         if (!IDLSPI) goto KOHGFA;
      }

/* Bыборка и сортировка X-ов из списка ребер */
      l= 0;
      for (i=1; i&lt;=IDLSPI; ++i)
         if (RYSL[i] &gt; 0.0) irabx[++l]= RXREB[i];
         else RYSL[i]= 1.0;

      for (i=1;  i&lt;=l; ++i) {
         ixmin= irabx[i];
         k= 0;
         for (j=i+1;  j&lt;=l; ++j) {
            ixtek= irabx[j];
            if (ixtek &lt; ixmin) {k= j; ixmin= ixtek; }
         }
         if (k) {irabx[k]= irabx[i];  irabx[i]= ixmin; }
      }  /* цикла сортировки */

/*  Cобственно заливка */

      for (j=1;  j&lt;=l-1;  j+= 2)
         FILSTR (KOD,iytek,irabx[j],irabx[j+1]);

      for (j=1;  j&lt;=IDLSPI; ++j)        /*  Приращения X-ов */
         RXREB[j]= RXREB[j] + RPRIR[j];
   }  /* цикла горизонтальной раскраски */

   if (iysled == iymak) goto KOHGFA;

/*  Bыбрасывание из списка всех ребер с YMAK ребра == YSLED */

   i= 0;
M1:++i;
M2:if (i &gt; IDLSPI) goto WYBROSILI;
      if (IYREB[i] != iysled) goto M1;
         --IDLSPI;
         for (j=i;  j&lt;=IDLSPI; ++j) {
            IYREB[j]= IYREB[k= j+1];
            RXREB[j]= RXREB[k];
            RPRIR[j]= RPRIR[k];
         }
         goto M2;
WYBROSILI:
   iybeg= iysled + 1;
   iysled= newysl;
   goto ZALIWKA;

KOHGFA:;
}  /* V_FP1 */
</PRE>
<P>
<CENTER>
<H3><A name=tth_sEc0.16.4>0.16.4</A>&nbsp;&nbsp;Тестовая процедуры 
V_FP1</H3></CENTER>
<P><PRE>/*---------------------------------------------- main V_FP1 */

float Px[MAXARR] = {
   0.0,200.0,200.0,250.0,270.0,270.0,210.0,210.0,230.0,230.0
};
float Py[MAXARR] = {
   0.0,200.0,250.0,250.0,230.0,200.0,210.0,230.0,230.0,210.0
};

void main (void)
{
   int   ii, kol, grn, new, entry;
   int   gdriver = DETECT, gmode;

   kol= 5;              /* Кол-во вершин        */
   grn= 11;             /* Код пикселов границы */
   new= 14;             /* Код заливки          */
   entry= 1;

   initgraph(&amp;gdriver, &amp;gmode, "c:\tc\bgi");
   if ((ii= graphresult()) != grOk) {
      printf ("Err=%d\n", ii); goto all;
   }

m0:goto m2;
m1:++entry;
   printf("Vertexs, boundary_pixel, pixel= (%d %d %d) ? ",
            kol, grn, new);
   scanf ("%d%d%d", &amp;kol, &amp;grn, &amp;new);
   if (kol &lt; 0) goto all;

   for (ii=1; ii&lt;=kol; ++ii) {
      printf ("Px[%d], Py[%d] = ? ", ii, ii);
      scanf  ("%d%d", &amp;Px[ii], &amp;Py[ii]);
   }

m2:
   setbkcolor(0);       /* Очистка экрана */
   cleardevice();

/* Заливка */
   V_FP1 (new, kol, Px, Py);

/* Построение границы */
   setcolor (grn);
   for (ii= 1; ii&lt;kol; ++ii)
      line (Px[ii], Py[ii], Px[ii+1], Py[ii+1]);
   line (Px[kol], Py[kol], Px[1], Py[1]);

/* При первом входе строится квадратик дырки */
   if (!entry) {
      for (ii=kol+1; ii&lt;kol+4; ++ii)
         line (Px[ii], Py[ii], Px[ii+1], Py[ii+1]);
      line (Px[kol+4], Py[kol+4], Px[kol+1], Py[kol+1]);
   }

   goto m1;

all:
   closegraph();
}
</PRE>
<CENTER>
<H3><A name=tth_sEc0.17>0.17</A>&nbsp;&nbsp;Приложение 6. Процедуры заливки 
области</H3></CENTER>
<P>В данном приложении приведены три процедуры заливки гранично-определенной 
области с затравкой. 
<P>Первая процедура - V_FAB4R реализует рекурсивный алгоритм заполнения для 4-х 
связной области соответствующий алгоритму, помещенному в [<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#mbib4" name=CITEmbib4>4</A>]. 
<P>Вторая процедура - V_FAB4 реализует итеративный алгоритм заполнения для 4-х 
связной области близкий к алгоритму, помещенному в [<A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#mbib3" name=CITEmbib3>3</A>]. 
<P>Характерная особенность таких алгоритмов - очень большие затраты памяти под 
рабочий стек и многократное дублирование занесения пикселов. Характерные 
значения для размера стека (см. ниже определение константы MAX_STK) около десяти 
тысяч байт при размере порядка 70&times;70 пикселов и очень сильно зависят от размеров 
заливаемой области, ее конфигурации и выбора начальной точки. Так, например, для 
заливки квадрата со стороной, равной 65 дискретам, и старте заливки из точки 
(20,20) относительно угла квадрата требуется 7938 байт для стека. 
<P>Третья процедура - V_FAST реализует алгоритм построчного заполнения с 
затравкой гранично-определенной области, близкий к соответствующему алгоритму из 
[<A href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#mbib3" name=CITEmbib3>3</A>]. 
Отличительная черта таких алгоритмов - большие объемы программного кода, 
небольшие затраты памяти под рабочий стек и практически отсутствующее 
дублирование занесения пикселов. Характерные значения для размера стека (см. 
ниже определение константы MAX_STK) около сотни байт. 
<P>
<P><BR>
<CENTER>
<H3><A name=tth_sEc0.17.1>0.17.1</A>&nbsp;&nbsp;V_FAB4R - рекурсивная заливка 
4-x связной области</H3></CENTER>
<P><PRE>/*---------------------------------------------------- V_FAB4R
 * Подпрограммы для заливки с затравкой гранично-определенной
 * области 4-х связным алгоритмом:
 *
 * V_FAB4R  - заливка гранично-определенной
 *            области 4-х связным алгоритмом
 */

#include &lt;graphics.h&gt;
#include &lt;stdio.h&gt;

#define MAX_GOR 2048  /* Разрешение дисплея по X */
#define MAX_VER 2048  /* Разрешение дисплея по Y */

static int gor_max= MAX_GOR;
static int ver_max= MAX_VER;

/*---------------------------------------------------- V_FAB4R
 * Заливка гранично-определенной области
 * 4-х связным алгоритмом
 */
void V_FAB4R (grn_pix, new_pix, x_isx, y_isx)
int grn_pix, new_pix, x_isx, y_isx;
{
   if (getpixel (x_isx, y_isx) != grn_pix &amp;&amp;
      getpixel (x_isx, y_isx) != new_pix)
   {
      putpixel (x_isx, y_isx, new_pix);
      V_FAB4R (grn_pix, new_pix, x_isx+1, y_isx);
      V_FAB4R (grn_pix, new_pix, x_isx,   y_isx+1);
      V_FAB4R (grn_pix, new_pix, x_isx-1, y_isx);
      V_FAB4R (grn_pix, new_pix, x_isx,   y_isx-1);
   }
}  /* V_FAB4 */
</PRE>
<P>
<CENTER>
<H3><A name=tth_sEc0.17.2>0.17.2</A>&nbsp;&nbsp;Тест процедуры 
V_FAB4R</H3></CENTER>
<P><PRE>/*-------------------------------------------------- FAB4_MAIN
 */
void main (void)
{
   int   ii, kol, grn, new, entry;
   int   x_isx, y_isx;
   int   gdriver = DETECT, gmode;
   int   Px[256] = {200,200,250,270,270,210,210,230,230};
   int   Py[256] = {200,250,250,230,200,210,230,230,210};

   kol= 5;              /* Кол-во вершин        */
   grn= 11;             /* Код пикселов границы */
   new= 14;             /* Код заливки          */
   x_isx= 240;          /* Координаты затравки  */
   y_isx= 240;
   entry= 0;

   initgraph(&amp;gdriver, &amp;gmode, "c:\tc\bgi");
   if ((ii= graphresult()) != grOk) {
      printf ("Err=%d\n", ii); goto all;
   }

m0:goto m2;
m1:++entry;
   printf("Vertexs, boundary_pixel, new_pixel= (%d %d %d) ? ",
            kol, grn, new);
   scanf ("%d%d%d", &amp;kol, &amp;grn, &amp;new);
   if (kol &lt; 0) goto all;

   for (ii=0; ii&lt;kol; ++ii) {
      printf ("Px[%d], Py[%d] = ? ", ii, ii);
      scanf  ("%d%d", &amp;Px[ii], &amp;Py[ii]);
   }

   printf ("X,Y isx= (%d %d) ? ", x_isx, y_isx);
   scanf ("%d%d", &amp;x_isx, &amp;y_isx);

m2:
   setbkcolor(0);
   cleardevice();

/* Построение границы */
   setcolor (grn);
   for (ii= 0; ii&lt;kol-1; ++ii)
      line (Px[ii], Py[ii], Px[ii+1], Py[ii+1]);
   line (Px[kol-1], Py[kol-1], Px[0], Py[0]);

/* При первом входе строится квадратик дырки */
   if (!entry) {
      for (ii= kol; ii&lt;kol+3; ++ii)
         line (Px[ii], Py[ii], Px[ii+1], Py[ii+1]);
      line (Px[kol+3], Py[kol+3], Px[kol], Py[kol]);
   }

/* Заливка */
   V_FAB4R (grn, new, x_isx, y_isx);
   goto m1;
all:
   closegraph();
}
</PRE>
<P>
<P><BR>
<CENTER>
<H3><A name=tth_sEc0.17.3>0.17.3</A>&nbsp;&nbsp;V_FAB4 - итеративная заливка 4-x 
связной области</H3></CENTER>
<P><PRE>/*----------------------------------------------------- V_FAB4
 * Подпрограммы для заливки с затравкой гранично-определенной
 * области 4-х связным алгоритмом:
 *
 * Pop_Stk  - Локальная подпрограмма. Извлекает координаты
 *            пиксела из стека в глобальные скаляры xtek, ytek
 *
 * Push_Stk - Локальная подпрограмма. Заносит координаты
 *            пиксела в стек
 *
 * V_FAB4   - собственно заливка гранично-определенной
 *            области 4-х связным алгоритмом
 *
 * V_FA_SET - устанавливает количественные ограничения
 *            для заливки
 */

#include &lt;alloc.h&gt;
#include &lt;graphics.h&gt;
#include &lt;stdio.h&gt;

#define MAX_GOR 2048  /* Разрешение дисплея по X */
#define MAX_VER 2048  /* Разрешение дисплея по Y */
#define MAX_STK 8192  /* Размер стека координат заливки */

static int gor_max= MAX_GOR;
static int ver_max= MAX_VER;
static int stk_max= MAX_STK;
static int *pi_stk, *pn_stk;   /* Указ  стека заливки */
static int xtek, ytek;         /* Координаты из стека */
static int stklen;             /* Достигнутая глубина стека*/
                               /* только для отладочных    */
                               /* измерений программы      */

/*---------------------------------------------------- Pop_Stk
 * Извлекает координаты пиксела из стека в xtek, ytek
 * Возвращает 0/1 - нет/есть ошибки
 */
static int  Pop_Stk ()
{  register int  otw;
   otw= 0;
   if (pi_stk &lt;= pn_stk) ++otw; else {
      ytek= *--pi_stk;  xtek= *--pi_stk;
   }
   return (otw);
}  /* Pop_Stk */

/*--------------------------------------------------- Push_Stk
 * Заносит координаты пиксела в стек
 * Возвращает -1/0 - нет места под стек/норма
 */
static int  Push_Stk (x, y)
register int x, y;
{
   register int glu;
   if ((glu= pi_stk - pn_stk) &gt;= stk_max) x= -1; else {
      *pi_stk++= x;  *pi_stk++= y; x= 0;
      if (glu &gt; stklen) stklen= glu;
   }
   return (x);
}  /* Push_Stk */
</PRE>
<P>
<P><BR><PRE>/*----------------------------------------------------- V_FAB4
 * Заливка гранично-определенной области
 * 4-х связным алгоритмом
 * Возвращает:
 * -1 - нет места под стек
 *  0 - норма
 */
int V_FAB4 (grn_pix, new_pix, x_isx, y_isx)
int grn_pix, new_pix, x_isx, y_isx;
{
   register int  pix, x, y, otw;

   otw= 0;

/* Инициализация стека */
   if ((pn_stk= (int *)malloc (stk_max)) == NULL) {
      --otw;  goto all;
   }
   pi_stk= pn_stk;

   Push_Stk (x_isx, y_isx);     /* Затравку в стек */

   while (pn_stk &lt; pi_stk) {    /* Пока не исчерпан стек */
/* Выбираем пиксел из стека и красим его */
      Pop_Stk ();
      if (getpixel (x= xtek, y= ytek) != new_pix)
          putpixel (x, y, new_pix);

/* Проверяем соседние пикселы на необходимость закраски */
      if ((pix= getpixel (++x, y))   != new_pix &amp;&amp;
           pix != grn_pix) otw= Push_Stk (x, y);

      if ((pix= getpixel (--x, ++y)) != new_pix &amp;&amp;
           pix != grn_pix) otw= Push_Stk (x, y);

      if ((pix= getpixel (--x, --y)) != new_pix &amp;&amp;
           pix != grn_pix) otw= Push_Stk (x, y);

      if ((pix= getpixel (++x, --y)) != new_pix &amp;&amp;
           pix != grn_pix) otw= Push_Stk (x, y);
      if (otw) break;
   }
all:
   free (pn_stk);
   return (otw);
}  /* V_FAB4 */
</PRE>
<P>
<P><BR><PRE>/*--------------------------------------------------- V_FA_SET
 * Устанавливает количественные ограничения для заливки
 */
void V_FA_SET (x_resolution, y_resolution, stack_length)
int  x_resolution, y_resolution, stack_length;
{
   if (x_resolution &gt; 0 &amp;&amp; x_resolution &lt;= MAX_GOR)
      gor_max= x_resolution;
   if (y_resolution &gt; 0 &amp;&amp; y_resolution &lt;= MAX_VER)
      ver_max= y_resolution;
/* Кол байт координат, заносимых в стек м.б. только четным */
   if (stack_length &gt; 0) stk_max= stack_length &amp; 0177776;
}  /* V_FA_SET */
</PRE>
<P>
<P><BR>
<CENTER>
<H3><A name=tth_sEc0.17.4>0.17.4</A>&nbsp;&nbsp;Тест процедуры 
V_FAB4</H3></CENTER>
<P><PRE>/*-------------------------------------------------- FAB4_MAIN
 */
void main (void)
{
   int   ii, kol, grn, new, entry;
   int   x_isx, y_isx;
   int   gdriver = DETECT, gmode;
   int   Px[256] = {200,200,250,270,270,210,210,230,230};
   int   Py[256] = {200,250,250,230,200,210,230,230,210};

   kol= 5;              /* Кол-во вершин        */
   grn= 11;             /* Код пикселов границы */
   new= 14;             /* Код заливки          */
   x_isx= 240;          /* Координаты затравки  */
   y_isx= 240;
   entry= 0;

   initgraph(&amp;gdriver, &amp;gmode, "c:\tc\bgi");
   if ((ii= graphresult()) != grOk) {
      printf ("Err=%d\n", ii); goto all;
   }

m0:goto m2;
m1:++entry;
   printf("Vertexs, boundary_pixel, new_pixel= (%d %d %d) ? ",
            kol, grn, new);
   scanf ("%d%d%d", &amp;kol, &amp;grn, &amp;new);
   if (kol &lt; 0) goto all;

   for (ii=0; ii&lt;kol; ++ii) {
      printf ("Px[%d], Py[%d] = ? ", ii, ii);
      scanf  ("%d%d", &amp;Px[ii], &amp;Py[ii]);
   }

   printf ("X,Y isx= (%d %d) ? ", x_isx, y_isx);
   scanf ("%d%d", &amp;x_isx, &amp;y_isx);

m2:
   setbkcolor(0);
   cleardevice();

/* Построение границы */
   setcolor (grn);
   for (ii= 0; ii&lt;kol-1; ++ii)
      line (Px[ii], Py[ii], Px[ii+1], Py[ii+1]);
   line (Px[kol-1], Py[kol-1], Px[0], Py[0]);

/* При первом входе строится квадратик дырки */
   if (!entry) {
      for (ii= kol; ii&lt;kol+3; ++ii)
         line (Px[ii], Py[ii], Px[ii+1], Py[ii+1]);
      line (Px[kol+3], Py[kol+3], Px[kol], Py[kol]);
   }

/* Установка количественных ограничений для проц заливки */
   V_FA_SET (getmaxx()+1, getmaxy()+1, MAX_STK);

   stklen= 0;           /* Занятое кол-во байт в стеке */

/* Заливка */
   ii= V_FAB4 (grn, new, x_isx, y_isx);
   printf ("Answer= %d MaxStack=%d\n", ii, stklen);
   goto m1;

all:
   closegraph();
}
</PRE>
<P>
<CENTER>
<H3><A name=tth_sEc0.17.5>0.17.5</A>&nbsp;&nbsp;V_FAST - построчная заливка 
области</H3></CENTER>
<P><PRE>/*----------------------------------------------------- V_FAST
 * Подпрограммы заливки области с затравкой
 * построчным алгоритмом:
 *
 * Pop_Stk   - Локальная подпрограмма. Извлекает координаты
 *             пиксела из стека в глобальные скаляры xtek,ytek
 *
 * Push_Stk  - Локальная подпрограмма. Заносит координаты
 *             пиксела в стек
 *
 * Get_Video - Локальная подпрограмма. Читает строку из
 *             видеопамяти в глобальный буфер строки.
 *
 * Put_Video - Локальная подпрограмма. Копирует байты из
 *             глобального буфера строки в видеопамять.
 *
 * Search    - Локальная подпрограмма. Ищет затравочные
 *             пикселы в строке видеопамяти, находящейся
 *             в глобальном массиве.
 *
 * V_FAST    - Собственно подпрограмма построчной заливки
 *             гранично-определенной области
 *
 * V_FA_SET  - Устанавливает количественные ограничения
 *            для заливки
 */

#include &lt;alloc.h&gt;
#include &lt;graphics.h&gt;
#include &lt;stdio.h&gt;

#define MAX_GOR 2048  /* Разрешение дисплея по X */
#define MAX_VER 2048  /* Разрешение дисплея по Y */
#define MAX_STK 8192  /* Размер стека координат заливки */

static int gor_max= MAX_GOR;
static int ver_max= MAX_VER;
static int stk_max= MAX_STK;
static int *pi_stk, *pn_stk;   /* Указ  стека заливки */
static int xtek, ytek;         /* Координаты из стека */
static char *pc_video;         /* Указ на буфер строки */
static int stklen;             /* Достигнутая глубина стека*/
                               /* только для отладочных    */
                               /* измерений программы      */


/*---------------------------------------------------- Pop_Stk
 * Извлекает координаты пиксела из стека в xtek, ytek
 * Возвращает 0/1 - нет/есть ошибки
 */
static int  Pop_Stk ()
{  register int  otw;
   otw= 0;
   if (pi_stk &lt;= pn_stk) ++otw; else {
      ytek= *--pi_stk;  xtek= *--pi_stk;
   }
   return (otw);
}  /* Pop_Stk */

/*--------------------------------------------------- Push_Stk
 * Заносит координаты пиксела в стек
 * Возвращает -1/0 - нет места под стек/норма
 */
static int  Push_Stk (x, y)
register int x, y;
{
   register int glu;
   if ((glu= pi_stk - pn_stk) &gt;= stk_max) x= -1; else {
      *pi_stk++= x;  *pi_stk++= y; x= 0;
      if (glu &gt; stklen) stklen= glu;
   }
   return (x);
}  /* Push_Stk */

/*-------------------------------------------------- Get_Video
 * В байтовый буфер строки, заданный глобальным
 * указателем pc_video,
 * читает из видеопамяти пикселы y-строки от xbg до xen
 * Возвращает 0/1 - нет/есть ошибки
 */
static int  Get_Video (y, pcxbg, pcxen)
int y;  register char *pcxbg, *pcxen;
{  register int x;

   if (y&gt;=0 &amp;&amp; y&lt;ver_max &amp;&amp; pcxbg&lt;=pcxen) {
      x= pcxbg - pc_video;
      do *pcxbg++= getpixel (x++, y); while (pcxbg &lt;= pcxen);
      y= 0;
   } else y= 1;
   return (y);
}  /* Get_Video */

/*-------------------------------------------------- Put_Video
 * Пикселы из буфера строки, начиная от указателя pxbg,
 * до указателя pxen пишет в y-строку видеопамяти
 * Возвращает 0/1 - нет/есть ошибки
 */
static int  Put_Video (y, pxbg, pxen)
int y;  register char *pxbg, *pxen;
{  register int  x;
   if (y&gt;=0 &amp;&amp; y&lt;ver_max &amp;&amp; pxbg&lt;=pxen) {
      x= pxbg - pc_video;
      do putpixel (x++, y, *pxbg++); while (pxbg &lt;= pxen);
      y= 0;
   } else y= 1;
   return (y);
}  /* Put_Video */

/*----------------------------------------------------- Search
 * Ищет затравочные пикселы в yt-строке видеопамяти,
 * находящейся по указателю pc_video, начиная от
 * указателя pcl до указателя pcr
 * grn - код граничного пиксела
 * new - код, которым перекрашивается область
 * Возвращает: 0/1 - не найден/найден затравочный
 */
static int  Search (yt, pcl, pcr, grn, new)
int yt;  char *pcl, *pcr;  int grn, new;
{  register int pix;
   register char *pc;
   int x, otw;

   otw= 0;
   while (pcl &lt;= pcr) {
      pc= pcl;                          /* Указ тек пиксела */
/* Поиск крайнего правого не закрашенного пиксела в строке */
      while ((pix= *pc &amp; 255) != grn &amp;&amp; pix != new &amp;&amp; pc&lt;pcr)
         ++pc;

      if (pc != pcl) {          /* Найден закрашиваемый */
         ++otw;
         x= pc - pc_video;      /* Его координата в строке */
         if (pc != pcr || pix == grn || pix == new) --x;
         Push_Stk (x, yt);
      }
/* Продолжение анализа строки пока не достигнут прав пиксел */
      pcl= pc;
      while (((pix= *pc &amp; 255) == grn || pix==new) &amp;&amp; pc&lt;pcr)
         ++pc;
      if (pc == pcl) ++pc;
      pcl= pc;
   }
   return (otw);
}  /* Search */
</PRE>
<P>
<P><BR><PRE>/*----------------------------------------------------- V_FAST
 * Построчная заливка с затравкой гранично-определенной
 * области
 *
 * int V_FAST (int grn_pix, int new_pix, int x_isx, int y_isx)
 *
 * Вход:
 * grn_pix - код граничного пиксела
 * new_pix - код заполняющего пиксела
 * x_isx   - координаты затравки
 * y_isx
 *
 * Возвращает:
 * -2 - нет места под растровую строку
 * -1 - нет места под стек
 *  0 - норма
 *  1 - при чтении пикселов из видеопамяти в буферную
 *      строки выход за пределы буферной строки
 *  2 - исчерпан стек при запросе координат пикселов
 *
 */
int V_FAST (grn_pix, new_pix, x_isx, y_isx)
int grn_pix, new_pix, x_isx, y_isx;
{
   register char *pcl;    /* Указ левого  пиксела в строке */
   register char *pcr;    /* Указ правого пиксела в строке */
   int  otw;

   otw= 0;

/* Инициализация стека */
   if ((pn_stk= (int *)malloc (stk_max)) == NULL) {
      --otw;  goto all;
   }
   pi_stk= pn_stk;

/* Заказ массива под растровую строку */
   if ((pc_video= malloc (gor_max)) == NULL) {
      otw= -2;  goto fre_stk;
   }

   Push_Stk (x_isx, y_isx);     /* Затравку в стек */

/* Цикл заливки строк до исчерпания стека */

   while (pi_stk &gt; pn_stk) {

/* Запрос координат затравки из стека */
      if (Pop_Stk ()) {otw=2; break; }
      pcl= pcr= pc_video + xtek;   /* Указ затравки */

/* Запрос полной строки из видеопамяти */
      if (Get_Video (ytek, pc_video, pc_video+gor_max-1))
         {otw= 1;  break; }

/* Закраска затравки и вправо от нее */
      do *pcr++= new_pix; while ((*pcr &amp; 255) != grn_pix);
      --pcr;                    /* Указ крайнего правого */

/* Закраска влево */
      while ((*--pcl &amp; 255) != grn_pix) *pcl= new_pix;
      ++pcl;                    /* Указ крайнего левого */

/* Занесение подправленной строки в видеопамять */
      Put_Video (ytek, pcl, pcr);

/* Поиск затравок в строках ytek+1 и ytek-1,
 * начиная с левого подинтервала, заданного pcl, до
 * правого подинтервала, заданного pcr
 */
      if (!Get_Video (++ytek, pcl, pcr))
         Search (ytek, pcl, pcr, grn_pix, new_pix);

      if (!Get_Video (ytek-= 2, pcl, pcr))
         Search (ytek, pcl, pcr, grn_pix, new_pix);
   }
   free (pc_video);
fre_stk:
   free (pn_stk);
all:
   return (otw);
}  /* V_FAST */
</PRE>
<P>
<P><BR><PRE>/*--------------------------------------------------- V_FA_SET
 * Устанавливает количественные ограничения для заливки
 */
void V_FA_SET (x_resolution, y_resolution, stack_length)
int  x_resolution, y_resolution, stack_length;
{
   if (x_resolution &gt; 0 &amp;&amp; x_resolution &lt;= MAX_GOR)
      gor_max= x_resolution;
   if (y_resolution &gt; 0 &amp;&amp; y_resolution &lt;= MAX_VER)
      ver_max= y_resolution;
/* Кол байт координат, заносимых в стек м.б. только четным */
   if (stack_length &gt; 0) stk_max= stack_length &amp; 0177776;
}  /* V_FA_SET */
</PRE>
<P>
<CENTER>
<H3><A name=tth_sEc0.17.6>0.17.6</A>&nbsp;&nbsp;Тест процедуры 
V_FAST</H3></CENTER>
<P><PRE>/*-------------------------------------------------- FAST_MAIN
 */
void main (void)
{
   int   ii, kol, grn, new, entry;
   int   x_isx, y_isx;
   int   gdriver = DETECT, gmode;
   int   Px[256] = {200,200,250,270,270,210,210,230,230};
   int   Py[256] = {200,250,250,230,200,210,230,230,210};

   kol= 5;              /* Кол-во вершин        */
   grn= 11;             /* Код пикселов границы */
   new= 14;             /* Код заливки          */
   x_isx= 240;          /* Координаты затравки  */
   y_isx= 240;
   entry= 0;

   initgraph(&amp;gdriver, &amp;gmode, "c:\tc\bgi");
   if ((ii= graphresult()) != grOk) {
      printf ("Err=%d\n", ii); goto all;
   }

m0:goto m2;
m1:++entry;
   printf("Vertexs, boundary_pixel, new_pixel= (%d %d %d) ? ",
            kol, grn, new);
   scanf ("%d%d%d", &amp;kol, &amp;grn, &amp;new);
   if (kol &lt; 0) goto all;

   for (ii=0; ii&lt;kol; ++ii) {
      printf ("Px[%d], Py[%d] = ? ", ii, ii);
      scanf  ("%d%d", &amp;Px[ii], &amp;Py[ii]);
   }

   printf ("X,Y isx= (%d %d) ? ", x_isx, y_isx);
   scanf ("%d%d", &amp;x_isx, &amp;y_isx);

m2:
   setbkcolor(0);
   cleardevice();

/* Построение границы */
   setcolor (grn);
   for (ii= 0; ii&lt;kol-1; ++ii)
      line (Px[ii], Py[ii], Px[ii+1], Py[ii+1]);
   line (Px[kol-1], Py[kol-1], Px[0], Py[0]);

/* При первом входе строится квадратик дырки */
   if (!entry) {
      for (ii= kol; ii&lt;kol+3; ++ii)
         line (Px[ii], Py[ii], Px[ii+1], Py[ii+1]);
      line (Px[kol+3], Py[kol+3], Px[kol], Py[kol]);
   }

/* Установка количественных ограничений для проц заливки */
   V_FA_SET (getmaxx()+1, getmaxy()+1, MAX_STK);

   stklen= 0;           /* Занятое кол-во байт в стеке */

/* Заливка */
   ii= V_FAST (grn, new, x_isx, y_isx);
   printf ("Answer= %d MaxStack=%d\n", ii, stklen);
   goto m1;

all:
   closegraph();
}
</PRE>
<CENTER>
<H3><A name=tth_sEc0.18>0.18</A>&nbsp;&nbsp;Приложение 7. Процедуры отсечения 
отрезка</H3></CENTER>
<P>В данном приложении приведены процедуры, обеспечивающие выполнение отсечения 
по прямоугольному и многоугольному выпуклому окну и тестовая программа проверки 
работы процедур отсечения. 
<P><PRE>/*=================================================== V_CLIP.C
 *
 * Подрограммы, связанные с отсечением:
 *
 * V_SetPclip - установить размеры многоугольного окна
 *              отсечения
 * V_SetRclip - установить размеры прямоугольного окна
 *              отсечения
 * V_GetRclip - опросить   размеры прямоугольного окна
 *              отсечения
 * V_CSclip   - отсечение по алгоритму Коэна-Сазерленда
 *              прямоугольное окно, кодирование
 *              концов отсекаемого отрезка
 * V_FCclip   - отсечение по алгоритму быстрого отсечения
 *              Алгоритм Собкова-Поспишила-Янга -
 *              прямоугольное окно, кодирование
 *              отсекаемого отрезка
 * V_LBclip   - отсечение по алгоритму Лианга-Барски
 *              прямоугольное окно, параметрическое
 *              представление линий
 * V_CBclip   - отсечение по алгоритму Кируса-Бека
 *              окно - выпуклый многоугольник,
 *              параметрическое представление линий
 */


/* Глобальные скаляры для алгоритмов отсечения по
 * прямоугольному окну - Коэна-Сазерленда, Fc-алгоритм,
 * Лианга-Барски
 */
static float Wxlef= 0.0,   /* Координаты левого нижнего и */
             Wybot= 0.0,   /* правого верхнего углов окна */
             Wxrig= 7.0,   /* отсечения                   */
             Wytop= 5.0;

/* Глобальные скаляры для алгоритма Кируса-Бека
 * отсечения по многоугольному окну
 */

/* Координаты прямоугольного окна */
static float Wxrect[4]= {0.0, 0.0, 7.0, 7.0 };
static float Wyrect[4]= {0.0, 5.0, 5.0, 0.0 };

/* Перепендикуляры к сторонам прямоугольного окна */
static float WxNrec[4]= {1.0,  0.0, -1.0, 0.0 };
static float WyNrec[4]= {0.0, -1.0,  0.0, 1.0 };

/* Данные для многоугольного окна */
static int   Windn=4;          /* Кол-во вершин у окна   */
static float *Windx=  Wxrect,  /* Координаты вершин окна */
             *Windy=  Wyrect;
static float *Wnormx= WxNrec,  /* Координаты нормалей    */
             *Wnormy= WyNrec;
</PRE>
<P>
<CENTER>
<H3><A name=tth_sEc0.18.1>0.18.1</A>&nbsp;&nbsp;V_SetPclip - установить 
многоугольник отсечения</H3></CENTER>
<P><PRE>/*------------------------------------------------- V_SetPclip
 * Устанавливает многоугольное окно отсечения
 * kv - количество вершин в окне
 * wx - X-координаты вершин
 * wy - Y-координаты вершин
 * nx - X-координаты нормалей к ребрам
 * ny - Y-координаты нормалей к ребрам
 *
 * Проверяет окно на выпуклость и невырожденность
 *
 * Если окно правильное, то
 * 1. Обновляет глобалы описания многоугольного окна:
 *    Windn=  kv;
 *    Windx=  wx;  Windy=  wy;  --Координаты вершин окна
 *    Wnormx= nx;  Wnormy= ny;  --Координаты перпендикуляров
 *
 * 2. Вычисляет координаты перепендикуляров к сторонам окна
 *
 * Возвращает:
 * 0 - норма
 * 1 - вершин менее трех
 * 2 - многоугольник вырожден в отрезок
 * 3 - многоугольник невыпуклый
 */

int  V_SetPclip (kv, wx, wy, nx, ny)
int  kv;  float *wx, *wy, *nx, *ny;
{  int   ii, jj, sminus, splus, szero, otw;
   float r,
         vox, voy,      /* Координаты (i-1)-й вершины */
         vix, viy,      /* Координаты i-й     вершины */
         vnx, vny;      /* Координаты (i+1)-й вершины */

/* Проверка на выпуклость
 * для этого вычисляются векторные произведения
 * смежных сторон и определяется знак
 * если все знаки == 0 то многоугольник вырожден
 * если все знаки &gt;= 0 то многоугольник выпуклый
 * если все знаки &lt;= 0 то многоугольник невыпуклый
 */
   otw= 0;
   if (--kv &lt; 2) {++otw; goto all; }
   sminus= 0;
   splus=  0;
   szero=  0;
   vox= wx[kv];  voy= wy[kv];
   vix= *wx;     viy= *wy;
   ii= 0;
   do {
      if (++ii &gt; kv) ii= 0;           /* Следующая  вершина */
      vnx= wx[ii];  vny= wy[ii];      /* Координаты (i+1)-й */
      r= (vix-vox)*(vny-viy) -        /* Вект произв ребер  */
         (viy-voy)*(vnx-vix);         /* смежных с i-й верш */
      if (r &lt; 0) ++sminus; else
      if (r &gt; 0) ++splus;  else ++szero;
      vox= vix;  voy= viy;            /* Обновлен координат */
      vix= vnx;  viy= vny;
   }  while (ii);

   if (!splus &amp;&amp; !sminus)       /* Все векторные равны нулю */
      {otw= 2; goto all; }      /* Многоугольник вырожден   */
   if (splus &amp;&amp; sminus)         /* Знакопеременн. векторные */
      {otw= 3; goto all; }      /* Многоугольник невыпуклый */

/* Установление глобалов для правильного окна */
   Windn= kv+1;                 /* Количество вершин у окна */
   Windx=  wx;  Windy=  wy;     /* Координаты вершин окна   */
   Wnormx= nx;  Wnormy= ny;     /* Координ. перпендикуляров */

/* Вычисление координат перпендикуляров к сторонам */

   vox= *wx; voy= *wy;
   ii= 0;
   do {
      if (++ii &gt; kv) ii= 0;
      vix= wx[ii];  viy= wy[ii];     /* Текущая вершина */
      vnx= viy-voy; vny= vox-vix;    /* Поворот по часовой  */
      if (splus) {                   /* Внутр нормали влево */
         vnx= -vnx; vny= -vny;
      }
      *nx++= vnx;  *ny++= vny;
      vox= vix;  voy= viy;          /* Обновление координат */
   } while (ii);

all:
   return (otw);
}  /* V_SetPclip */
</PRE>
<P>
<CENTER>
<H3><A name=tth_sEc0.18.2>0.18.2</A>&nbsp;&nbsp;V_SetRclip - установить 
прямоугольник отсечения</H3></CENTER>
<P><PRE>/*------------------------------------------------- V_SetRclip
 * Устанавливает прямоугольное окно отсечения
 * Возвращает 0/1 - нет/есть ошибки в задании окна
 */
int  V_SetRclip (xleft, ybottom, xright, ytop)
float xleft, ybottom, xright, ytop;
{  int  otw;
   otw= 0;
   if (xleft &gt;= xright || ybottom &gt;= ytop) ++otw; else {
      Windn= 4;
      Windx= Wxrect;  Windy= Wyrect;         /* Вершины */
      Wxlef= Wxrect[0]= Wxrect[1]= xleft;
      Wybot= Wyrect[0]= Wyrect[3]= ybottom;
      Wxrig= Wxrect[2]= Wxrect[3]= xright;
      Wytop= Wyrect[1]= Wyrect[2]= ytop;
      Wnormx= WxNrec; Wnormy= WyNrec;        /* Нормали */
      WxNrec[0]=  1;  WyNrec[0]=  0;
      WxNrec[1]=  0;  WyNrec[1]= -1;
      WxNrec[2]= -1;  WyNrec[2]=  0;
      WxNrec[3]=  0;  WyNrec[3]=  1;
   }
   return (otw);
}  /* V_SetRclip */
</PRE>
<P>
<P><BR>
<CENTER>
<H3><A name=tth_sEc0.18.3>0.18.3</A>&nbsp;&nbsp;V_GetRclip - опросить 
прямоугольник отсечения</H3></CENTER>
<P><PRE>/*------------------------------------------------- V_GetRclip
 * Возвращает текущее прямоугольное окно отсечения
 */
void V_GetRclip (xleft, ybottom, xright, ytop)
float *xleft, *ybottom, *xright, *ytop;
{
   *xleft=  Wxlef;  *ybottom= Wybot;
   *xright= Wxrig;  *ytop= Wytop;
}  /* V_GetRclip */
</PRE>
<P>
<P><BR>
<CENTER>
<H3><A name=tth_sEc0.18.4>0.18.4</A>&nbsp;&nbsp;V_CSclip - отсечение 
Коэна-Сазерленда</H3></CENTER>
<P><PRE>/*--------------------------------------------------- V_CSclip
 * Реализует алгоритм отсечения Коэна-Сазерленда с
 * кодированием концов отсекаемого отрезка
 *
 * int  V_CSclip (float *x0, float *y0, float *x1, float *y1)
 *
 * Отсекает отрезок, заданный значениями координат его
 * точек (x0,y0), (x1,y1), по окну отсечения, заданному
 * глобальными скалярами Wxlef, Wybot, Wxrig, Wytop
 *
 * Конечным точкам отрезка приписываются коды,
 * характеризующие его положение относительно окна отсечения
 * по правилу:
 *
 *  1001 | 1000 | 1010
 *  -----|------|-----
 *       | Окно |
 *  0001 | 0000 | 0010
 *  -----|------|-----
 *  0101 | 0100 | 0110
 *
 *  Отрезок целиком видим если оба его конца имеют коды 0000
 *  Если логическое И кодов концов не равно 0, то отрезок
 *  целиком вне окна и он просто отбрасывается.
 *  Если же результат этой операции = 0, то отрезок
 *  подозрительный. Он может быть и вне и пересекать окно.
 *  Для подозрительных отрезков определяются координаты их
 *  пересечений с теми сторонами, с которыми они могли бы
 *  пересечься в соответствии с кодами концов.
 *  При этом используется горизонтальность и вертикальность
 *  сторон окна, что позволяет определить одну из координат
 *  без вычислений.
 *  Часть отрезка, оставшаяся за окном отбрасывается.
 *  Оставшаяся часть отрезка проверяется на возможность его
 *  принятия или отбрасывания целиком. Если это невозможно,
 *  то процесс повторяется для другой стороны окна.
 *  На каждом цикле вычислений конечная точка отрезка,
 *  выходившая за окно, заменяется на точку, лежащую или на
 *  стороне окна или его продолжении.
 *
 *  Вспомогательная процедура Code вычисляет код положения
 *  для конца отрезка.
 *
 */
</PRE>
<P>
<P><BR><PRE>static float  CSxn, CSyn;   /* Координаты начала отрезка */

static int  CScode (void)  /* Определяет код точки xn, yn */
{  register int  i;
   i= 0;
   if (CSxn &lt; Wxlef) ++i; else
   if (CSxn &gt; Wxrig) i+= 2;
   if (CSyn &lt; Wybot) i+= 4; else
   if (CSyn &gt; Wytop) i+= 8;
   return (i);
}  /* CScode */
</PRE>
<P>
<P><BR><PRE>int   V_CSclip (x0, y0, x1, y1)
float *x0, *y0, *x1, *y1;
{
   float  CSxk, CSyk;   /* Координаты конца отрезка  */
   int    cn, ck,       /* Коды концов отрезка */
          visible,      /* 0/1 - не видим/видим*/
          ii, s;        /* Рабочие переменные  */
   float  dx, dy,       /* Приращения координат*/
          dxdy,dydx,    /* Наклоны отрезка к сторонам */
          r;            /* Рабочая переменная  */

   CSxk= *x1; CSyk= *y1;
   CSxn= *x1; CSyn= *y1; ck= CScode ();
   CSxn= *x0; CSyn= *y0; cn= CScode ();

/* Определение приращений координат и наклонов отрезка
 * к осям. Заодно сразу на построение передается отрезок,
 * состоящий из единственной точки, попавшей в окно
 */
   dx= CSxk - CSxn;
   dy= CSyk - CSyn;
   if (dx != 0) dydx= dy / dx; else {
      if (dy == 0) {
         if (cn==0 &amp;&amp; ck==0) goto out; else goto all;
      }
   }
   if (dy != 0) dxdy= dx / dy;

/* Основной цикл отсечения */
   visible= 0;  ii= 4;
   do {
      if (cn &amp; ck) break;       /* Целиком вне окна    */
      if (cn == 0 &amp;&amp; ck == 0) { /* Целиком внутри окна */
         ++visible;  break;
      }
      if (!cn) {                /* Если Pn внутри окна, то */
         s= cn; cn= ck; ck= s;  /* перестить точки Pn,Pk и */
         r=CSxn; CSxn=CSxk; CSxk=r;  /* их коды, чтобы Pn  */
         r=CSyn; CSyn=CSyk; CSyk=r;  /* оказалась вне окна */
      }
      /* Теперь отрезок разделяется. Pn помещается в точку
       * пересечения отрезка со стороной окна.
       */
      if (cn &amp; 1) {         /* Пересечение с левой стороной */
         CSyn= CSyn + dydx * (Wxlef-CSxn);
         CSxn= Wxlef;
      } else if (cn &amp; 2) {  /* Пересечение с правой стороной*/
         CSyn= CSyn + dydx * (Wxrig-CSxn);
         CSxn= Wxrig;
      } else if (cn &amp; 4) {  /* Пересечение в нижней стороной*/
         CSxn= CSxn + dxdy * (Wybot-CSyn);
         CSyn= Wybot;
      } else if (cn &amp; 8) {  /*Пересечение с верхней стороной*/
         CSxn= CSxn + dxdy * (Wytop-CSyn);
         CSyn= Wytop;
      }
      cn= CScode ();        /* Перевычисление кода точки Pn */
   } while (--ii &gt;= 0);
   if (visible) {
out:  *x0= CSxn;  *y0= CSyn;
      *x1= CSxk;  *y1= CSyk;
   }
all:
   return (visible);
}  /* V_CSclip */
</PRE>
<P>
<P><BR>
<CENTER>
<H3><A name=tth_sEc0.18.5>0.18.5</A>&nbsp;&nbsp;V_FCclip - Fast 
Clipping-алгоритм</H3></CENTER>
<P><PRE>/*--------------------------------------------------- V_FCclip
 *  Реализует алгоритм отсечения FC (Fast Clipping)
 *  Собкова-Поспишила-Янга, с кодированием линий
 *
 * int  V_FCclip (float *x0, float *y0, float *x1, float *y1)
 *
 * Отсекает отрезок, заданный значениями координат его
 * точек (x0,y0), (x1,y1), по окну отсечения, заданному
 * глобальными скалярами Wxlef, Wybot, Wxrig, Wytop
 *
 * Возвращает:
 * -1 - ошибка в задании окна
 *  0 - отрезок не видим
 *  1 - отрезок видим
 */
</PRE>
<P>
<P><BR><PRE>static float FC_xn, FC_yn, FC_xk, FC_yk;

static void Clip0_Top(void)
{FC_xn= FC_xn + (FC_xk-FC_xn)*(Wytop-FC_yn)/(FC_yk-FC_yn);
 FC_yn= Wytop; }

static void Clip0_Bottom(void)
{FC_xn= FC_xn + (FC_xk-FC_xn)*(Wybot-FC_yn)/(FC_yk-FC_yn);
 FC_yn= Wybot; }

static void Clip0_Right(void)
{FC_yn= FC_yn + (FC_yk-FC_yn)*(Wxrig-FC_xn)/(FC_xk-FC_xn);
 FC_xn= Wxrig; }

static void Clip0_Left(void)
{FC_yn= FC_yn + (FC_yk-FC_yn)*(Wxlef-FC_xn)/(FC_xk-FC_xn);
 FC_xn= Wxlef; }

static void Clip1_Top(void)
{FC_xk= FC_xk + (FC_xn-FC_xk)*(Wytop-FC_yk)/(FC_yn-FC_yk);
 FC_yk= Wytop; }

static void Clip1_Bottom(void)
{FC_xk= FC_xk + (FC_xn-FC_xk)*(Wybot-FC_yk)/(FC_yn-FC_yk);
 FC_yk= Wybot; }

static void Clip1_Right(void)
{FC_yk= FC_yk + (FC_yn-FC_yk)*(Wxrig-FC_xk)/(FC_xn-FC_xk);
 FC_xk= Wxrig; }

static void Clip1_Left(void)
{FC_yk= FC_yk + (FC_yn-FC_yk)*(Wxlef-FC_xk)/(FC_xn-FC_xk);
 FC_xk= Wxlef; }
</PRE>
<P>
<P><BR><PRE>int  V_FCclip (x0, y0, x1, y1)
float *x0, *y0, *x1, *y1;
{  int  Code= 0;
   int  visible= 0;             /* Отрезок невидим */

   FC_xn= *x0;  FC_yn= *y0;
   FC_xk= *x1;  FC_yk= *y1;

/*
 * Вычисление значения Code - кода отрезка
 * Биты 0-3 - для конечной точки, 4-7 - для начальной
 *
 */
   if (FC_yk &gt; Wytop) Code+= 8; else
   if (FC_yk &lt; Wybot) Code+= 4;

   if (FC_xk &gt; Wxrig) Code+= 2; else
   if (FC_xk &lt; Wxlef) Code+= 1;

   if (FC_yn &gt; Wytop) Code+= 128; else
   if (FC_yn &lt; Wybot) Code+= 64;

   if (FC_xn &gt; Wxrig) Code+= 32; else
   if (FC_xn &lt; Wxlef) Code+= 16;

/* Отсечение для каждого из 81-го случаев */

   switch (Code) {

     /* Из центра */

     case 0x00: ++visible;  break;
     case 0x01: Clip1_Left() ;   ++visible;  break;
     case 0x02: Clip1_Right();  ++visible;  break;
     case 0x04: Clip1_Bottom(); ++visible;  break;
     case 0x05: Clip1_Left() ;
                if (FC_yk &lt; Wybot) Clip1_Bottom();
                ++visible;  break;
     case 0x06: Clip1_Right();
                if (FC_yk &lt; Wybot) Clip1_Bottom();
                ++visible;  break;
     case 0x08: Clip1_Top();    ++visible;  break;
     case 0x09: Clip1_Left() ;
                if (FC_yk &gt; Wytop) Clip1_Top();
                ++visible;  break;
     case 0x0A: Clip1_Right();
                if (FC_yk &gt; Wytop) Clip1_Top();
                ++visible;  break;
</PRE>
<P>
<P><BR><PRE>     /* Слева */

     case 0x10: Clip0_Left();   ++visible;
     case 0x11: break;                          /* Отброшен */
     case 0x12: Clip0_Left();   Clip1_Right();
                ++visible;  break;
     case 0x14: Clip0_Left();
                if (FC_yn &lt; Wybot) break;       /* Отброшен */
                Clip1_Bottom();
                ++visible;
     case 0x15: break;                          /* Отброшен */
     case 0x16: Clip0_Left();
                if (FC_yn &lt; Wybot) break;       /* Отброшен */
                Clip1_Bottom();
                if (FC_xk &gt; Wxrig) Clip1_Right();
                ++visible;
                break;
     case 0x18: Clip0_Left();
                if (FC_yn &gt; Wytop) break;       /* Отброшен */
                Clip1_Top();
                ++visible;
     case 0x19: break;                          /* Отброшен */
     case 0x1A: Clip0_Left();
                if (FC_yn &gt; Wytop) break;       /* Отброшен */
                Clip1_Top();
                if (FC_xk &gt; Wxrig) Clip1_Right();
                ++visible;
                break;
</PRE>
<P>
<P><BR><PRE>     /* Справа */

     case 0x20: Clip0_Right(); ++visible;  break;
     case 0x21: Clip0_Right(); Clip1_Left(); ++visible;
     case 0x22: break;                          /* Отброшен */
     case 0x24: Clip0_Right();
                if (FC_yn &lt; Wybot) break;       /* Отброшен */
                Clip1_Bottom();
                ++visible;
                break;
     case 0x25: Clip0_Right();
                if (FC_yn &lt; Wybot) break;       /* Отброшен */
                Clip1_Bottom();
                if (FC_xk &lt; Wxlef) Clip1_Left();
                ++visible;
     case 0x26: break;                          /* Отброшен */
     case 0x28: Clip0_Right();
                if (FC_yn &gt; Wytop) break;       /* Отброшен */
                Clip1_Top();
                ++visible;
                break;
     case 0x29: Clip0_Right();
                if (FC_yn &gt; Wytop) break;       /* Отброшен */
                Clip1_Top();
                if (FC_xk &lt; Wxlef) Clip1_Left();
                ++visible;
     case 0x2A: break;                          /* Отброшен */
</PRE>
<P>
<P><BR><PRE>     /* Снизу */

     case 0x40: Clip0_Bottom(); ++visible;  break;
     case 0x41: Clip0_Bottom();
                if (FC_xn &lt; Wxlef) break;       /* Отброшен */
                Clip1_Left() ;
                if (FC_yk &lt; Wybot) Clip1_Bottom();
                ++visible;
                break;
     case 0x42: Clip0_Bottom();
                if (FC_xn &gt; Wxrig) break;       /* Отброшен */
                Clip1_Right();
                ++visible;
     case 0x44:
     case 0x45:
     case 0x46: break;                          /* Отброшен */
     case 0x48: Clip0_Bottom();
                Clip1_Top();
                ++visible;
                break;
     case 0x49: Clip0_Bottom();
                if (FC_xn &lt; Wxlef) break;       /* Отброшен */
                Clip1_Left() ;
                if (FC_yk &gt; Wytop) Clip1_Top();
                ++visible;
                break;
     case 0x4A: Clip0_Bottom();
                if (FC_xn &gt; Wxrig) break;       /* Отброшен */
                Clip1_Right();
                if (FC_yk &gt; Wytop) Clip1_Top();
                ++visible;
                break;
</PRE>
<P>
<P><BR><PRE>     /* Снизу слева */

     case 0x50: Clip0_Left();
                if (FC_yn &lt; Wybot) Clip0_Bottom();
                ++visible;
     case 0x51: break;                          /* Отброшен */
     case 0x52: Clip1_Right();
                if (FC_yk &lt; Wybot) break;       /* Отброшен */
                Clip0_Bottom();
                if (FC_xn &lt; Wxlef) Clip0_Left();
                ++visible;
     case 0x54:
     case 0x55:
     case 0x56: break;                          /* Отброшен */
     case 0x58: Clip1_Top();
                if (FC_xk &lt; Wxlef) break;       /* Отброшен */
                Clip0_Bottom();
                if (FC_xn &lt; Wxlef) Clip0_Left();
                ++visible;
     case 0x59: break;                          /* Отброшен */
     case 0x5A: Clip0_Left();
                if (FC_yn &gt; Wytop) break;       /* Отброшен */
                Clip1_Right();
                if (FC_yk &lt; Wybot) break;       /* Отброшен */
                if (FC_yn &lt; Wybot) Clip0_Bottom();
                if (FC_yk &gt; Wytop) Clip1_Top();
                ++visible;
                break;
</PRE>
<P>
<P><BR><PRE>     /* Снизу-справа */

     case 0x60: Clip0_Right();
                if (FC_yn &lt; Wybot) Clip0_Bottom();
                ++visible;
                break;
     case 0x61: Clip1_Left() ;
                if (FC_yk &lt; Wybot) break;       /* Отброшен */
                Clip0_Bottom();
                if (FC_xn &gt; Wxrig) Clip0_Right();
                ++visible;
     case 0x62:
     case 0x64:
     case 0x65:
     case 0x66: break;                          /* Отброшен */
     case 0x68: Clip1_Top();
                if (FC_xk &gt; Wxrig) break;       /* Отброшен */
                Clip0_Right();
                if (FC_yn &lt; Wybot) Clip0_Bottom();
                ++visible;
                break;
     case 0x69: Clip1_Left() ;
                if (FC_yk &lt; Wybot) break;       /* Отброшен */
                Clip0_Right();
                if (FC_yn &gt; Wytop) break;       /* Отброшен */
                if (FC_yk &gt; Wytop) Clip1_Top();
                if (FC_yn &lt; Wybot) Clip0_Bottom();
                ++visible;
     case 0x6A: break;                          /* Отброшен */
</PRE>
<P>
<P><BR><PRE>     /* Сверху */

     case 0x80: Clip0_Top();
                ++visible;
                break;
     case 0x81: Clip0_Top();
                if (FC_xn &lt; Wxlef) break;       /* Отброшен */
                Clip1_Left() ;
                ++visible;
                break;
     case 0x82: Clip0_Top();
                if (FC_xn &gt; Wxrig) break;       /* Отброшен */
                Clip1_Right();
                ++visible;
                break;
     case 0x84: Clip0_Top();
                Clip1_Bottom();
                ++visible;
                break;
     case 0x85: Clip0_Top();
                if (FC_xn &lt; Wxlef) break;       /* Отброшен */
                Clip1_Left() ;
                if (FC_yk &lt; Wybot) Clip1_Bottom();
                ++visible;
                break;
     case 0x86: Clip0_Top();
                if (FC_xn &gt; Wxrig) break;       /* Отброшен */
                Clip1_Right();
                if (FC_yk &lt; Wybot) Clip1_Bottom();
                ++visible;
     case 0x88:
     case 0x89:
     case 0x8A: break;                          /* Отброшен */
</PRE>
<P>
<P><BR><PRE>     /* Сверху-слева */

     case 0x90: Clip0_Left();
                if (FC_yn &gt; Wytop) Clip0_Top();
                ++visible;
     case 0x91: break;                          /* Отброшен */
     case 0x92: Clip1_Right();
                if (FC_yk &gt; Wytop) break;       /* Отброшен */
                Clip0_Top();
                if (FC_xn &lt; Wxlef) Clip0_Left();
                ++visible;
                break;
     case 0x94: Clip1_Bottom();
                if (FC_xk &lt; Wxlef) break;       /* Отброшен */
                Clip0_Left();
                if (FC_yn &gt; Wytop) Clip0_Top();
                ++visible;
     case 0x95: break;                          /* Отброшен */
     case 0x96: Clip0_Left();
                if (FC_yn &lt; Wybot) break;       /* Отброшен */
                Clip1_Right();
                if (FC_yk &gt; Wytop) break;       /* Отброшен */
                if (FC_yn &gt; Wytop) Clip0_Top();
                if (FC_yk &lt; Wybot) Clip1_Bottom();
                ++visible;
     case 0x98:
     case 0x99:
     case 0x9A: break;                          /* Отброшен */
</PRE>
<P>
<P><BR><PRE>     /* Сверху-справа */

     case 0xA0: Clip0_Right();
                if (FC_yn &gt; Wytop) Clip0_Top();
                ++visible;
                break;
     case 0xA1: Clip1_Left() ;
                if (FC_yk &gt; Wytop) break;       /* Отброшен */
                Clip0_Top();
                if (FC_xn &gt; Wxrig) Clip0_Right();
                ++visible;
     case 0xA2: break;                          /* Отброшен */
     case 0xA4: Clip1_Bottom();
                if (FC_xk &gt; Wxrig) break;       /* Отброшен */
                Clip0_Right();
                if (FC_yn &gt; Wytop) Clip0_Top();
                ++visible;
                break;
     case 0xA5: Clip1_Left() ;
                if (FC_yk &gt; Wytop) break;       /* Отброшен */
                Clip0_Right();
                if (FC_yn &lt; Wybot) break;       /* Отброшен */
                if (FC_yk &lt; Wybot) Clip1_Bottom();
                if (FC_yn &gt; Wytop) Clip0_Top();
                ++visible;
     case 0xA6:                                 /* Отброшен */
     case 0xA8:
     case 0xA9:
     case 0xAA: break;
</PRE>
<P>
<P><BR><PRE>     /* Ошибка */

     default:   visible= -1;
                break;
   }  /* switch */

   if (visible &gt; 0) {
      *x0= FC_xn;  *y0= FC_yn;
      *x1= FC_xk;  *y1= FC_yk;
   }
   return (visible);
}  /* V_FCclip */
</PRE>
<P>
<P><BR>
<CENTER>
<H3><A name=tth_sEc0.18.6>0.18.6</A>&nbsp;&nbsp;V_LBclip - алгоритм 
Лианга-Барски</H3></CENTER>
<P><PRE>/*--------------------------------------------------- V_LBclip
 *  Реализует алгоритм отсечения Лианга-Барски
 *  с параметрическим заданием линий
 *
 * int  V_LBclip (float *x0, float *y0, float *x1, float *y1)
 *
 * Отсекает отрезок, заданный значениями координат его
 * точек (x0,y0), (x1,y1), по окну отсечения, заданному
 * глобальными скалярами Wxlef, Wybot, Wxrig, Wytop
 *
 * Возвращает:
 *  0 - отрезок не видим
 *  1 - отрезок видим
 */

static float LB_t0, LB_t1;

static int  LB_tclip (p, q)
float p, q;
{
   int   accept;
   float r;

   accept= 1;                           /* Отрезок принят */
   if (p == 0) {
      if (q &lt; 0) accept= 0;             /* Отбрасывание */
   } else {
      r= q/p;
      if (p &lt; 0) {
         if (r &gt; LB_t1) accept= 0;      /* Отбрасывание */
         else if (r &gt; LB_t0) LB_t0= r;
      } else {
         if (r &lt; LB_t0) accept= 0;      /* Отбрасывание */
         else if (r &lt; LB_t1) LB_t1= r;
      }
   }
   return (accept);
}  /* LB_tclip */
</PRE>
<P>
<P><BR><PRE>int  V_LBclip (x0, y0, x1, y1)
float *x0, *y0, *x1, *y1;
{  int   visible;
   float dx, dy;

   visible= 0;
   LB_t0= 0;  LB_t1= 1;
   dx= *x1 - *x0;
   if (LB_tclip (-dx, *x0-Wxlef)) {
      if (LB_tclip (dx, Wxrig-*x0)) {
         dy= *y1 - *y0;
         if (LB_tclip (-dy, *y0-Wybot)) {
            if (LB_tclip (dy, Wytop-*y0)) {
               if (LB_t1 &lt; 1) {
                  *x1= *x0 + LB_t1*dx;
                  *y1= *y0 + LB_t1*dy;
               }
               if (LB_t0 &gt; 0) {
                  *x0= *x0 + LB_t0*dx;
                  *y0= *y0 + LB_t0*dy;
               }
               ++visible;
            }
         }
      }
   }
   return (visible);
}  /* V_LBclip */
</PRE>
<P>
<P><BR>
<CENTER>
<H3><A name=tth_sEc0.18.7>0.18.7</A>&nbsp;&nbsp;V_CBclip - алгоритм 
Кируса-Бека</H3></CENTER>
<P><PRE>/*--------------------------------------------------- V_CBclip
 *  Реализует алгоритм отсечения Кируса-Бека
 *  по произвольному выпуклому многоугольнику
 *  с параметрическим заданием линий
 *
 * int  V_CBclip (float *x0, float *y0, float *x1, float *y1)
 *
 * Отсекает отрезок, заданный значениями координат его
 * точек (x0,y0), (x1,y1), по окну отсечения, заданному
 * глобальными скалярами:
 * int   Windn - количество вершин в окне отсечения
 * float *Windx, *Windy   - массивы X,Y координат вершин
 * float *Wnormx, *Wnormy - массивы координат нормалей
 *                          к ребрам
 *
 * Возвращает:
 *  0 - отрезок не видим
 *  1 - отрезок видим
 */
</PRE>
<P>
<P><BR><PRE>int  V_CBclip (x0, y0, x1, y1)
float *x0, *y0, *x1, *y1;
{  int   ii, jj, visible, kw;
   float xn, yn, dx, dy, r;
   float CB_t0, CB_t1;          /* Параметры концов отрезка */
   float Qx, Qy;                /* Положение относ ребра */
   float Nx, Ny;                /* Перпендикуляр к ребру */
   float Pn, Qn;                /**/

   kw= Windn - 1;               /* Ребер в окне */
   visible= 1;
   CB_t0= 0;  CB_t1= 1;
   dx= *x1 - (xn= *x0);
   dy= *y1 - (yn= *y0);

   for (ii=0; ii&lt;=kw; ++ii) {   /* Цикл по ребрам окна */
      Qx= xn - Windx[ii];       /* Положения относ ребра */
      Qy= yn - Windy[ii];
      Nx= Wnormx[ii];           /* Перепендикуляр к ребру */
      Ny= Wnormy[ii];
      Pn= dx*Nx + dy*Ny;        /* Скалярные произведения */
      Qn= Qx*Nx + Qy*Ny;

/* Анализ расположения */
      if (Pn == 0) {            /* Паралл ребру или точка */
         if (Qn &lt; 0) {visible= 0;  break; }
      } else {
         r= -Qn/Pn;
         if (Pn &lt; 0) {          /* Поиск верхнего предела t */
            if (r &lt; CB_t0) {visible= 0;  break; }
            if (r &lt; CB_t1) CB_t1= r;
         } else {               /* Поиск нижнего предела t */
            if (r &gt; CB_t1) {visible= 0;  break; }
            if (r &gt; CB_t0) CB_t0= r;
         }
      }
   }
   if (visible) {
      if (CB_t0 &gt; CB_t1) visible= 0; else {
         if (CB_t0 &gt; 0) {
            *x0= xn + CB_t0*dx;
            *y0= yn + CB_t0*dy;
         }
         if (CB_t1 &lt; 1) {
            *x1= xn + CB_t1*dx;
            *y1= yn + CB_t1*dy;
         }
      }
   }
   return (visible);
}  /* V_CBclip */
</PRE>
<P>
<P><BR>
<CENTER>
<H3><A name=tth_sEc0.18.8>0.18.8</A>&nbsp;&nbsp;Тест процедур 
отсечения</H3></CENTER>
<P><PRE>/*=================================================== T_CLIP.C
 *
 * ТЕСТ ПРОЦЕДУР ОТСЕЧЕНИЯ
 */

#include &lt;time.h&gt;
#include &lt;stdio.h&gt;

/*--------------------------------------------------- V_DMclip
 *  Пустышка для процедур отсечения
 */

int  V_DMclip (x0, y0, x1, y1)
float *x0, *y0, *x1, *y1;
{  int   visible;
   visible= 1;
   return (visible);
}  /* V_DMclip */
</PRE>
<P>
<P><BR><PRE>/*---------------------------------------------------- ClipMsg
 * Печатает сообщение о результатах отсечения
 */
void ClipMsg (proc, visible, x0, y0, x1, y1, dt)
char *proc; int visible; float x0, y0, x1, y1, dt;
{
   if (visible &lt; 0) {
      printf("*** ERROR (%s LineClip) - ", proc);
      printf("ошибка в координатах окна. ");
      printf("Прерывание с кодом ошибки 1.");
      exit (1);
   } else if (visible == 0)
      printf ("%s: Line is no visible dt=%f\n", proc, dt);
   else
      printf ("%s: ClipLine: x0=%f y0=%f x1=%f y1=%f dt=%f\n",
               proc, x0, y0, x1, y1, dt);
}  /* ClipMsg */
</PRE>
<P>
<P><BR><PRE>/*---------------------------------------------- MAIN T_CLIP.C
 */
void main (void)
{
   float Wxn, Wyn, Wxk, Wyk;
   float Xn, Yn, Xk, Yk, x0, y0, x1, y1;
   int   ii, numb= 1;
   float X_wind[100], Y_wind[100];
   float X_norm[100], Y_norm[100];
   int  visible;
   float dt;
   time_t t1, t2;
   long  ll, powt=10l;

   if (numb) goto set_win;

m0:printf ("----Вершин= %d ? ", numb);
   scanf  ("%d", &amp;numb);
   for (ii=0; ii&lt;numb; ++ii) {
      printf ("X_wind[%d], Y_wind[%d] ? ", ii, ii);
      scanf  ("%f%f", &amp;X_wind[ii], &amp;Y_wind[ii]);
   }
   ii= V_SetPclip (numb, X_wind, Y_wind, X_norm, Y_norm);
   printf ("V_SetPclip= %d\n", ii);
   if (ii) goto m0;
   for (ii=0; ii&lt;numb; ++ii)
      printf ("ind=%d X_norm=%f, Y_norm=%f\n",
               ii, X_norm[ii], Y_norm[ii]);
   if (ii) goto m0;


/* Задание окна отсечения */
set_win:
   powt= 1l;
   V_GetRclip (&amp;Wxn, &amp;Wyn, &amp;Wxk, &amp;Wyk);
   for (;;) {
      printf ("Window: (Xn=%f Yn=%f Xk=%f Yk=%f) ? ",
               Wxn, Wyn, Wxk, Wyk);
      scanf  ("%f%f%f%f", &amp;Wxn, &amp;Wyn, &amp;Wxk, &amp;Wyk);
      if (!V_SetRclip (Wxn, Wyn, Wxk, Wyk)) break;
      printf ("Error in a window boundarys\n");
   }

/* Ввод координат отрезка */
   Xn= Wxn-1.0;  Yn= Wyn-1.0;  Xk= Wxk+1.0;  Yk= Wyk+1.0;

   for (;;) {
      printf ("------------- ");
      printf ("ClipWindow: Xn=%f Yn=%f Xk=%f Yk=%f\n",
               Wxlef, Wybot, Wxrig, Wytop);
      printf ("New Line: (Xn=%f Yn=%f Xk=%f Yk=%f) ? ",
               Xn, Yn, Xk, Yk);
      scanf  ("%f%f%f%f", &amp;Xn, &amp;Yn, &amp;Xk, &amp;Yk);

      ll= powt;
      t1= time(NULL);
      do {
         x0= Xn; y0= Yn; x1= Xk; y1= Yk;
         visible= V_DMclip (&amp;x0, &amp;y0, &amp;x1, &amp;y1);
      } while (--ll &gt; 0l);
      t2= time (NULL);
      dt= ((float)(t2 - t1));
      ClipMsg ("DM", visible, x0, y0, x1, y1, dt);
</PRE>
<P>
<P><BR><PRE>      ll= powt;
      t1= time(NULL);
      do {
         x0= Xn; y0= Yn; x1= Xk; y1= Yk;
         visible= V_CSclip (&amp;x0, &amp;y0, &amp;x1, &amp;y1);
      } while (--ll &gt; 0l);
      t2= time (NULL);
      dt= ((float)(t2 - t1));
      ClipMsg ("CS", visible, x0, y0, x1, y1, dt);

      ll= powt;
      t1= time(NULL);
      do {
         x0= Xn; y0= Yn; x1= Xk; y1= Yk;
         visible= V_FCclip (&amp;x0, &amp;y0, &amp;x1, &amp;y1);
      } while (--ll &gt; 0l);
      t2= time (NULL);
      dt= ((float)(t2 - t1));
      ClipMsg ("FC", visible, x0, y0, x1, y1, dt);

      ll= powt;
      t1= time(NULL);
      do {
         x0= Xn; y0= Yn; x1= Xk; y1= Yk;
         visible= V_LBclip (&amp;x0, &amp;y0, &amp;x1, &amp;y1);
      } while (--ll &gt; 0l);
      t2= time (NULL);
      dt= ((float)(t2 - t1));
      ClipMsg ("LB", visible, x0, y0, x1, y1, dt);

      ll= powt;
      t1= time(NULL);
      do {
         x0= Xn; y0= Yn; x1= Xk; y1= Yk;
         visible= V_CBclip (&amp;x0, &amp;y0, &amp;x1, &amp;y1);
      } while (--ll &gt; 0l);
      t2= time (NULL);
      dt= ((float)(t2 - t1));
      ClipMsg ("CB", visible, x0, y0, x1, y1, dt);
   }
}
</PRE>
<CENTER>
<H3><A name=tth_sEc0.19>0.19</A>&nbsp;&nbsp;Приложение 8. Процедуры отсечения 
многоугольника</H3></CENTER>
<P>В данном приложении содержатся процедуры V_Plclip, реализующие простой 
алгоритм отсечения произвольного многоугольника по выпуклому многоугольному окну 
отсечения и тестовая программа проверки их работы. 
<P>Процедуры реализуют алгоритм, который, как и алгоритм Сазерленда-Ходгмана, 
последовательно отсекает весь многоугольник по каждому из ребер окна отсечения. 
<P>
<CENTER>
<H3><A name=tth_sEc0.19.1>0.19.1</A>&nbsp;&nbsp;V_Plclip - простой алгоритм 
отсечения многоугольника</H3></CENTER>
<P><PRE>/*=================================================== V_PLCLIP
 * Файл V_PLCLIP.C - процедуры простого алгоритма отсечния
 *                   многоугольника
 * Последняя редакция:
 * 25.12.93  17:25
 */

#include &lt;graphics.h&gt;
#include "V_WINDOW.C"   /* Глобалы и проц работы с окнами */

/* Включаемый файл V_WINDOW.C содержит
 * подрограммы и глобалы для окон:
 *
 * V_SetPclip - установить размеры многоугольного окна
 *              отсечения
 * V_GetPclip - опросить параметры многоугольного окна
 *              отсечения
 * V_SetRclip - установить размеры прямоугольного окна
 *              отсечения
 * V_GetRclip - опросить   размеры прямоугольного окна
 *              отсечения
 *
 * Глобальные скаляры для алгоритмов отсечения по
 * прямоугольному окну - Коэна-Сазерленда, Fc-алгоритм,
 * Лианга-Барски
 *
 * static float Wxlef= 100.0, -- Координаты левого нижнего и
 *              Wybot= 100.0, -- правого верхнего углов окна
 *              Wxrig= 300.0, -- отсечения
 *              Wytop= 200.0;
 *
 * Глобальные скаляры для алгоритма Кируса-Бека
 * отсечения по многоугольному окну
 *
 * Координаты прямоугольного окна
 * static float Wxrect[4]= {100.0, 100.0, 300.0, 300.0 };
 * static float Wyrect[4]= {100.0, 200.0, 200.0, 100.0 };
 *
 * Перепендикуляры к сторонам прямоугольного окна
 * static float WxNrec[4]= {1.0,  0.0, -1.0, 0.0 };
 * static float WyNrec[4]= {0.0, -1.0,  0.0, 1.0 };
 *
 * Данные для многоугольного окна
 * static int   Windn=4;          -- Кол-во вершин у окна
 * static float *Windx=  Wxrect,  -- Координаты вершин окна
 *              *Windy=  Wyrect;
 * static float *Wnormx= WxNrec,  -- Координаты нормалей
 *              *Wnormy= WyNrec;
 */
</PRE>
<P>
<P><BR><PRE>/*-------------------------------------------------- Pl_clip0
 * Служебная процедура, отсекает многоугольник
 * относительно одного ребра окна
 *
 * Отсечение выполняется в цикле по сторонам многоугольника
 * При первом входе в цикл только вычисляются величины для
 * начальной точки: координаты, скалярное произведение,
 * определяющее ее расположение относительно ребра окна, и
 * код расположения.
 * При последующих входах в цикл эти значения вычисляются
 * для очередной вершины.
 * По значениям кодов расположения вершин для стороны
 * многоугольника определяется как она расположена
 * относительно ребра и вычисляются координаты результирующего
 * многоугольника.
 */

static int Pl_clip0 (N_reb, N_in, X_in, Y_in, X_ou, Y_ou)
int   N_reb, N_in;
float *X_in, *Y_in, *X_ou, *Y_ou;
{
   int  ii, jj;
   int  pozb,      /* Коды расположения начальной точки  */
        pozn,      /* многоугольника и точек тек стороны */
        pozk;      /* 0/1/2 - пред точка вне/на/внутри   */
   float Rx,Ry;    /* Координаты начала ребра окна */
   float Nx, Ny;   /* Нормаль к  ребру окна */
   float xb, yb;   /* Начальная точка многоугольника  */
   float xn, yn;   /* Начальная точка текущей стороны */
   float xk, yk;   /* Конечная  точка текущей стороны */
   float t;        /* Значение параметра точки пересечения */
   float Qb,Qn,Qk; /* Скалярные произведения */
   float *ptx_ou;

/* Запрос параметров ребра окна */
   Rx= Windx[N_reb];  Ry= Windy[N_reb];
   Nx= Wnormx[N_reb]; Ny= Wnormy[N_reb];

/* Цикл отсчения многоугольника ребром окна */
   ii= 0;  ++N_in;  ptx_ou= X_ou;
   while (--N_in &gt;= 0) {
      if (N_in) {
         xk= *X_in++;  yk= *Y_in++;   /* Кон точка стороны  */
         Qk= (xk-Rx)*Nx + (yk-Ry)*Ny; /* Параметр положения */
         pozk= 1;                     /* 1 - точка на гр. */
         if (Qk &lt; 0) --pozk; else     /* 0 - точка вне    */
         if (Qk &gt; 0) ++pozk;          /* 2 - точка внутри */
      } else {
         xk= xb;  yk= yb;  Qk= Qb;  pozk= pozb;
      }
      if (!ii) {
         xb= xn= xk; yb= yn= yk; Qb= Qn= Qk; pozb= pozn= pozk;
         ++ii; continue;
      }
      jj= 0;
      switch (pozn*3 + pozk) {     /* Стар Нов Выход     */
         case 0: goto no_point;    /*  вне-вне нет       */
         case 1: goto endpoint;    /*  вне-на  конечная  */
         case 2: goto intersec;    /*  вне-вну перес,кон */
         case 3: goto no_point;    /*  на -вне нет       */
         case 4:                   /*  на -на  конечная  */
         case 5: goto endpoint;    /*  на -вну конечная  */
         case 6: goto no_end;      /*  вну-вне пересечен */
         case 7:                   /*  вну-на  конечная  */
         case 8: goto endpoint;    /*  вну-вну конечная  */
      }
no_end: ++jj;
intersec:
      t= Qn/(Qn-Qk);
      *X_ou++= xn + t*(xk-xn);
      *Y_ou++= yn + t*(yk-yn);
      if (!jj) {
endpoint:
         *X_ou++= xk;  *Y_ou++= yk;
      }
no_point:
      xn= xk;  yn= yk;  Qn= Qk;  pozn= pozk;
   }
   return (X_ou - ptx_ou);
}  /* Pl_clip0 */
</PRE>
<P>
<P><BR><PRE>/*--------------------------------------------------- V_Plclip
 * Простая процедура отсечения многоугольника
 * N_in       - число вершин во входном многоугольнике
 * X_in, Y_in - координаты вершин отсекаемого мног-ка
 *              этот массив будет испорчен
 * Возвращает:
 *  &lt; 0 - ошибки
 * &gt;= 0 - количество вершин в выходном многоугольнике
 * X_ou, Y_ou - координаты вершин отсеченного многоугольника
 */

int  V_Plclip (N_in, X_in, Y_in, X_ou, Y_ou)
int   N_in;
float *X_in, *Y_in, *X_ou, *Y_ou;
{
   int  ii, N_ou; float *ptr;

   if ((N_ou= N_in) &lt; 3) {N_ou= -1;  goto all; }
   if (Windn &lt; 3) {N_ou= -2;  goto all; }
   for (ii=0; ii&lt;Windn; ++ii) {
      N_ou= Pl_clip0 (ii, N_ou, X_in, Y_in, X_ou, Y_ou);
      ptr= X_in;  X_in= X_ou;  X_ou= ptr;
      ptr= Y_in;  Y_in= Y_ou;  Y_ou= ptr;
   }
   if (!(Windn &amp; 1)) {
      ii= N_ou;
      while (--ii &gt;= 0) {*X_ou++= *X_in++; *Y_ou++= *Y_in++; }
   }
all:
   return N_ou;
}  /* V_Plclip */
</PRE>
<P>
<P><BR>
<CENTER>
<H3><A name=tth_sEc0.19.2>0.19.2</A>&nbsp;&nbsp;Тест процедуры 
V_Plclip</H3></CENTER>
<P><PRE>/*=================================================== T_PLCLIP
 * ТЕСТ процедуры V_Plclip для отсечения многоугольника
 *
 * При первом входе устанавливается восьмиугольное окно
 * отсечения:
 * X: 150, 100, 100, 150, 250, 300, 300, 250
 * Y: 100, 150, 250, 300, 300, 250, 150, 100
 *
 * И на нем отсекается треугольник:
 * (10,160),(90,220),(170,160)
 *
 * Затем выдается запрос на количество вершин в
 * новом отсекаемом многоугольнике:
 * --- Vertexs in polyline= XX ?
 * При вводе числа &gt; 0 будут запрашиваться координаты вершин
 *                     много-ка и выполняться его отсечение
 * При вводе числа = 0 программа затребует ввод координат
 *                     нового прямоугольного окна отсечения
 * При вводе числа &lt; 0 программа запросит переустановку
 *                     многоугольного окна отсечения:
 *
 * ----Vertexs in clip window= XX ?
 * При вводе числа &gt; 0 будут запрашиваться координаты вершин.
 * При вводе числа = 0 программа затребует ввод координат
 *                     прямоугольного окна.
 * При вводе числа &lt; 0 программа закончится.
 */
</PRE>
<P>
<P><BR><PRE>#include &lt;graphics.h&gt;
#include "V_PLCLIP.C"

/*--------------------------------------------------- DrawPoly
 * Чертит контур многоугольника
 */
void DrawPoly (col, n, x, y)
int col, n; float *x, *y;
{  int  ii, jj;
   setcolor (col);
   for (ii=0; ii&lt;n; ++ii) {
      if ((jj= ii+1) &gt;= n) jj= 0;
      line (x[ii], y[ii], x[jj], y[jj]);
   }
}  /* DrawPoly */

/*---------------------------------------------------- CLR_STR
 * Зачищает строку выводом в нее пробелов
 */
void CLR_STR (void)
{
printf ("                                                \r");
}

/*------------------------------------------------ PLCLIP_MAIN
 */
void main (void)
{  int   ii, jj,
         fon;           /* Индекс фона  */
   float Wxn,Wyn,       /* Прямоугольный отсекатель */
         Wxk,Wyk;
   int   N_wind= 0;     /* Вводимый отсекатель */
   float X_wind[100],
         Y_wind[100];
   float X_norm[100],
         Y_norm[100];
   int   wnum;          /* Запрошенный отсекатель */
   float *wx,*wy,*wnx,*wny;
   int   N_poly= 0;     /* Отсекаемый многугольник */
   float X_poly[100],
         Y_poly[100];
   int   N_clip= 0;     /* Отсеченный многугольник */
   float X_clip[100],
         Y_clip[100];
   int   entry= 0;      /* 0/1 - нет/был вывод по умолчанию */
   int   gdriver= DETECT, gmode;

   initgraph (&amp;gdriver, &amp;gmode, "");
   fon= 0;                      /* Цвет фона */

   setbkcolor(fon);             /* Очистка экрана */
   cleardevice();

/*--------------- Установить окно отсечения ----------------*/
new_window:
   gotoxy (1,1);
   if (!entry) {
      N_wind= 8;  wx= X_wind;  wy= Y_wind;
      *wx++= 150; *wx++= 100;  *wx++= 100; *wx++= 150;
      *wy++= 100; *wy++= 150;  *wy++= 250; *wy++= 300;

      *wx++= 250; *wx++= 300;  *wx++= 300; *wx++= 250;
      *wy++= 300; *wy++= 250;  *wy++= 150; *wy++= 100;
      goto wr_window;
   }
   if (!N_poly) goto set_rect;
</PRE>
<P>
<P><BR><PRE>/*---------- Задание многоугольного окна отсечения ---------*/
set_window:
   CLR_STR ();
   printf ("----Vertexs in clip window= %d ? ", N_wind);
   scanf  ("%d", &amp;N_wind);
   if (N_wind &lt; 0) goto all;
   if (!N_wind) goto set_rect;
   for (ii=0; ii&lt;N_wind; ++ii) {
      CLR_STR ();
      printf ("X_wind[%d], Y_wind[%d] ? ", ii, ii);
      scanf  ("%f%f", &amp;X_wind[ii], &amp;Y_wind[ii]);
   }
wr_window:
   jj= V_SetPclip (N_wind, X_wind, Y_wind, X_norm, Y_norm);
   if (jj) {
      printf ("Error=%d in polyline window\n", jj);
      goto set_window;
   } else goto ou_win;
</PRE>
<P>
<P><BR><PRE>/*---------- Задание прямоугольного окна отсечения ---------*/
set_rect:
   V_GetRclip (&amp;Wxn, &amp;Wyn, &amp;Wxk, &amp;Wyk);
get_rect:
   CLR_STR ();
   printf ("Rect window: (Xn=%f Yn=%f Xk=%f Yk=%f) ? ",
            Wxn, Wyn, Wxk, Wyk);
   scanf  ("%f%f%f%f", &amp;Wxn, &amp;Wyn, &amp;Wxk, &amp;Wyk);
wr_rect:
   jj= V_SetRclip (Wxn, Wyn, Wxk, Wyk);
   if (jj) {
      printf ("Error=%d in rectangle window\n", jj);
      goto get_rect;
   }
</PRE>
<P>
<P><BR><PRE>/*--------------- Прорисовка окна отсечения ----------------*/
ou_win:
   wnum= V_GetPclip (&amp;wx, &amp;wy, &amp;wnx, &amp;wny);
   DrawPoly (LIGHTRED, wnum, wx, wy);
</PRE>
<P>
<P><BR><PRE>/*------- Ввод координат отсекаемого многоугольника --------*/

set_poly:
   gotoxy (1,1);
   if (!entry) { /* При первом входе отрисовка по умолчанию */
      N_poly= 3;
      X_poly[0]=  10;  X_poly[1]=  90;  X_poly[2]= 170;
      Y_poly[0]= 160;  Y_poly[1]= 220;  Y_poly[2]= 160;
   } else {
      CLR_STR ();
      printf ("--- Vertexs in polyline= %d ? ",N_poly);
      scanf  ("%d", &amp;N_poly);
      if (N_poly &lt;= 0) goto new_window;
      for (ii=0; ii&lt;N_poly; ++ii) {
         printf ("                                   \r");
         printf ("X_poly[%d], Y_poly[%d] ? ", ii, ii);
         scanf  ("%f%f", &amp;X_poly[ii], &amp;Y_poly[ii]);
      }
   }
   ++entry;

/*---------- Прорисовка отсекателя и отсекаемого -----------*/
   wnum= V_GetPclip (&amp;wx, &amp;wy, &amp;wnx, &amp;wny);
   DrawPoly (LIGHTRED, wnum, wx, wy);
   DrawPoly (LIGHTGREEN, N_poly, X_poly, Y_poly);


/*----------------------- Отсечение ------------------------*/
   N_clip= V_Plclip(N_poly, X_poly, Y_poly, X_clip, Y_clip);

/*----------------- Прорисовка отсеченного -----------------*/
   DrawPoly (YELLOW, N_clip, X_clip, Y_clip);
   goto set_poly;

all:
   closegraph();
}  /* PLCLIP_MAIN */
</PRE>
<P><A name=tthFtNtAAB></A><A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#tthFrefAAB"><SUP>1</SUP></A> 
Переход к модели с перечислением занятых точек также возможен из любой другой, 
но при решении проблем точности аппроксимации. 
<DIV align=center>
<H3><FONT color=#0000ff face=""><A 
href="http://ermak.cs.nstu.ru/kg_rivs/kg02.htm#top" title="В начало ...">В 
начало документа</A> , <A href="http://ermak.cs.nstu.ru/kg_rivs/home.htm#top" 
title=Домой>На основную страничку</A></FONT></H3>
<H3><FONT color=#ff0000 face=""></FONT></H3></DIV></BODY></HTML>
